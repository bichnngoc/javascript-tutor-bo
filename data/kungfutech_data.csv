id,bai,tieude,noidung
1,Arrow function trong JavaScript,Giới thiệu,"Ngoàifunction declarationvàfunction expression, JavaScript còn cóarrow function. Trong bài viết này, mình sẽ trình bày về arrow function là gì và cách sử dụng arrow function cơ bản."
2,Arrow function trong JavaScript,Arrow function trong Javascript là gì?,"Arrow function trong JavaScript là hàm sử dụng kí hiệu=>để định nghĩa, với cú pháp cơ bản như sau:
`=>` 
```js
let func = (arg1, arg2,..., argN) => expression;
```
`let func = (arg1, arg2,..., argN) => expression;` Hàm trên nhận danh sách tham số là(arg1, arg2,..., argN), sau đó thực hiện biểu thứcexpressionrồireturnvề kết quả của biểu thứcexpression.
`(arg1, arg2,..., argN)` `expression` `return` `expression` Nói cách khác, đây là cách biểu diễn rút gọn của biểu thức hàm:

```js
let func = function(arg1, arg2,..., argN) {
      return expression;
    }
```
`let func = function(arg1, arg2,..., argN) {
      return expression;
    }` Ví dụ sử dụng arrow function trả về tổng của hai số:

```js
let sum = (a, b) => a + b;
console.log(sum(1, 2)); // 3
```
`let sum = (a, b) => a + b;
console.log(sum(1, 2)); // 3` Hàmsumnhận vào hai tham số làavàb. Sau đó, hàm này tính tổnga + brồi trả về giá trị tổng đó.
`sum` `a` `b` `a + b` Nếu arrow function có một tham số thì bạn có thể bỏ qua cặp dấu(), ví dụ:
`()` 
```js
let square = (n) => n * n;
```
`let square = (n) => n * n;` Trường hợp, arrow function không có tham số nào, thì bạn nên viết cặp dấu():
`()` 
```js
let sayHello = () => console.log(""Hello!"");
```
`let sayHello = () => console.log(""Hello!"");`"
3,Arrow function trong JavaScript,Sử dụng arrow function,"Arrow function có thể được sử dụng giống như function expression.
Ví dụ khởi tạo hàm dựa trên điều kiện:

```js
let isVietnamese = confirm(""Bạn có phải người Việt Nam không?"");
let welcome = isVietnamese
  ? () => console.log(""Chào bạn!"")
  : () => console.log(""Hello!"");
welcome();
```
`let isVietnamese = confirm(""Bạn có phải người Việt Nam không?"");
let welcome = isVietnamese
  ? () => console.log(""Chào bạn!"")
  : () => console.log(""Hello!"");
welcome();` Ví dụ sử dụng arrow function làm hàm callback:

```js
function ask(question, handleYes, handleNo) {
  const answer = confirm(question);
  if (answer) {
    handleYes();
  } else {
    handleNo();
  }
}

ask(
  ""Bạn muốn tiếp tục thực hiện chương trình không?"",
  () => console.log(""Bạn đã chọn Yes!""),
  () => console.log(""Bạn đã chọn No!"")
);
```
`function ask(question, handleYes, handleNo) {
  const answer = confirm(question);
  if (answer) {
    handleYes();
  } else {
    handleNo();
  }
}

ask(
  ""Bạn muốn tiếp tục thực hiện chương trình không?"",
  () => console.log(""Bạn đã chọn Yes!""),
  () => console.log(""Bạn đã chọn No!"")
);`"
4,Arrow function trong JavaScript,Arrow function với nhiều dòng code,"Trong các ví dụ trên, thành phầnexpressionchỉ là một dòng code. Tuy nhiên, bạn cũng có thể viết nhiều dòng code bằng cách đặt chúng vào trong cặp dấu{}và sử dụng từ khóareturnđể trả về giá trị.
`expression` `{}` `return` Ví dụ arrow function tính tổng hai số với nhiều dòng code:

```js
let sum = (a, b) => {
  return a + b;
};

console.log(sum(1, 2)); // 3
```
`let sum = (a, b) => {
  return a + b;
};

console.log(sum(1, 2)); // 3`"
5,Arrow function trong JavaScript,Tổng kết,"Vậy arrow function là gì?
Arrow function là hàm sử dụng kí tự=>để khai báo hàm, giúp việc khai báo hàm trở nên ngắn gọn hơn.
`=>` Cú pháp cơ bản là:

```js
let func = (arg1, arg2,..., argN) => expression;
```
`let func = (arg1, arg2,..., argN) => expression;` Arrow function trên nhận vào danh sách tham số(arg1, arg2,..., argN), thành phầnexpressionđược xử lý và trả về giá trị củaexpression.
`(arg1, arg2,..., argN)` `expression` `expression` Trường hợp có dấu{}, bạn cần sử dụng thêm từ khóareturnđể trả về giá trị của hàm.
`{}` `return` 
```js
let func = (arg1, arg2,..., argN) => {
      expression;
      return something;
    }
```
`let func = (arg1, arg2,..., argN) => {
      expression;
      return something;
    }` Arrow function có thể được sử dụng giống như function expression."
6,Arrow function trong JavaScript,Thực hành,"Viết arrow function trả về giá trị nhỏ nhất của hai số (giả sử giá trị truyền nào luôn là số).
Xem đáp án

```js
let min = (a, b) => (a < b ? a : b);

min(2, 5); // 2
min(4, -1); // -1
min(3, 3); // 3
```
`let min = (a, b) => (a < b ? a : b);

min(2, 5); // 2
min(4, -1); // -1
min(3, 3); // 3` Trường hợp hai số truyền vào bằng nhau thì dĩ nhiên kết quả là giá trị của hai số đó.
Viết arrow function kiểm tra xem một số có phải là số nguyên tố hay không. Nếu là số nguyên tố thì trả vềtrue. Ngược lại, trả vềfalse.
`true` `false` Sau đó, in ra các số nguyên tố từ 1 đến 10.
Xem đáp án

```js
// Hàm kiểm tra số nguyên tố
const isPrime = (number) => {
  if (isNaN(number)) return false;

  if (number < 2) return false;
  if (number === 2) return true;

  for (i = 2; i * i <= number; i++) {
    if (number % i === 0) return false;
  }

  return true;
};

// Duyệt từ 1 đến 10 để in ra số nguyên tố
for (let i = 1; i <= 10; i++) {
  if (isPrime(i)) {
    console.log(i);
  }
}

// 2
// 3
// 5
// 7
```
`// Hàm kiểm tra số nguyên tố
const isPrime = (number) => {
  if (isNaN(number)) return false;

  if (number < 2) return false;
  if (number === 2) return true;

  for (i = 2; i * i <= number; i++) {
    if (number % i === 0) return false;
  }

  return true;
};

// Duyệt từ 1 đến 10 để in ra số nguyên tố
for (let i = 1; i <= 10; i++) {
  if (isPrime(i)) {
    console.log(i);
  }
}

// 2
// 3
// 5
// 7` Trong đó:
`isNaN(number)` `number` `NaN` `isNaN(number)` `false` `number`"
7,Bất đồng bộ song song hay tuần tự?,Giới thiệu,"Có thể bạn đã quen với việcxử lý bất đồng bộtrong JavaScript với Promise hoặc Async/await rồi. Tuy nhiên, khi bạn có một chuỗi các hành động thì câu hỏi đặt ra là: bạn sẽ xử lý chúng như thế nào? Bạn quyết định xử lý bất đồng bộ song song hay tuần tự?
Câu trả lời có lẽ sẽ phụ thuộc vào từng trường hợp. Tuy nhiên, để biết được nên lựa chọn cách nào thì bạn cần phải biết ý nghĩa và cách triển khai của từng trường hợp.
Bài viết này sẽ giới thiệu với bạn về 2 cách xử lý bất đồng bộ. Mời bạn theo dõi bài viết!"
8,Bất đồng bộ song song hay tuần tự?,Định nghĩa bài toán,"Giả sử, mình cómột công việcbất đồng bộ là: lấy thông tin bài viết (getPost). Công việc này bao gồm3 hành độngbất đồng bộ là:

```js
const wait = (ms) => {
  return new Promise((res) => setTimeout(res, ms));
};

const getContent = async () => {
  await wait(1000);
  return ""This is content"";
};

const getComments = async () => {
  await wait(1500);
  return [""comment 1"", ""comment 2""];
};

const getRelatedPosts = async () => {
  await wait(2000);
  return [""post 2"", ""post 3"", ""post 4""];
};

const getPost = async () => {
  // TODO: Implement later
};
```
`const wait = (ms) => {
  return new Promise((res) => setTimeout(res, ms));
};

const getContent = async () => {
  await wait(1000);
  return ""This is content"";
};

const getComments = async () => {
  await wait(1500);
  return [""comment 1"", ""comment 2""];
};

const getRelatedPosts = async () => {
  await wait(2000);
  return [""post 2"", ""post 3"", ""post 4""];
};

const getPost = async () => {
  // TODO: Implement later
};` Với công việc như trên, mình sẽ thử triển khai theo cách xử lý bất đồng bộ tuần tự và cách xử lý bất đồng bộ song song, sau đó sẽ kiểm tra xem cách nào tốt hơn nhé!"
9,Bất đồng bộ song song hay tuần tự?,Xử lý bất đồng bộ tuần tự,"Với cách này, 3 hành độnggetContent,getCommentsvàgetRelatedPostssẽ thực hiện tuần tự nhau. Nếu sử dụng async/await thì kết quả sẽ như sau:

```js
const getPost = async () => {
  console.time(""time"");

  const content = await getContent();
  const comments = await getComments();
  const relatedPosts = await getRelatedPosts();

  console.log(`Post Info: `, { content, comments, relatedPosts });
  console.timeEnd(""time"");
};

getPost();
/*
    Post Info:
    {
      comments:  [""comment 1"", ""comment 2""]
      content: ""This is content""
      relatedPosts: [""post 2"", ""post 3"", ""post 4""]
    }
    time: 4504.9638671875ms
    */
```
`const getPost = async () => {
  console.time(""time"");

  const content = await getContent();
  const comments = await getComments();
  const relatedPosts = await getRelatedPosts();

  console.log(`Post Info: `, { content, comments, relatedPosts });
  console.timeEnd(""time"");
};

getPost();
/*
    Post Info:
    {
      comments:  [""comment 1"", ""comment 2""]
      content: ""This is content""
      relatedPosts: [""post 2"", ""post 3"", ""post 4""]
    }
    time: 4504.9638671875ms
    */` Trong ví dụ trên, mình sử dụngconsole.time và console.timeEndđể tính toán thời gian thực hiện. Kết quả thu được cỡ4500 ms. Đó chính làtổng thời gian thực hiện của 3 hành động.
Cụ thể:

```js
time(getPost) = time(getContent) + time(getComments) + time(getRelatedPosts)
    = 1000 + 1500 + 2000
    = 4500 (ms)
```
`time(getPost) = time(getContent) + time(getComments) + time(getRelatedPosts)
    = 1000 + 1500 + 2000
    = 4500 (ms)`"
10,Bất đồng bộ song song hay tuần tự?,Xử lý bất đồng bộ song song,"Với cách này, 3 hành độnggetContent,getCommentsvàgetRelatedPostssẽ thực hiện gần như là song song với nhau. Để thực hiện việc này, mình sẽ áp dụngPromise.allvào đây và kết quả thu được như sau:

```js
const getPost = async () => {
  console.time(""time"");

  const [content, comments, relatedPosts] = await Promise.all([
    getContent(),
    getComments(),
    getRelatedPosts(),
  ]);

  console.log(`Post Info: `, { content, comments, relatedPosts });
  console.timeEnd(""time"");
};

/*
    Post Info:
    {
      comments:  [""comment 1"", ""comment 2""]
      content:  ""This is content""
      relatedPosts:  [""post 2"", ""post 3"", ""post 4""]
    }
    time: 2001.398193359375ms
    */
```
`const getPost = async () => {
  console.time(""time"");

  const [content, comments, relatedPosts] = await Promise.all([
    getContent(),
    getComments(),
    getRelatedPosts(),
  ]);

  console.log(`Post Info: `, { content, comments, relatedPosts });
  console.timeEnd(""time"");
};

/*
    Post Info:
    {
      comments:  [""comment 1"", ""comment 2""]
      content:  ""This is content""
      relatedPosts:  [""post 2"", ""post 3"", ""post 4""]
    }
    time: 2001.398193359375ms
    */` Trong ví dụ trên, mình đưa 3 hành động bất đồng bộ vào mộtmảng, rồi truyền nó vào Promise.all. Tiếp theo, mình thực hiệnawaitvới phương thức này để đợi kết quả trả về.
Sau khi hàm trên kết thúc, mình dùngDestructuring Assignmentđể lấy ra kết quả như mong muốn, theo đúng thứ tự truyền vào của các hành động bên trong Promise.all.
Với cách này, thời gian thực hiện cỡ2000 ms. Đó chính làthời gian thực hiện lớn nhất của 3 hành động.
Cụ thể:

```js
time(getPost) = Max of [time(getContent), time(getComments), time(getRelatedPosts)]
    = Max of [1000, 1500, 2000]
    = 2000
```
`time(getPost) = Max of [time(getContent), time(getComments), time(getRelatedPosts)]
    = Max of [1000, 1500, 2000]
    = 2000`"
11,Bất đồng bộ song song hay tuần tự?,Lời kết,"Trên đây mình đã giới thiệu với bạn 2 cách xử lý bất đồng bộ song song và tuần tự rồi. Trong bài toán trên, 3 hành động là hoàn toàn độc lập nhau. Do đó, nếu làm thực tế thì mình sẽ lựa chọn xử lý bất đồng bộ song song. Vì thời gian thực hiện là ngắn hơn đáng kể so với cách xử lý bất đồng bộ tuần tự. Ngược lại, chỉ khi nào các hành động phụ thuộc lẫn nhau thì mình mới sử dụng cách xử lý bất đồng bộ tuần tự mà thôi.
Bạn đã biết cách xử lý bất đồng bộ song song chưa? Và nếu bạn đã từng làm nó rồi thì cách thực hiện của bạn là gì? Ngoài cách sử dụng Promise.all như trên thì còn cách nào nữa không? Chia sẻ với mình và mọi người trong phần bình luận nhé!
Xin chào và hẹn gặp lại, thân ái!"
12,"Xử lý bất đồng bộ với callback, promise, async/await",Giới thiệu,"Khi lập trình JavaScript, bạn sẽ thường xuyên phải thực hiện các công việc mất thời gian như: request lên server, lấy dữ liệu từ database, đọc/ghi file,... Nếu bạn chỉ xử lý đồng bộ thôi thì chắc chắn sẽ rất mất thời gian. Để giải quyết vấn đề này, JavaScript cung cấp một số công cụ hỗ trợ bạnxử lý bất đồng bộrất tốt như sử dụngcallback, promise hayasync/await.
Trong bài viết này, mình sẽ cùng nhau tìm hiểu xem xử lý bất đồng bộ là gì? Tại sao phải xử lý bất đồng bộ? Và các cách để xử lý bất đồng bộ trong JavaScript. Mời bạn theo dõi bài viết!"
13,"Xử lý bất đồng bộ với callback, promise, async/await",Cơ bản về xử lý bất đồng bộ,"Giả sử bạn có một nhiệm vụ bao gồm 2 công việc tốn thời gian, tạm gọi là A và B.
Đối với xử lý đồng bộ, bạn sẽ thực hiện công việc A; đợi A hoàn thành xong thì sẽ thực hiện B; rồi lại đợi B hoàn thành thì nhiệm vụ cuối cùng mới coi như xong.
Nghĩa là thời gian để hoàn thành nhiệm vụ là tổng của thời gian hoàn thành A và B. Hơn nữa, trong khoảng thời gian này bạn sẽ không thể thực hiện thêm 1 hành động nào khác (như bắt cácsự kiệnvới chuột và bàn phím của người dùng...). Điều này rõ ràng làm giảm hiệu năng và trải nghiệm người dùng đối với chương trình.
Để khắc phục tình trạng này, các ngôn ngữ lập trình như C/C++, Java,... sẽ sử dụngcơ chế đa luồng (multi-thread). Nghĩa là mỗi công việc tốn thời gian sẽ được thực hiện trên một thread riêng biệt mà không can thiệp vào thread chính. Bạn vẫn có thể thực hiện các công việc tốn thời gian mà vẫn có thể bắt các sự kiện ở thread chính.
Với ví dụ trên, thời gian để hoàn thành nhiệm vụ sẽ chỉ bằng thời gian hoàn thành của A hoặc B. Cái nào thực hiện xong trước sẽ đợi cái còn lại hoàn thành thì nhiệm vụ sẽ kết thúc.
Tuy nhiên, JavaScript lại là một câu chuyện khác. Hai nền tảng quan trọng với JavaScript (trình duyệt và Nodejs đều làsingle-thread. Chính vì vậy, bạn không thể xử lý đa luồng với JavaScript được mà phải sử dụng cơ chếxử lý bất đồng bộ.
Với cách xử lý bất đồng bộ, khi A bắt đầu thực hiện, chương trình tiếp tục thực hiện B mà không đợi A kết thúc. Việc mà bạn cần làm ở đây là cung cấp một phương thức để chương trình thực hiện khi A hoặc B kết thúc.
Cơ chế giúp bạn thực hiện việc này trong JavaScript có thể là sử dụngCallback,PromisehoặcAsync/await."
14,"Xử lý bất đồng bộ với callback, promise, async/await",Sử dụng Callback để xử lý bất đồng bộ,"Sử dụng Callbackcó thể nói là cách đầu tiên và dễ nhất giúp bạn xử lý bất đồng bộ. Khi định nghĩa mộtfunctionthực hiện một nhiệm vụ tốn thời gian, bạn cần truyền thêm tham số vào hàm - đóng vai trò làhàm callback.
Khi hành động bắt đầu, rồi khi nó kết thúc, hàm callback sẽ được gọi ngay sau đó.
Ví dụ dưới đây sẽ thực hiện mộtGETrequest. Thông thường, việc này sẽ tốn thời gian (ít hay nhiều tuỳ thuộc vào tốc độ mạng):

```js
function doAsync(url, onSuccess, onError) {
  const xhr = new XMLHttpRequest();
  xhr.open(""GET"", url);
  xhr.onload = () => onSuccess(xhr.responseText);
  xhr.onerror = () => onError(xhr.statusText);
  xhr.send();
}
// Usage:
doAsync(
  ""https://something.com"",
  (value) => {
    // 'value' is corresponding with 'xhr.responseText'
  },
  (error) => {
    // 'error' is corresponding with 'xhr.statusText'
  }
);
```
`function doAsync(url, onSuccess, onError) {
  const xhr = new XMLHttpRequest();
  xhr.open(""GET"", url);
  xhr.onload = () => onSuccess(xhr.responseText);
  xhr.onerror = () => onError(xhr.statusText);
  xhr.send();
}
// Usage:
doAsync(
  ""https://something.com"",
  (value) => {
    // 'value' is corresponding with 'xhr.responseText'
  },
  (error) => {
    // 'error' is corresponding with 'xhr.statusText'
  }
);` Ở đây, hàmdoAsynclà một hàm bất đồng bộ với 2 hàm callback là:onSuccessvàonError. Khi request trên thành công thì hàmonSuccesssẽ được gọi, ngược lại hàmonErrorsẽ được gọi. Khá dễ hiểu và dễ triển khai phải không?
Tuy nhiên, thử tưởng tượng bạn phải thực hiện 2 request liên tiếp, với request thứ 2 chỉ thực hiện khi request thứ nhất thực hiện xong:

```js
// Usage:
doAsync(
  ""https://something.com"",
  (value) => {
    // 'value' is corresponding with 'xhr.responseText' (1)

    doAsync(
      ""https://other.com"",
      (value) => {
        // 'value' is corresponding with 'xhr.responseText' (2)
      },
      (error) => {
        // 'error' is corresponding with 'xhr.statusText' (2)
      }
    );
  },
  (error) => {
    // 'error' is corresponding with 'xhr.statusText' (1)
  }
);
```
`// Usage:
doAsync(
  ""https://something.com"",
  (value) => {
    // 'value' is corresponding with 'xhr.responseText' (1)

    doAsync(
      ""https://other.com"",
      (value) => {
        // 'value' is corresponding with 'xhr.responseText' (2)
      },
      (error) => {
        // 'error' is corresponding with 'xhr.statusText' (2)
      }
    );
  },
  (error) => {
    // 'error' is corresponding with 'xhr.statusText' (1)
  }
);` Bắt đầu phức tạp rồi nhỉ? Và nếu bạn phải thực hiện thêm vài request khác nữa thì kết quả chắc chắn sẽ còn kinh khủng hơn rất nhiều. Trường hợp này gọi làCallback Hell.
Để tránh Callback Hell, bạn có thể sử dụng một cơ chế khác. Đó là Promise."
15,"Xử lý bất đồng bộ với callback, promise, async/await",Sử dụng Promise để xử lý bất đồng bộ,"Cú pháp cơ bản củaPromiselà:

```js
let promise = new Promise(function (resolve, reject) {
  // Code here
});
```
`let promise = new Promise(function (resolve, reject) {
  // Code here
});` Trong đó, hàm được truyền vàonew Promisegọi làexecutor.
Ban đầu, Promise có state làpendingvà kết quảvaluelàundefined. Khi executor kết thúc công việc, nó sẽ gọi đến 1 trong 2 hàm được truyền vào:
Khi sử dụng Promise, ví dụ phía trên sẽ trở thành:

```js
function doAsync(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(""GET"", url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

// Usage:
doAsync(""https://something.com"")
  .then((value) => {
    // 'value' is corresponding with 'xhr.responseText'
  })
  .catch((error) => {
    // 'error' is corresponding with 'xhr.statusText'
  });
```
`function doAsync(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(""GET"", url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

// Usage:
doAsync(""https://something.com"")
  .then((value) => {
    // 'value' is corresponding with 'xhr.responseText'
  })
  .catch((error) => {
    // 'error' is corresponding with 'xhr.statusText'
  });` Và khi bạn muốn thực hiện 2 request liên tiếp:

```js
// Usage:
doAsync(""https://something.com"")
  .then((value) => {
    /*
     * 'value' is corresponding with 'xhr.responseText'
     * from 'https://something.com'
     */
    return doAsync(""https://other.com"");
  })
  .then((value) => {
    /*
     * 'value' is corresponding with 'xhr.responseText'
     * from 'https://other.com'
     */
  })
  .catch((error) => {
    /*
     * 'error' is corresponding with 'xhr.statusText'
     * from either 'https://something.com' or 'https://other.com'
     */
  });
```
`// Usage:
doAsync(""https://something.com"")
  .then((value) => {
    /*
     * 'value' is corresponding with 'xhr.responseText'
     * from 'https://something.com'
     */
    return doAsync(""https://other.com"");
  })
  .then((value) => {
    /*
     * 'value' is corresponding with 'xhr.responseText'
     * from 'https://other.com'
     */
  })
  .catch((error) => {
    /*
     * 'error' is corresponding with 'xhr.statusText'
     * from either 'https://something.com' or 'https://other.com'
     */
  });` Rõ ràng, cấu trúc chương trình đã trở nên rõ ràng hơn. Không còn hiện tượng nhiều mức lồng nhau như khi sử dụng callback nữa rồi."
16,"Xử lý bất đồng bộ với callback, promise, async/await",Sử dụng Async/await để xử lý bất đồng bộ,"Async/awaitlà một cú pháp đặc biệt giúp bạn làm việc với Promise dễ dàng hơn. Khi sử dụng async/await, cấu trúc chương trình xử lý bất đồng bộ sẽ giống với chương trình xử lý đồng bộ hơn.
Với ví dụ sử dụng Promise bên trên, mình có thể áp dụng async/await như sau:

```js
function doAsync(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(""GET"", url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

// Usage:
async function run() {
  let responseText1, responseText2;

  try {
    responseText1 = await doAsync(""https://something.com"");
    responseText2 = await doAsync(""https://other.com"");
  } catch (error) {
    /*
     * 'error' is corresponding with 'xhr.statusText'
     * from either 'https://something.com' or 'https://other.com'
     */
  }
}

run();
```
`function doAsync(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(""GET"", url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

// Usage:
async function run() {
  let responseText1, responseText2;

  try {
    responseText1 = await doAsync(""https://something.com"");
    responseText2 = await doAsync(""https://other.com"");
  } catch (error) {
    /*
     * 'error' is corresponding with 'xhr.statusText'
     * from either 'https://something.com' or 'https://other.com'
     */
  }
}

run();` Nếu xử lý theo cách này thì dù bạn có thực hiện thêm nhiều request nữa, cấu trúc chương trình vẫn rất rõ ràng và mạch lạc phải không?
Và theo mình, đây có lẽ là cách tốt nhất để xử lý bất đồng bộ trong JavaScript, theo quan điểm của bạn thì sao nhỉ?"
17,"Xử lý bất đồng bộ với callback, promise, async/await",Lời kết,"Trên đây là một số kiến thức cơ bản về xử lý bất đồng bộ trong JavaScript với callback, promise và async/await. Bài này không viết chi tiết về Promise hay async/await mà chỉ giúp bạn thấy được cách sử dụng cơ bản, cũng như ưu điểm của chúng so với việc sử dụng callback thông thường.
Để biết thêm về Promise và async/await, bạn có thể tham khảo thêm trong các bài viết dưới đây:
Xin chào và hẹn gặp lại, thân ái!"
18,Tìm hiểu biến trong JavaScript,Giới thiệu,"Nếu như trong toán học có khái niệmbiến sốthì trong lập trình cũng có khái niệm biến. Đây là một thành phần không thể thiếu trong lập trình. Vì vậy, bài viết này mình sẽ tập trung vào tìm hiểu xem biến là gì, cách khai báo biến trong JavaScript và quy tắc đặt tên biến."
19,Tìm hiểu biến trong JavaScript,Biến là gì?,"Biến là ""tên biểu tượng"" dùng để đại diện cho một giá trị. Và giá trị của biến có thể thay đổi trong chương trình.
Giả sửxlà số lượng người đang đọc bài viết này, thìxchính là một biến. Ví dụ giá trị của biếnxbây giờ là 100. Nhưng năm phút sau, số lượng người đọc bài viết tăng lên thành 150. Lúc này, giá trị của biếnxsẽ là 150.
`x` `x` `x` `x`"
20,Tìm hiểu biến trong JavaScript,Cách khai báo biến trong JavaScript,"Để khai báo biến trong JavaScript, bạn dùng từ khóalet(từ khóavarđã lỗi thời và không nên sử dụng).
`let` `var` Cú pháp khai báo biến như sau:

```js
let <tên biến>;
```
`let <tên biến>;` Ví dụ câu lệnh sau khai báo một biến số có tên là ""language"":

```js
let language;
```
`let language;` Bây giờ, bạn có thể gán giá trị cho biến ""language"" sử dụng toán tử gán (=):
`=` 
```js
let language;

language = ""JavaScript"";
```
`let language;

language = ""JavaScript"";` Nghĩa là biến ""language"" đang liên kết đến vùng nhớ có giá trị là ""JavaScript"". Và bạn có thể truy cập đến vùng nhớ bằng cách sử dụng tên của biến như sau:

```js
let language;

language = ""JavaScript"";

console.log(language); // Kết quả hiển thị trên console là: ""JavaScript""
```
`let language;

language = ""JavaScript"";

console.log(language); // Kết quả hiển thị trên console là: ""JavaScript""` Để ngắn gọn, bạn có thể khai báo biến và gán giá trị cho biến trên cùng một dòng:

```js
let language = ""JavaScript"";
console.log(language); // JavaScript
```
`let language = ""JavaScript"";
console.log(language); // JavaScript` Để khai báo nhiều biến, bạn có thể dùng dấu phẩy (,) để ngăn cách các biến trên cùng một dòng:
`,` 
```js
let language = ""JavaScript"",
  message = ""Hello"",
  date = ""Monday"";
```
`let language = ""JavaScript"",
  message = ""Hello"",
  date = ""Monday"";` Ngoài ra, bạn cũng có thể viết như sau:

```js
let language = ""JavaScript"",
  message = ""Hello"",
  date = ""Monday"";
```
`let language = ""JavaScript"",
  message = ""Hello"",
  date = ""Monday"";` Hoặc cho dấu phẩy lên đầu:

```js
let language = ""JavaScript"",
  message = ""Hello"",
  date = ""Monday"";
```
`let language = ""JavaScript"",
  message = ""Hello"",
  date = ""Monday"";` Tuy nhiên, mình thấy khai báo mỗi biến trên một dòng là dễ nhìn hơn cả:

```js
let language = ""JavaScript"";
let message = ""Hello"";
let date = ""Monday"";
```
`let language = ""JavaScript"";
let message = ""Hello"";
let date = ""Monday"";` Về cơ bản thì các cách trên đều giống nhau, tùy thuộc thói quen và sở thích của bạn mà lựa chọn cho phù hợp."
21,Tìm hiểu biến trong JavaScript,Cách thay đổi giá trị của biến số,"Để thay đổi giá trị của biến, bạn chỉ cần gán giá trị mới cho nó, ví dụ:

```js
// Khai báo biến và gán giá trị ban đầu
let language = ""JavaScript"";
console.log(language); // JavaScript

// Thay đổi giá trị của biến
language = ""React"";
console.log(language); // React
```
`// Khai báo biến và gán giá trị ban đầu
let language = ""JavaScript"";
console.log(language); // JavaScript

// Thay đổi giá trị của biến
language = ""React"";
console.log(language); // React` Hoặc bạn cũng có thể gán giá trị của biến số này cho biến số khác, ví dụ:

```js
// Khai báo biến và gán giá trị ban đầu
let language1 = ""JavaScript"";
console.log(language1); // JavaScript

// Khai báo biến số 2
let language2;

// Gán giá trị của biến language1 cho biến language2
language2 = language1;
console.log(language2); // JavaScript

// Giá trị của biến language1 vẫn không đổi
console.log(language1); // JavaScript
```
`// Khai báo biến và gán giá trị ban đầu
let language1 = ""JavaScript"";
console.log(language1); // JavaScript

// Khai báo biến số 2
let language2;

// Gán giá trị của biến language1 cho biến language2
language2 = language1;
console.log(language2); // JavaScript

// Giá trị của biến language1 vẫn không đổi
console.log(language1); // JavaScript`"
22,Tìm hiểu biến trong JavaScript,Quy tắc đặt tên biến trong JavaScript,"Quy tắc đặt tên biến trong JavaScript như sau:
`_` `$` Từ khoá (keywords) là những từ mang ý nghĩa đặc biệt. Từletlà một từ khoá, với ý nghĩa là để khai báo biến.
Từ dự trữ (reserved words) là những từ sẽ được dùng làm từ khoá cho những phiên bản sau của JavaScript. Bạn không thể sử dụng từ khoá hay từ dự trữ để đặt tên cho biến số.
Danh sách những từ khoá và những từ dự trữ:
breakcasecatchclassconstcontinuedebuggerdefaultdeletedoelseenumexportextendsfalsefinallyforfunctionifimplementsimportininstanceofinterfaceletnewnullpackageprivateprotectedpublicreturnstaticsuperswitchthisthrowtruetrytypeofvarvoidwhilewithyield
`break` `case` `catch` `class` `const` `continue` `debugger` `default` `delete` `do` `else` `enum` `export` `extends` `false` `finally` `for` `function` `if` `implements` `import` `in` `instanceof` `interface` `let` `new` `null` `package` `private` `protected` `public` `return` `static` `super` `switch` `this` `throw` `true` `try` `typeof` `var` `void` `while` `with` `yield` Ví dụ những tên biến hợp lệ:

```js
let temp = 100;
let _result3 = 10;
let $_$ = ""hehehe"";
let I_AM_HUNGRY = true;
let dientichao = 999;
```
`let temp = 100;
let _result3 = 10;
let $_$ = ""hehehe"";
let I_AM_HUNGRY = true;
let dientichao = 999;` Ví dụ những tên biến không hợp lệ:

```js
let point% = 50;       // sử dụng kí tự đặc biệt %
let 2you = 'passtion'; // bắt đầu bằng số
let null = 'oh no';    // sử dụng từ khoá ""null""
```
`let point% = 50;       // sử dụng kí tự đặc biệt %
let 2you = 'passtion'; // bắt đầu bằng số
let null = 'oh no';    // sử dụng từ khoá ""null""` 📝 Một số chú ý khi đặt tên biến:"
23,Tìm hiểu biến trong JavaScript,Chuẩn hóa cách đặt tên biến,"Về cơ bản, bạn có thể đặt tên biến là bất kỳ thứ gì, miễn là tuân theo quy tắc trên. Tuy nhiên, bạn nên đặt tên biến theo đúng chuẩn thì tốt hơn.
Mục đích là để bạn hoặc đồng nghiệp khi đọc code thì dễ dàng hiểu được mỗi biến dùng để làm gì, ví dụ:
`name` `age` `address` Có nhiều trường hợp dùng một từ không thể hiện được ý nghĩa của biến, bạn có thể dùng nhiều từ tùy ý, ví dụ:
`totalStudent` `numberOfMotobike` Trong ví dụ trên, bạn thấy mình viết hoa chữ cái đầu tiên của các từ phía sau. Điều này giúp việc đọc tên biến dễ dàng hơn. Cách đặt tên biến này gọi là:camelCase.
Ngoài cách trên, bạn có thể sử dụngsnake_casevới dấu gạch dưới (_) để ngăn cách các từ như sau:
`_` Còn nhiều cách đặt tên khác nữa (PascalCase, CONSTANT_CASE, flatcase,...). Bạn có thể chọn một cách bất kỳ. Miễn sao bạn đặt tên biến dễ nhìn và thống nhất một kiểu đặt tên biến trong toàn bộ dự án.
💡 Đối với lập trình JavaScript, mình thấy đặt tên biến theo kiểucamelCaselà phổ biến hơn cả. Và mình cũng sử dụng cách này khi lập trình JavaScript."
24,Tìm hiểu biến trong JavaScript,Một số lỗi với biến trong JavaScript,"Khai báo và gán giá trị cho biến tưởng chừng là đơn giản. Nhưng đôi khi bạn cũng có thể mắc các lỗi sau đây.
Một biến số chỉ được khai báo một lần, nếu bạn khai báo lại biến đó thì sẽ bị lỗi cú pháp, ví dụ:

```js
let language = ""JavaScript"";

let language = ""React"";
```
`let language = ""JavaScript"";

let language = ""React"";` Bạn sẽ bị lỗi:Uncaught SyntaxError: Identifier 'language' has already been declared(biến ""language"" đã được định nghĩa rồi).
`Uncaught SyntaxError: Identifier 'language' has already been declared` Thực tế, bạn vẫn có thể gán giá trị cho biến mà không cần khai báo.

```js
message = ""hello"";
console.log(message); // hello
```
`message = ""hello"";
console.log(message); // hello` Tuy nhiên, nếu bạn sử dụng chế độ code nghiêm ngặt""use strict""thì bạn sẽ bị lỗi.
`""use strict""` 
```js
""use strict"";

message = ""hello"";
console.log(message);
```
`""use strict"";

message = ""hello"";
console.log(message);` Lỗi cụ thể là:Uncaught ReferenceError: message is not defined(biến ""message"" chưa được định nghĩa).
`Uncaught ReferenceError: message is not defined`"
25,Tìm hiểu biến trong JavaScript,Tổng kết,"Sau đây là tóm tắt những kiến thức cần nhớ về biến là gì, cách khai báo biến trong JavaScript và quy tắc đặt tên biến:
`let` `let <tên biến>;` `_` `$`"
26,Tìm hiểu biến trong JavaScript,Thực hành,"```js
let num = 100;
let _result3@ = ""haha"";
let $_$ = ""hehehe"";
let 2me = 'love';
let I_WANT_TO_EAT = ""just eat it"";
let dientihinhvuong = 999;
let a%b = 50;
let var = 'oh no';
```
`let num = 100;
let _result3@ = ""haha"";
let $_$ = ""hehehe"";
let 2me = 'love';
let I_WANT_TO_EAT = ""just eat it"";
let dientihinhvuong = 999;
let a%b = 50;
let var = 'oh no';` Và chỉ ra chính xác lỗi sai là gì?
Đáp án:

```js
let num = 100; // Đúng
let _result3@ = ""haha""; // Sai: vì sử dụng kí tự đặc biệt @
let имя_abc = ""hehehe""; // Đúng: được phép sử dụng kí tự không phải Latinh
let 2me = 'love'; // Sai: vì bắt đầu bằng số
let I_WANT_TO_EAT = ""just eat it""; // Đúng
let _dientihinhvuong = 10000; // Đúng: được phép bắt đầu dấu _
let a%b = 50; // Sai: vì có kí tự đặc biệt %
let var = 'oh no'; // Sai: vì tên biến trùng từ khóa var
```
`let num = 100; // Đúng
let _result3@ = ""haha""; // Sai: vì sử dụng kí tự đặc biệt @
let имя_abc = ""hehehe""; // Đúng: được phép sử dụng kí tự không phải Latinh
let 2me = 'love'; // Sai: vì bắt đầu bằng số
let I_WANT_TO_EAT = ""just eat it""; // Đúng
let _dientihinhvuong = 10000; // Đúng: được phép bắt đầu dấu _
let a%b = 50; // Sai: vì có kí tự đặc biệt %
let var = 'oh no'; // Sai: vì tên biến trùng từ khóa var` Đáp án

```js
// 1. Khai báo hai biến ""message"" và ""name"".
let message;
let name;

// 2. Gán giá trị cho biến ""name"" là tên của bạn, ví dụ: ""Lam"".
name = ""Lam"";

// 3. Gán giá trị của biến ""name"" cho biến ""message"".
message = name;

// 4. In ra console giá trị của biến ""message"" (kết quả phải là giá trị từ bước 2).
console.log(message); // Lam
```
`// 1. Khai báo hai biến ""message"" và ""name"".
let message;
let name;

// 2. Gán giá trị cho biến ""name"" là tên của bạn, ví dụ: ""Lam"".
name = ""Lam"";

// 3. Gán giá trị của biến ""name"" cho biến ""message"".
message = name;

// 4. In ra console giá trị của biến ""message"" (kết quả phải là giá trị từ bước 2).
console.log(message); // Lam` Ví dụ: ban đầux = ""hello""vày = ""world"". Sau khi hoán đổi thìx = ""world""vày = ""hello"".
`x = ""hello""` `y = ""world""` `x = ""world""` `y = ""hello""` Đáp án

```js
// 1. Khai báo và gán giá trị cho hai biến ""x"" và ""y"" (giá trị là chuỗi ký tự tùy ý).
let x = ""hello"";
let y = ""world"";

// 2. Hoán đổi giá trị của hai biến ""x"" và ""y"" cho nhau.
// - Bạn cần khai báo thêm một biến trung gian để lưu giá trị của một biến.
// - Giả sử là biến x:
let z = x;

// - Sau đó, gán giá trị của biến y cho biến x.
x = y;

// - Cuối cùng, gán giá trị của biến z cho biến y. Lúc này, ta đã hoán đổi xong rồi.
y = z;

// 3. In ra console giá trị hai biến ""x"" và ""y"" sau khi hoán đổi.
console.log(x); // world
console.log(y); // hello
```
`// 1. Khai báo và gán giá trị cho hai biến ""x"" và ""y"" (giá trị là chuỗi ký tự tùy ý).
let x = ""hello"";
let y = ""world"";

// 2. Hoán đổi giá trị của hai biến ""x"" và ""y"" cho nhau.
// - Bạn cần khai báo thêm một biến trung gian để lưu giá trị của một biến.
// - Giả sử là biến x:
let z = x;

// - Sau đó, gán giá trị của biến y cho biến x.
x = y;

// - Cuối cùng, gán giá trị của biến z cho biến y. Lúc này, ta đã hoán đổi xong rồi.
y = z;

// 3. In ra console giá trị hai biến ""x"" và ""y"" sau khi hoán đổi.
console.log(x); // world
console.log(y); // hello`"
27,Các kiểu dữ liệu trong JavaScript,Giới thiệu,"Trong hai bài viết vềbiếnvàhằngtrong JavaScript, mình có đề cập đến việcgán giá trịcho biến và hằng. Ở đó, mỗi giá trị đều có một kiểu dữ liệu nhất định. Vậy bạn có biết kiểu dữ liệu là gì và các kiểu dữ liệu trong JavaScript là gì không?
Sau đây mình sẽ cùng tìm hiểu về các kiểu dữ liệu cơ bản trong JavaScript. Còn về chi tiết của từng kiểu dữ liệu thì mình sẽ giới thiệu ở các bài tiếp theo."
28,Các kiểu dữ liệu trong JavaScript,Kiểu dữ liệu là gì?,"Kiểu dữ liệu là một cách phân loại dữ liệu chotrình biên dịchhoặctrình thông dịchhiểu về kiểu của dữ liệu đang sử dụng.
Đối với nhiều ngôn ngữ lập trình, khi khai báo một biến, bạn phải chỉ rõ biến đó thuộc kiểu dữ liệu gì. Nhưng đối với JavaScript thì khác, một biến có thể thuộc bất kỳ kiểu dữ liệu nào, ví dụ:

```js
let x = 999;
console.log(x); // 999

x = ""Helloworld"";
console.log(x); // Helloworld
```
`let x = 999;
console.log(x); // 999

x = ""Helloworld"";
console.log(x); // Helloworld` Bạn thấy rằng, biếnxban đầu được gán giá trịkiểu số. Nhưng sau đó, mình gán lại giá trị kiểuchuỗi kí tựcho biếnxvà không có lỗi nào xảy ra.
`x` `x` Đây vừa làưu điểm, nhưng cũng lànhược điểmcủa JavaScript."
29,Các kiểu dữ liệu trong JavaScript,Các kiểu dữ liệu trong JavaScript,"JavaScript có8 kiểu dữ liệu cơ bản, trong đó, có 7 kiểu dữ liệu nguyên thủy (boolean, null, undefined, number, BigInt, string, symbol) và 1 kiểu dữ liệu dạng tham chiếu (object).
Boolean là kiểu dữ liệu logic chỉ bao gồm hai giá trị làtrue(đúng, chính xác) vàfalse(sai, không chính xác), ví dụ:
`true` `false` 
```js
let isWebLoaded = true; // => Trang web đã được tải xong
console.log(isWebLoaded); // true

let isProgramRunning = false; // Chương trình đang không chạy
console.log(isProgramRunning); // false
```
`let isWebLoaded = true; // => Trang web đã được tải xong
console.log(isWebLoaded); // true

let isProgramRunning = false; // Chương trình đang không chạy
console.log(isProgramRunning); // false` Kiểu dữ liệunulllà một kiểu dữ liệu đặc biệt, chỉ bao gồm một giá trị lànull, ví dụ:
`null` 
```js
let language = null;
console.log(language); // null
```
`let language = null;
console.log(language); // null` Trong ví dụ trên, biếnlanguageđược hiểu làkhông biết giá trịhoặckhông có giá trị.
`language` Cũng tương tự nhưnull,undefinedlà một kiểu dữ liệu đặc biệt trong JavaScript, chỉ bao gồm một giá trịundefined, ví dụ:
`undefined` 
```js
let language = undefined;
console.log(language); // undefined
```
`let language = undefined;
console.log(language); // undefined` Kiểu dữ liệuundefinedcó nghĩa làgiá trị chưa được gán.
📝 Khác nhau cơ bản giữaundefinedvànull:
Ví dụ khai báo biến mà không gán giá trị:

```js
let language;
console.log(language); // undefined
```
`let language;
console.log(language); // undefined` Trường hợp biến đã có giá trị rồi, bạn vẫn có thể chủ động gán lại giá trịundefinedcho biến. Tuy nhiên, điều này là không nên. Vì như vậy là không đúng ý nghĩa của kiểu dữ liệuundefined.

```js
let language = ""JavaScript"";
console.log(language); // JavaScript

// KHÔNG NÊN
language = undefined;
console.log(language); // undefined

// NÊN
language = null;
console.log(language); // null
```
`let language = ""JavaScript"";
console.log(language); // JavaScript

// KHÔNG NÊN
language = undefined;
console.log(language); // undefined

// NÊN
language = null;
console.log(language); // null` Kiểu dữ liệu number là kiểu dữ liệu dạng số (tương tự trong toán học). Number trong JavaScript không có cú pháp gì đặc biệt. Bạn chỉ cần viết số ra.
JavaScript có hai loại số là:số nguyênvàsố thực.

```js
let n1 = 66; // số nguyên dương
let n2 = -66; // số nguyên âm
let n3 = 3.14; // số thực dương
let n4 = -3.14; // số thực âm
let n5 = 2e3; // => 2*10^3 = 2000
let n6 = 2e-3; // => 2*10^(-3) = 0.002
let n7 = 0xff; // số dạng hexa (hệ cơ số 16): 15*16 + 15 = 255
let n8 = 067; // số dạng octa (hệ cơ số 8): 6*8 + 7 = 55
let n9 = 0b11; // số dạng nhị phân (hệ cơ số 2): 1*2 + 1 = 3
```
`let n1 = 66; // số nguyên dương
let n2 = -66; // số nguyên âm
let n3 = 3.14; // số thực dương
let n4 = -3.14; // số thực âm
let n5 = 2e3; // => 2*10^3 = 2000
let n6 = 2e-3; // => 2*10^(-3) = 0.002
let n7 = 0xff; // số dạng hexa (hệ cơ số 16): 15*16 + 15 = 255
let n8 = 067; // số dạng octa (hệ cơ số 8): 6*8 + 7 = 55
let n9 = 0b11; // số dạng nhị phân (hệ cơ số 2): 1*2 + 1 = 3` Ngoài những loại số trên, JavaScript còn có 3 số đặc biệt là:Infinity,-InfinityvàNaN.
`/` 
```js
console.log(Infinity); // Infinity console.log(1 / 0); // Infinity
```
`console.log(Infinity); // Infinity console.log(1 / 0); // Infinity` 
```js
console.log(-Infinity); // -Infinity console.log(-1 / 0); // -Infinity
```
`console.log(-Infinity); // -Infinity console.log(-1 / 0); // -Infinity` 
```js
// Lấy 0 / 0 console.log(0 / 0); // NaN
// Lấy chuỗi ký tự chia cho số console.log(""JavaScript"" / 2); // NaN
// Lấy hai số Infinity trừ cho nhau console.log(Infinity - Infinity); // NaN
```
`// Lấy 0 / 0 console.log(0 / 0); // NaN
// Lấy chuỗi ký tự chia cho số console.log(""JavaScript"" / 2); // NaN
// Lấy hai số Infinity trừ cho nhau console.log(Infinity - Infinity); // NaN` Nhờ những số đặc biệt này mà việc tính toán trong JavaScript ""luôn an toàn"". Vì chương trình sẽ không bao giờ bịcrashdo lỗichia cho 0hay giá trịkhông phải số. Điều mà bạn có thể gặp phải ở nhiều ngôn ngữ khác như C/C++, Java,...
Trong JavaScript, kiểu dữ liệunumberkhông thể biểu diễn một sốnguyênlớn hơn(253-1)(bằng9007199254740991) và nhỏ hơn-(253-1).
`(253-1)` `-(253-1)` Với hầu hết các trường hợp, việc sử dụng kiểu dữ liệunumberlà quá đủ. Nhưng đôi khi, bạn vẫn cần biểu diễn và tính toán với những số nguyên cực kỳ lớn. Do đó, kiểu dữ liệuBigIntra đời nhằm giải quyết vấn đề này.
Để biểu diễn số nguyên với kiểuBigInt, bạn chỉ cần thêm chữ cáinở phía sau, ví dụ:
`n` 
```js
const reallyBigNumber = 12345678987654321012345678987654321n;
console.log(reallyBigNumber); // 12345678987654321012345678987654321n
```
`const reallyBigNumber = 12345678987654321012345678987654321n;
console.log(reallyBigNumber); // 12345678987654321012345678987654321n` String là kiểu dữ liệu dùng để biểu diễn chữ, văn bản, đoạn văn bản,...
Có ba cách để biểu diễn string trong JavaScript:
`'` `""` ``` 
```js
const msg1 = ""Đây là string dùng dấu nháy đơn"";
const msg2 = ""Đây là string dùng dấu nháy kép"";
const msg3 = `Đây là string dùng dấu backtick`;
```
`const msg1 = ""Đây là string dùng dấu nháy đơn"";
const msg2 = ""Đây là string dùng dấu nháy kép"";
const msg3 = `Đây là string dùng dấu backtick`;` Dấu nháy đơn và dấu nháy kép là hoàn toàn giống nhau.
Riêng với dấu ""backtick"", bạn có thể sử dụng biến, hằng hoặc thậm chí viết một biểu thức trong đó, với cú pháp${…}, ví dụ:
`${…}` 
```js
// Truyền biến vào trong dấu ""backtick""
let name = ""Lam"";
console.log(`My name is ${name}`); // My name is Lam

// Truyền hằng vào trong dấu ""backtick""
const language = ""JavaScript"";
console.log(`You are learning ${language}`); // You are learning JavaScript

// Truyền vào biểu thức
console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
```
`// Truyền biến vào trong dấu ""backtick""
let name = ""Lam"";
console.log(`My name is ${name}`); // My name is Lam

// Truyền hằng vào trong dấu ""backtick""
const language = ""JavaScript"";
console.log(`You are learning ${language}`); // You are learning JavaScript

// Truyền vào biểu thức
console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3` String trong JavaScript có thể chỉ gồm 1 kí tự""a"", nhiều kí tự""abc""hoặc không kí tự nào""""(empty string).
`""a""` `""abc""` `""""` Symbol là một kiểu dữ liệu nguyên thủy dùng để tạo ra các giá trị duy nhất (unique value) và bất biến (immutable). Symbol thường được dùng làmkeycho kiểu dữ liệuobjectsau đây. (Chúng ta sẽ tìm hiểu sâu hơn về Symbol trong các bài viết sau)
Object là kiểu dữ liệu tham chiếu. Có thể hiểuobjectlà một tập hợp gồm các cặpkey - value (khóa - giá trị).
Trong đó, kiểu dữ liệu củakeycó thể làstringhoặcsymbol. Vàvalueứng vớikeycó thể là bất kỳ kiểu dữ liệu nào. (Chúng ta sẽ tìm hiểu sâu hơn về Object ở các bài sau)"
30,Các kiểu dữ liệu trong JavaScript,Cách xác định kiểu dữ liệu của biến,"Như mình đã nói ở trên, một biến trong JavaScript có thể thuộc bất kỳ kiểu dữ liệu nào. Để xác định kiểu dữ liệu hiện tại của một biến, JavaScript cung cấp cho bạntypeof, với hai loại cú pháp:
`typeof` `typeof x` `typeof(x)` Kết quả trả về sẽ là mộtstringứng với tên của kiểu dữ liệu. Ví dụ về toán tửtypeofvới các kiểu dữ liệu trong JS:
`string` `typeof` 
```js
let x;
console.log(typeof x); // undefined

x = true;
console.log(typeof x); // boolean

x = 1;
console.log(typeof x); // number

x = 1234567891234567890123456789125345362n;
console.log(typeof x); // bigint

x = ""hello"";
console.log(typeof x); // string

// (1)
x = Symbol(""id"");
console.log(typeof x); // symbol
// (2)
x = { n: 1 };
console.log(typeof x); // object
// (3)
x = null;
console.log(typeof x); // object
```
`let x;
console.log(typeof x); // undefined

x = true;
console.log(typeof x); // boolean

x = 1;
console.log(typeof x); // number

x = 1234567891234567890123456789125345362n;
console.log(typeof x); // bigint

x = ""hello"";
console.log(typeof x); // string

// (1)
x = Symbol(""id"");
console.log(typeof x); // symbol
// (2)
x = { n: 1 };
console.log(typeof x); // object
// (3)
x = null;
console.log(typeof x); // object`"
31,Các kiểu dữ liệu trong JavaScript,Tổng kết,"Sau đây là tóm tắt những kiến thức cơ bản về các kiểu dữ liệu trong JavaScript:
JavaScript có8 kiểu dữ liệu cơ bản, trong đó, có 7 kiểu dữ liệu nguyên thủy (boolean, null, undefined, number, BigInt, string, symbol) và 1 kiểu dữ liệu dạng tham chiếu (object).
`boolean` `true` `false` `null` `null` `undefined` `undefined` `number` `±(253-1` `BigInt` `BigInt` `n` `string` `'` `""` ``` `symbol` `object` `object` Để kiểm tra kiểu dữ liệu của một biến, bạn có thể sử dụngtypeof.
`typeof` `typeof x` `typeof(x)` `string` `typeof null` `object` `null` `object`"
32,Các phương thức của mảng trong Javascript,Giới thiệu,"Có rất nhiều phương thức của mảng trong JavaScript. Nhờ đó, việc xử lý mảng trở nên dễ dàng hơn. Sau đây, mình sẽ tìm hiểu chi tiết về các phương thức xử lý mảng phổ biến nhất."
33,Các phương thức của mảng trong Javascript,Các phương thức thêm/xóa phần tử mảng,"Trong bài viếtArray là gì? Array trong JavaScript, mình đã giới thiệu 4 phương thức cơ bản của mảng là:
`arr.push(...items)` `arr.pop()` `arr.shift()` `arr.unshift(...items)` Ngoài ra, còn nhiều phương thức của mảng trong JavaScript nữa.
`splice` Làm sao để xóa phần tử bất kỳ trong mảng?
Dĩ nhiên, mảng trong JavaScript cũng làobject. Nghĩa là bạn có thể dùngdeleteđể xóa một phần tử bất kỳ trong mảng dựa vào chỉ số.
`delete` 
```js
let letters = [""a"", ""b"", ""c""];

delete letters[1]; // xóa phần tử ""b""
console.log(letters[1]); // undefined

console.log(letters.length); // 3
```
`let letters = [""a"", ""b"", ""c""];

delete letters[1]; // xóa phần tử ""b""
console.log(letters[1]); // undefined

console.log(letters.length); // 3` Vấn đề xảy ra là: mặc dù bạn đã xóa một phần tử trong mảng, nhưng độ dài của mảnglengthvẫn không đổi (bằng 3). Bởi vì,delete obj.keychỉ xóa giá trị của thuộc tínhkeytrong object.
`length` `delete obj.key` `key` Cái chúng ta mong muốn là: khi xóa phần tử của mảng thì độ dài mảng phải giảm đi. Đó chính là lý do phương thứcsplicera đời.
`splice` Phương thứcarr.splicecó thểxóa, thêm hoặc thay thếphần tử của mảng. Cú pháp phương thứcsplicelà:
`arr.splice` `splice` 
```js
arr.splice(start[, deleteCount, elem1,..., elemN]);
```
`arr.splice(start[, deleteCount, elem1,..., elemN]);` Phương thứcsplicexử lý mảng tại vị trí có chỉ sốstartbằng cách: xóa đideleteCountphần tử, rồi chèn thêm các phần tửelem1,... elemNvào đúng vị trí đó. Sau đó, trả về mảng của những phần tử bị xóa.
`splice` `start` `deleteCount` `elem1,... elemN` Ví dụ xóa đi 1 phần tử tại vị trí 1:

```js
let letters = [""a"", ""b"", ""c""];

// từ vị trí có chỉ số 1, xóa đi 1 phần tử
letters.splice(1, 1);

console.log(letters); // (2) ['a', 'c']
```
`let letters = [""a"", ""b"", ""c""];

// từ vị trí có chỉ số 1, xóa đi 1 phần tử
letters.splice(1, 1);

console.log(letters); // (2) ['a', 'c']` Ví dụ xóa đi 3 phần tử tại vị trí đầu tiên và thêm 2 phần tử khác:

```js
let letters = [""a"", ""b"", ""c""];

// từ vị trí có chỉ số 0, xóa đi 3 phần tử, rồi thêm vào 2 phần tử
letters.splice(0, 3, ""d"", ""e"");

console.log(letters); // (2) ['d', 'e']
```
`let letters = [""a"", ""b"", ""c""];

// từ vị trí có chỉ số 0, xóa đi 3 phần tử, rồi thêm vào 2 phần tử
letters.splice(0, 3, ""d"", ""e"");

console.log(letters); // (2) ['d', 'e']` Ví dụ trả về mảng các phần tử bị xóa:

```js
let letters = [""a"", ""b"", ""c""];

// từ vị trí có chỉ số 1, xóa đi 2 phần tử là ""b"", ""c""
// rồi thêm vào 1 phần tử ""d""
let arr = letters.splice(1, 2, ""d"");

console.log(letters); // (2) ['a', 'd']
console.log(arr); // (2) ['b', 'c'] -> mảng các phần tử bị xóa
```
`let letters = [""a"", ""b"", ""c""];

// từ vị trí có chỉ số 1, xóa đi 2 phần tử là ""b"", ""c""
// rồi thêm vào 1 phần tử ""d""
let arr = letters.splice(1, 2, ""d"");

console.log(letters); // (2) ['a', 'd']
console.log(arr); // (2) ['b', 'c'] -> mảng các phần tử bị xóa` Phương thứcsplicecũng có thểthêm phần tử vào mảng mà không cần xóa đi phần tử nào, bằng cách truyền vào giá trịdeleteCountbằng 0.
`splice` `deleteCount` 
```js
let letters = [""a"", ""b"", ""c""];

letters.splice(""1"", 0, ""d"", ""e"");
console.log(letters); // (5) ['a', 'd', 'e', 'b', 'c']
```
`let letters = [""a"", ""b"", ""c""];

letters.splice(""1"", 0, ""d"", ""e"");
console.log(letters); // (5) ['a', 'd', 'e', 'b', 'c']` Phương thứcsplicechấp nhậnchỉ số âm. Nếu chỉ số âm thìthứ tự đếm là từ cuối lên đầu, ví dụ:
`splice` 
```js
let letters = [""a"", ""b"", ""c""];

// chỉ số bằng -1 tức đếm 1 đơn vị từ cuối lên
// xóa đi 0 phần tử
// rồi chèn thêm 2 phần tử ""d"" và ""e""
letters.splice(-1, 0, ""d"", ""e"");
console.log(letters); // (5) ['a', 'b', 'd', 'e', 'c']
```
`let letters = [""a"", ""b"", ""c""];

// chỉ số bằng -1 tức đếm 1 đơn vị từ cuối lên
// xóa đi 0 phần tử
// rồi chèn thêm 2 phần tử ""d"" và ""e""
letters.splice(-1, 0, ""d"", ""e"");
console.log(letters); // (5) ['a', 'b', 'd', 'e', 'c']` `slice` Phương thứcarr.sliceđơn giản hơn phương thứcarr.splice.
`arr.slice` `arr.splice` Cú pháp phương thứcslicelà:
`slice` 
```js
arr.slice([start], [end]);
```
`arr.slice([start], [end]);` Phương thức nàytrả về mảng mớibằng cách copy mảng ban đầu từ vị trístartđến vị tríend(không bao gồmend). Cả hai giá trịstartvàendđều có thể âm, khi đó việc đếm được tính từ cuối của mảng.
`start` `end` `end` `start` `end` Phương thức của arrayarr.slicetương tự như phương thức của stringstr.slice, chỉ khác là trả vềsubarraychứ không phải làsubstring.
`arr.slice` `str.slice` 
```js
let letters = [""a"", ""b"", ""c"", ""d""];

// copy mảng letters từ vị trí 1 đến vị trí 3
let arr1 = letters.slice(1, 3);
console.log(arr1); // (2) ['b', 'c']

// copy mảng letters từ vị trí số 2 từ cuối lên đến cuối mảng
let arr2 = letters.slice(-2);
console.log(arr2); // (2) ['c', 'd']
```
`let letters = [""a"", ""b"", ""c"", ""d""];

// copy mảng letters từ vị trí 1 đến vị trí 3
let arr1 = letters.slice(1, 3);
console.log(arr1); // (2) ['b', 'c']

// copy mảng letters từ vị trí số 2 từ cuối lên đến cuối mảng
let arr2 = letters.slice(-2);
console.log(arr2); // (2) ['c', 'd']` `concat` Phương thứcarr.concattrả về array mới bao gồm các giá trị củaarrban đầu, cộng thêm giá trị các phần tử trong array thêm vào hoặc các giá trị khác.
`arr.concat` `arr` Cú pháp phương thứcarr.concatlà:
`arr.concat` 
```js
arr.concat(arg1, arg2,...)
```
`arr.concat(arg1, arg2,...)` Phương thức này chấp nhậnsố lượng tham số tùy ý. Và giá trị củaarg1, arg2,...có thể là mảng hoặc giá trị khác.
`arg1, arg2,...` Giả sử phần tửargNlà mảng thì tất cả các phần tử trong mảngargNđược sao chép. Ngược lại, nếu giá trị củaargNkhông phải mảng thì giá trị của chính nó được copy vào mảng, ví dụ:
`argN` `argN` `argN` 
```js
let arr1 = [1, 2];

// tạo mảng mới từ mảng arr1 và mảng [3, 4]
let arr2 = arr1.concat([3, 4]);
console.log(arr2); // (4) [1, 2, 3, 4]

// tạo mảng mới từ mảng arr1 và mảng [3, 4] và [5, 6]
let arr3 = arr1.concat([3, 4], [5, 6]);
console.log(arr3); // (6) [1, 2, 3, 4, 5, 6]

// tạo mảng mới từ mảng arr1 và mảng [3, 4] cùng với các giá trị 5, 6
let arr4 = arr1.concat([3, 4], 5, 6);
console.log(arr4); // (6) [1, 2, 3, 4, 5, 6]
```
`let arr1 = [1, 2];

// tạo mảng mới từ mảng arr1 và mảng [3, 4]
let arr2 = arr1.concat([3, 4]);
console.log(arr2); // (4) [1, 2, 3, 4]

// tạo mảng mới từ mảng arr1 và mảng [3, 4] và [5, 6]
let arr3 = arr1.concat([3, 4], [5, 6]);
console.log(arr3); // (6) [1, 2, 3, 4, 5, 6]

// tạo mảng mới từ mảng arr1 và mảng [3, 4] cùng với các giá trị 5, 6
let arr4 = arr1.concat([3, 4], 5, 6);
console.log(arr4); // (6) [1, 2, 3, 4, 5, 6]` Bình thường, phương thứcconcatchỉ copy các phần tử từ mảng. Nhưng với các object khác, thậm chí là dạngarray-like(cóchỉ sốvà thuộc tínhlength) thì giá trị của object cũng được copy vào:
`concat` `length` 
```js
let arr = [1, 2];

let arrayLike = {
  0: ""hello"",
  length: 1,
};

// copy toàn bộ object vào mảng
console.log(arr.concat(arrayLike)); // (3) [1, 2, {...}]
```
`let arr = [1, 2];

let arrayLike = {
  0: ""hello"",
  length: 1,
};

// copy toàn bộ object vào mảng
console.log(arr.concat(arrayLike)); // (3) [1, 2, {...}]` Nhưng nếu objectarray-likeđó cóthuộc tính đặc biệtlàSymbol.isConcatSpreadablethì cách xử lý hoàn toàn giống như của mảng bình thường:
`Symbol.isConcatSpreadable` 
```js
let arr = [1, 2];

let arrayLike = {
  0: ""hello"",
  1: ""hi"",
  length: 2,
  [Symbol.isConcatSpreadable]: true,
};

// từng phần tử của mảng được copy vào mảng arr
console.log(arr.concat(arrayLike)); // (4) [1, 2, ""hello"", ""hi""]
```
`let arr = [1, 2];

let arrayLike = {
  0: ""hello"",
  1: ""hi"",
  length: 2,
  [Symbol.isConcatSpreadable]: true,
};

// từng phần tử của mảng được copy vào mảng arr
console.log(arr.concat(arrayLike)); // (4) [1, 2, ""hello"", ""hi""]`"
34,Các phương thức của mảng trong Javascript,Phương thức duyệt mảng trong JavaScript,"Phương thức của mảng trong JavaScript giúp duyệt tất cả các phần tử là:forEach.
`forEach` Phương thức này cho phép bạn thực hiện mộthàmtrên mỗi phần tử trong mảng với cú pháp:

```js
arr.forEach(function (item, index, array) {
  // code xử lý trong đây
});
```
`arr.forEach(function (item, index, array) {
  // code xử lý trong đây
});` Trong đó:
`item` `index` `array` `arr` Ví dụ:

```js
[""a"", ""b"", ""c""].forEach(function (item, index, array) {
  console.log(`item ${item} at index ${index} in array ${array}`);
});
```
`[""a"", ""b"", ""c""].forEach(function (item, index, array) {
  console.log(`item ${item} at index ${index} in array ${array}`);
});` Kết quả
item a at index 0 in array a,b,citem b at index 1 in array a,b,citem c at index 2 in array a,b,c
Để hiểu hơn vềforEach, bạn có thể đọc thêm bài viết:JavaScript forEach là cái quái gì?
`forEach`"
35,Các phương thức của mảng trong Javascript,Các phương thức tìm kiếm trong mảng,"Sau đây mình sẽ tìm hiểu về các phương thức của mảng trong JavaScript giúp tìm kiếm.
`indexOf` `lastIndexOf` `includes` Các phương thứcindexOf,lastIndexOfvàincludescó cú pháp và cách sử dụng tương tự như các phương thức cùng tên trong string.
`indexOf` `lastIndexOf` `includes` `arr.indexOf(item, from)` `item` `from` `-1` `arr.lastIndexOf(item, from)` `indexOf` `item` `from` `arr.includes(item, from)` `item` `from` `true` `false` Các ví dụ:

```js
let arr = [1, 0, 1, false];

console.log(arr.indexOf(0)); // 1
console.log(arr.indexOf(false)); // 3
console.log(arr.indexOf(null)); // -1

console.log(arr.indexOf(1)); // 0
console.log(arr.lastIndexOf(1)); // 2

console.log(arr.includes(1)); // true
```
`let arr = [1, 0, 1, false];

console.log(arr.indexOf(0)); // 1
console.log(arr.indexOf(false)); // 3
console.log(arr.indexOf(null)); // -1

console.log(arr.indexOf(1)); // 0
console.log(arr.lastIndexOf(1)); // 2

console.log(arr.includes(1)); // true` Chú ý:các phương thức trên thườngsử dụng toán tử so sánh bằng nghiêm ngặt===để kiểm tra.
`===` Nếu bạn tìm kiếmfalsethì kết quả trả về là vị trí chính xác củafalsechứ không phải0.
`false` `false` `0` Nếu bạn muốn kiểm tra sự tồn tại màkhông quan tâm đến chỉ sốthì nên dùngarr.includes.
`arr.includes` Một điểm khác nhau giữaarr.includesvớiarr.indexOfvàarr.lastIndexOflàarr.includescó thể tìm chính xácNaN.
`arr.includes` `arr.indexOf` `arr.lastIndexOf` `arr.includes` `NaN` 
```js
let arr = [NaN];

console.log(arr.includes(NaN)); // true
console.log(arr.indexOf(NaN)); // -1
console.log(arr.lastIndexOf(NaN)); // -1
```
`let arr = [NaN];

console.log(arr.includes(NaN)); // true
console.log(arr.indexOf(NaN)); // -1
console.log(arr.lastIndexOf(NaN)); // -1` `find` `findIndex` Giả sử bạn có một mảng các object. Làm sao để tìm kiếm object trong mảng thỏa mãn một số điều kiện cho trước?
Để giải quyết vấn đề này, bạn có thể dùng phương thứcarr.findhoặcarr.findIndex.
`arr.find` `arr.findIndex` Phương thứcarr.find(fn)có cú pháp là:
`arr.find(fn)` 
```js
let result = arr.find(function (item, index, array) {
  // code xử lý
});
```
`let result = arr.find(function (item, index, array) {
  // code xử lý
});` Trong đó:
`item` `index` `array` `arr` Phương thứcarr.find(fn)tìm kiếm một phần tử trong mảng thỏa mãn hàmfn(nói cách khác là hàmfntrả vềtrue) và trả về phần tử tìm được, ngược lại thì trả vềundefined.
`arr.find(fn)` `fn` `fn` `true` `undefined` Ví dụ tìm kiếm user cóid === 2trong một mảng:
`id === 2` 
```js
let users = [
  { id: 1, name: ""Alex"" },
  { id: 2, name: ""John"" },
  { id: 3, name: ""Anna"" },
];

let user = users.find((item) => item.id === 2);

console.log(user.name); // John
```
`let users = [
  { id: 1, name: ""Alex"" },
  { id: 2, name: ""John"" },
  { id: 3, name: ""Anna"" },
];

let user = users.find((item) => item.id === 2);

console.log(user.name); // John` Trong ví dụ trên, hàm cung cấp cho phương thứcfindlàarrow function(item) => item.id === 2với một tham sốitem(các tham số còn lại không sử dụng).
`find` `(item) => item.id === 2` `item` Phương thứcarr.findIndexcó cú pháp hoàn toàn giống vớiarr.find. Chỉ khác là,arr.findIndextrả về chỉ số của phần tử tìm thấy, ngược lại thì trả về-1, ví dụ:
`arr.findIndex` `arr.find` `arr.findIndex` `-1` 
```js
let users = [
  { id: 1, name: ""Alex"" },
  { id: 2, name: ""John"" },
  { id: 3, name: ""Anna"" },
];

let index = users.findIndex((item) => item.id === 2);
console.log(index); // 1
```
`let users = [
  { id: 1, name: ""Alex"" },
  { id: 2, name: ""John"" },
  { id: 3, name: ""Anna"" },
];

let index = users.findIndex((item) => item.id === 2);
console.log(index); // 1` `filter` Phương thứcarr.findvàarr.findIndexchỉ tìm kiếm phần tử đầu tiên thỏa mãn. Đểtìm kiếm nhiều phần tử thỏa mãn, bạn có thể dùng phương thứcarr.filter.
`arr.find` `arr.findIndex` `arr.filter` Cú pháp củaarr.filtertương tự nhưarr.findvàarr.findIndex:
`arr.filter` `arr.find` `arr.findIndex` 
```js
let results = arr.filter(function (item, index, array) {
  // code kiểm tra
});
```
`let results = arr.filter(function (item, index, array) {
  // code kiểm tra
});` Phương thứcarr.filtertrả về một mảng các phần tử thỏa mãn, ngược lại thì trả về mảng rỗng:
`arr.filter` 
```js
let users = [
  { id: 1, name: ""Alex"" },
  { id: 2, name: ""John"" },
  { id: 3, name: ""Anna"" },
];

let results = users.filter((item) => item.id <= 2);
console.log(results.length); // 2

let others = users.filter((item) => item.id > 5);
console.log(others.length); // 0
```
`let users = [
  { id: 1, name: ""Alex"" },
  { id: 2, name: ""John"" },
  { id: 3, name: ""Anna"" },
];

let results = users.filter((item) => item.id <= 2);
console.log(results.length); // 2

let others = users.filter((item) => item.id > 5);
console.log(others.length); // 0`"
36,Các phương thức của mảng trong Javascript,Các phương thức biến đổi mảng,"Sau đây là các phương thức của mảng trong JavaScript giúptạo mảng mới từ một mảng gốchoặcthay đổi thứ tự của mảng gốc.
`map` Phương thứcarr.maplà một trong những phương thức phổ biến nhất của mảng.
`arr.map` Phương thức này thực hiện một hàm trên mỗi phần tử của mảng và trả về một mảng các kết quả với cú pháp là:

```js
let result = arr.map(function (item, index, array) {
  // trả về giá trị mới từ mỗi item
});
```
`let result = arr.map(function (item, index, array) {
  // trả về giá trị mới từ mỗi item
});` Ví dụ từ mảng các string, suy ra mảng các độ dài tương ứng là:

```js
let lengths = [""Dog"", ""Fish"", ""Elephant""].map((item) => item.length);
console.log(lengths); // (3) [3, 4, 8]
```
`let lengths = [""Dog"", ""Fish"", ""Elephant""].map((item) => item.length);
console.log(lengths); // (3) [3, 4, 8]` `sort` Phương thứcarr.sortsắp xếp các phần tử trong mảng theo thứ tự.
`arr.sort` Phương thức này trả về mảng đã được sắp xếp. Tuy nhiên, mình thường bỏ qua giá trị trả về. Vì thực chất là chínharrđã bị thay đổi.
`arr` Ví dụ:

```js
let arr = [1, 2, 15];
arr.sort();
console.log(arr); // (3) [1, 15, 2]
```
`let arr = [1, 2, 15];
arr.sort();
console.log(arr); // (3) [1, 15, 2]` Kết quả trả về là mảng[1, 15, 2]. Bạn có thấy điểm bất thường gì ở đây không?
`[1, 15, 2]` 💡 Mặc định các phần tử được sắp xếp theo thứ tự string.
Trong ví dụ trên, các phần tử đượcchuyển đổi kiểu dữ liệuvềstringđể so sánh. Mà""1"" < ""2""làtrue. Nên kết quả như trên là đúng.
`""1"" < ""2""` `true` Để sắp xếp theo tứ tự mong muốn, bạn cần truyền vào một hàm để so sánh.
Ví dụ một hàm so sánh:

```js
function compare(a, b) {
  if (a > b) return 1; // a đứng sau b
  if (a == b) return 0; // a, b bằng nhau
  if (a < b) return -1; // a đứng trước b
}
```
`function compare(a, b) {
  if (a > b) return 1; // a đứng sau b
  if (a == b) return 0; // a, b bằng nhau
  if (a < b) return -1; // a đứng trước b
}` Áp dụng hàm so sánh vào phương thứcarr.sortđể sắp xếp mảng số:
`arr.sort` 
```js
let arr = [1, 2, 15];

arr.sort(function (a, b) {  if (a > b) return 1; // a đứng sau b  if (a == b) return 0; // a, b bằng nhau  if (a < b) return -1; // a đứng trước b});
console.log(arr); // (3) [1, 2, 15]
```
`let arr = [1, 2, 15];

arr.sort(function (a, b) {  if (a > b) return 1; // a đứng sau b  if (a == b) return 0; // a, b bằng nhau  if (a < b) return -1; // a đứng trước b});
console.log(arr); // (3) [1, 2, 15]` Kết quả bây giờ đã đúng như mong muốn.
`reverse` Phương thứcarr.reversegiúp đảo ngược mảng gốc, ví dụ:
`arr.reverse` 
```js
let arr = [1, 2, 3, 4, 5];

arr.reverse();

console.log(arr); // (5) [5, 4, 3, 2, 1]
```
`let arr = [1, 2, 3, 4, 5];

arr.reverse();

console.log(arr); // (5) [5, 4, 3, 2, 1]` `split` `join` Phương thứcarr.split(delim)giúp tách string thành một mảng với giá trị dùng để phân tách làdelim.
`arr.split(delim)` `delim` Ví dụ phân tách string thành mảng dựa trên dấu phẩy,:
`,` 
```js
let str = ""a,b,c,d"";

let arr = str.split("","");

console.log(arr); // (4) [a, b, c, d]
```
`let str = ""a,b,c,d"";

let arr = str.split("","");

console.log(arr); // (4) [a, b, c, d]` Phương thứcarr.splitcòn có tham số thứ hai dùng để giới hạn chiều dài của mảng:
`arr.split` 
```js
let str = ""a,b,c,d"";

// giới hạn số phần tử của mảng là 2
let arr = str.split("","", 2);

console.log(arr); // (2) [a, b]
```
`let str = ""a,b,c,d"";

// giới hạn số phần tử của mảng là 2
let arr = str.split("","", 2);

console.log(arr); // (2) [a, b]` Phương thứcarr.joinxử lý ngược lại với phương thứcarr.split. Phương thức này trả về một string bằng cách ghép các phần tử mảng với ""một kí tự kết nối"".
`arr.join` `arr.split` Ví dụ ghép các phần tử mảng bởi dấu,:
`,` 
```js
let arr = [""a"", ""b"", ""c"", ""d""];

// ghép các phần tử mảng bằng kí tự ,
let str = arr.join("","");

console.log(str); // a,b,c,d
```
`let arr = [""a"", ""b"", ""c"", ""d""];

// ghép các phần tử mảng bằng kí tự ,
let str = arr.join("","");

console.log(str); // a,b,c,d` `reduce` `reduceRight` Phương thứcarr.reducevàarr.reduceRightdùng để tính toán và trả về một giá trị duy nhất từ các phần tử mảng.
`arr.reduce` `arr.reduceRight` Cú pháp phương thứcreducelà:
`reduce` 
```js
let value = arr.reduce(
  function (accumulator, item, index, array) {
    // code xử lý
  },
  [initial]
);
```
`let value = arr.reduce(
  function (accumulator, item, index, array) {
    // code xử lý
  },
  [initial]
);` Trong đó:
`initial` `0` `function` `accumulator` `accumulator` `initial` `item` `index` `array` `arr` Kết quả trả về của phương thứcreducechính là giá trị cuối cùng củaaccumulator.
`reduce` `accumulator` Ví dụ tính tổng các phần tử trong mảng:

```js
let arr = [1, 2, 3, 4, 5];

// giá trị khởi tạo không truyền nên mặc định là 0
// tại mỗi lần duyệt, giá trị tích lũy được cộng với giá trị phần tử hiện tại
let result = arr.reduce((sum, current) => sum + current);

console.log(result); // 15
```
`let arr = [1, 2, 3, 4, 5];

// giá trị khởi tạo không truyền nên mặc định là 0
// tại mỗi lần duyệt, giá trị tích lũy được cộng với giá trị phần tử hiện tại
let result = arr.reduce((sum, current) => sum + current);

console.log(result); // 15` Phương thứcarr.reduceRighttương tự như phương thứcarr.reduce, chỉ khác là thứ tự duyệt từ phải sang trái.
`arr.reduceRight` `arr.reduce` Để biết thêm vềarr.reduce, mời bạn tham khảo bài viết:Ứng dụng reduce trong mảng.
`arr.reduce`"
37,Các phương thức của mảng trong Javascript,Cách kiểm tra giá trị là mảng,"Vì array bản chất là object, nên bạn không thể dùngtypeofđể xác định array.
`typeof` 
```js
let arr = [];
let obj = {};

console.log(typeof arr); // object
console.log(typeof obj); // object
```
`let arr = [];
let obj = {};

console.log(typeof arr); // object
console.log(typeof obj); // object` Để giải quyết vấn đề trên, bạn có thể sử dụng phương thứcArray.isArray(value). Phương thức này trả vềtruenếuvaluelà mảng, ngược lại thì trả vềfalse.
`Array.isArray(value)` `true` `value` `false` 
```js
let arr = [];
let obj = {};

console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false
```
`let arr = [];
let obj = {};

console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false`"
38,Các phương thức của mảng trong Javascript,Tham sốthisArg,"`thisArg` Hầu hết các phương thức của mảng trong JavaScript đều có tham số cuối cùng làthisArg.
`thisArg` Tham số này không bắt buộc và ít sử dụng nên mình không nói đến trong các phần trên.
Cú pháp đầy đủ các phương thức vớithisArglà:
`thisArg` 
```js
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg là tham số cuối cùng và không bắt buộc phải có
```
`arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg là tham số cuối cùng và không bắt buộc phải có` Giá trị củathisArgchính là giá trị củathisở trong hàmfunc.
`thisArg` `this` `func` Ví dụ lọc các giá trị của mảng nằm trong đoạn từminđếnmax:
`min` `max` 
```js
// mảng ban đầu
let arr = [1, 3, 5, 2, 6, 10, 4];

// object điều kiện
let boundary1 = {
  min: 1,
  max: 5,
};

let boundary2 = {
  min: 3,
  max: 8,
};

// filter function
// giá trị của this là object ứng với thisArg
function filterFunc(item) {
  return item >= this.min && item <= this.max;
}

// filter
let ret1 = arr.filter(filterFunc, boundary1);
let ret2 = arr.filter(filterFunc, boundary2);

// kết quả
console.log(ret1); // (5) [1, 3, 5, 2, 4]
console.log(ret2); // (4) [3, 5, 6, 4]
```
`// mảng ban đầu
let arr = [1, 3, 5, 2, 6, 10, 4];

// object điều kiện
let boundary1 = {
  min: 1,
  max: 5,
};

let boundary2 = {
  min: 3,
  max: 8,
};

// filter function
// giá trị của this là object ứng với thisArg
function filterFunc(item) {
  return item >= this.min && item <= this.max;
}

// filter
let ret1 = arr.filter(filterFunc, boundary1);
let ret2 = arr.filter(filterFunc, boundary2);

// kết quả
console.log(ret1); // (5) [1, 3, 5, 2, 4]
console.log(ret2); // (4) [3, 5, 6, 4]`"
39,Các phương thức của mảng trong Javascript,Tổng kết,"Sau đây là tổng kết một số phương thức của mảng trong JavaScript:
`push(...items)` `pop()` `shift()` `unshift(...items)` `splice(pos, deleteCount, ...items)` `pos` `deleteCount` `items` `slice(start, end)` `start` `end` `end` `concat(...items)` `items` `items` `items` `indexOf(item, pos)` `item` `pos` `-1` `lastIndexOf(item, pos)` `indexOf(item, pos)` `includes(value)` `true` `value` `false` `find(func)` `func` `func` `true` `filter(func)` `func` `func` `true` `findIndex(func)` `find(func)` `forEach(func)` `func` `map(func)` `func` `sort(func)` `reverse()` `split(delim)` `delim` `join(delim)` `delim` `reduce(func, initial)` `func` `reduceRight(func, initial)` `reduce` Để kiểm tra một giá trị là mảng, bạn sử dụng phương thứcArray.isArray(value).
`Array.isArray(value)` Trên đây là các phương thức của mảng trong JavaScript mà mình thấy hay sử dụng nhất. Dĩ nhiên, còn nhiều phương thức khác nữa, bạn có thể tự tìm hiểu thêm tại các bài viết sau:"
40,Các phương thức với prototype trong JavaScript,Giới thiệu,"Trong bài viếtPrototype là gì? Prototype trong JavaScript, mình nói rằng__proto__đã lỗi thời và bạn nên dùng các phương thứcObject.getPrototypeOfvàObject.setPrototypeOfđể thay thế.
`__proto__` Vì vậy, bài viết này mình sẽ tập trung vào tìm hiểu về các phương thức với prototype trong JavaScript."
41,Các phương thức với prototype trong JavaScript,Phương thức của prototype,"Các phương thức của prototype trong JavaScript bao gồm:
`[[Prototype]]` `proto` `descriptors` `[[Prototype]]` `proto` `[[Prototype]]` Ví dụ về các phương thức của prototype:

```js
let animal = {
  eats: true,
};

// tạo đối tượng với với prototype là animal
let rabbit = Object.create(animal);
console.log(rabbit.eats); // true

console.log(Object.getPrototypeOf(rabbit) === animal); // true
Object.setPrototypeOf(rabbit, {}); // thay đổi prototype của rabbit thành {}
```
`let animal = {
  eats: true,
};

// tạo đối tượng với với prototype là animal
let rabbit = Object.create(animal);
console.log(rabbit.eats); // true

console.log(Object.getPrototypeOf(rabbit) === animal); // true
Object.setPrototypeOf(rabbit, {}); // thay đổi prototype của rabbit thành {}` Đối tượng mô tả thuộc tínhdescriptorsgiống như mình đã giới thiệu trong bài viết vềwritable, enumerable và configurable.
`descriptors` Bạn có thể sử dụngObject.createđểclone objectthay vì cách sử dụng vòng lặpfor...in:
`Object.create` `for...in` 
```js
let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```
`let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);` Câu lệnh trêncopy object một cách hoàn toàn, bao gồm tất cả các thuộc tính (enumerable và non-enumberable), getters/setters,... với giá trị chính xác của[[Prototype]].
`[[Prototype]]`"
42,Các phương thức với prototype trong JavaScript,Object thuần,"Như bạn đã biết,object thuầnthường dùng để lưu các cặpkey-value, với key làstringhoặcsymbol. Và một điều thú vị,keycó thể là bất kỳ string nào, ngoại trừ""__proto__"", ví dụ:
`""__proto__""` 
```js
let obj = {};
let key = ""__proto__"";

obj[key] = ""some value"";
console.log(obj[key].toString()); // ""[object Object]"" không phải ""some value"".
```
`let obj = {};
let key = ""__proto__"";

obj[key] = ""some value"";
console.log(obj[key].toString()); // ""[object Object]"" không phải ""some value"".` Trong ví dụ trên, mình muốn lưu trữ cặp key-value với giá trị của key là""__proto__"". Tuy nhiên, key này bịbỏ qua. Bởi vì,""__proto__""là một thuộc tính đặc biệt có giá trịnullhoặc mộtobject.
`""__proto__""` `""__proto__""` `null` Làm sao để giải quyết vấn đề này?
►Cách 1: bạn có thể chuyển qua sử dụngMapthay vì sử dụng object thuần như sau:

```js
let obj = new Map();
let key = ""__proto__"";

obj.set(key, ""some value"");
console.log(obj.get(key).toString()); // ""some value""
```
`let obj = new Map();
let key = ""__proto__"";

obj.set(key, ""some value"");
console.log(obj.get(key).toString()); // ""some value""` ►Cách 2: sử dụngObject.create(null), ví dụ:
`Object.create(null)` 
```js
let obj = Object.create(null);
let key = ""__proto__"";

obj[key] = ""some value"";
console.log(obj[key].toString()); // ""some value""
```
`let obj = Object.create(null);
let key = ""__proto__"";

obj[key] = ""some value"";
console.log(obj[key].toString()); // ""some value""` Bởi vì,__proto__không phải một thuộc tính trong object, mà chỉ làgetter/settercho[[Prototype]].
`__proto__` `[[Prototype]]` Khi gọiObject.create(null), thực chất là bạn đang tạo một object không có[[Prototype]]. Do đó,__proto__cũng không trở thànhgetter/setter.
`Object.create(null)` `[[Prototype]]` `__proto__` Vì vậy,__proto__có thể trở thànhthuộc tính bình thườngtrong object như cách làm trên.
`__proto__`"
43,Các phương thức với prototype trong JavaScript,Tổng kết,"Các phương thức với prototype trong JavaScript là:
`[[Prototype]]` `proto` `descriptors` `[[Prototype]]` `proto` `[[Prototype]]` __proto__thực chất làgetter/settercủa[[Prototype]]trong object. Vì vậy, bạn không thể lưukey-valuevới giá trị của key là__proto__.
`__proto__` `[[Prototype]]` `__proto__` Để giải quyết vấn đề trên, bạn có thể sử dụngMapthay vì object thuần, hoặc dùngObject.create(null)để tạo ra object không có prototype.
`Object.create(null)` Ngoài ra,Object.createcòn được dùng đểclone objectnhư sau:
`Object.create` 
```js
let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```
`let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);` Các phương thức hữu ích khác:
`true` `obj` `key`"
44,Các phương thức với prototype trong JavaScript,Thực hành,"Cho đoạn code sau:

```js
let dictionary = Object.create(null);

// Thêm phương thức toString vào dictionary tại đây

// thêm data vào dictionary
dictionary.apple = ""Apple"";
dictionary.__proto__ = ""test""; // __proto__ là một thuộc tính thường

// chỉ apple và __proto__ xuất hiện trong vòng lặp
for (let key in dictionary) {
  console.log(key); // ""apple"" rồi đến ""__proto__""
}

// gọi dictionary.toString()
console.log(dictionary.toString()); // ""apple,__proto__""
```
`let dictionary = Object.create(null);

// Thêm phương thức toString vào dictionary tại đây

// thêm data vào dictionary
dictionary.apple = ""Apple"";
dictionary.__proto__ = ""test""; // __proto__ là một thuộc tính thường

// chỉ apple và __proto__ xuất hiện trong vòng lặp
for (let key in dictionary) {
  console.log(key); // ""apple"" rồi đến ""__proto__""
}

// gọi dictionary.toString()
console.log(dictionary.toString()); // ""apple,__proto__""` Hãy thêm phương thứctoStringvàodictionaryđể thỏa mãn đoạn code trên?
`toString` `dictionary` Xem đáp án

```js
let dictionary = Object.create(null);

// Thêm phương thức toString vào dictionary tại đây
Object.defineProperty(dictionary, ""toString"", {
  value: function () {
    return Object.keys(this).join("","");
  },
  enumberable: false,
});
// thêm data vào dictionary
dictionary.apple = ""Apple"";
dictionary.__proto__ = ""test""; // __proto__ là một thuộc tính thường

// chỉ apple và __proto__ xuất hiện trong vòng lặp
for (let key in dictionary) {
  console.log(key); // ""apple"" rồi đến ""__proto__""
}

// gọi dictionary.toString()
console.log(dictionary.toString()); // ""apple,__proto__""
```
`let dictionary = Object.create(null);

// Thêm phương thức toString vào dictionary tại đây
Object.defineProperty(dictionary, ""toString"", {
  value: function () {
    return Object.keys(this).join("","");
  },
  enumberable: false,
});
// thêm data vào dictionary
dictionary.apple = ""Apple"";
dictionary.__proto__ = ""test""; // __proto__ là một thuộc tính thường

// chỉ apple và __proto__ xuất hiện trong vòng lặp
for (let key in dictionary) {
  console.log(key); // ""apple"" rồi đến ""__proto__""
}

// gọi dictionary.toString()
console.log(dictionary.toString()); // ""apple,__proto__""` Cho đoạn code sau:

```js
function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function () {
  console.log(this.name);
};

let rabbit = new Rabbit(""Rabbit"");
```
`function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function () {
  console.log(this.name);
};

let rabbit = new Rabbit(""Rabbit"");` Các câu lệnh sau có giống nhau hay không?

```js
rabbit.sayHi(); // (1)
Rabbit.prototype.sayHi(); // (2)
Object.getPrototypeOf(rabbit).sayHi(); // (3)
rabbit.__proto__.sayHi(); // (4)
```
`rabbit.sayHi(); // (1)
Rabbit.prototype.sayHi(); // (2)
Object.getPrototypeOf(rabbit).sayHi(); // (3)
rabbit.__proto__.sayHi(); // (4)` Xem đáp án
Kết quả
(1) - Rabbit(2) - undefined(3) - undefined(4) - undefined
Câu lệnh(1)thìthis=rabbit, bởi vìrabbitlà object đứng trước., nên đáp án đúng như trên.
`(1)` `this=rabbit` `rabbit` `.` Các câu lệnh(2), (3), (4)thìthis=Rabbit.prototype. Mà trongRabbit.prototypekhông có thuộc tínhname.
`(2), (3), (4)` `this=Rabbit.prototype` `Rabbit.prototype` `name` Tham khảo:Prototype methods, objects without__proto__
`__proto__`"
45,Cấu trúc code trong Javascript,Giới thiệu,"Chương trình là tập hợp của các câu lệnh. Hay nói cách khác, câu lệnh trong JavaScript là đơn vị cơ bản xây dựng nên một chương trình. Vì vậy, câu lệnh là khái niệm đầu tiên mà mình cần nắm vững khi học lập trình JavaScript."
46,Cấu trúc code trong Javascript,Câu lệnh trong JavaScript,"Câu lệnh là đơn vị cơ bản của một ngôn ngữ lập trình, đưa ra hướng dẫn cho máy tính để thực hiện một hành động.
Trong bài viết vềchương trình JavaScript đầu tiên, bạn đã thấy mình sử dụng hai câu lệnh:
`console.log(""Hello World"")` `alert(""Hello World"")` Đó là những câu lệnh rất cơ bản.
Và trong một chương trình, bạn có thể viết nhiều câu lệnh tùy thích. Mỗi câu lệnh trong JavaScript thường được ngăn cách nhau bởi dấu chấm phẩy (;).
`;` Ví dụ hiển thị dòng chữ trên bằng hai câu lệnhconsole.logkhác nhau:
`console.log` 
```js
console.log(""Hello"");
console.log(""World"");
```
`console.log(""Hello"");
console.log(""World"");` Thông thường, mình sẽ viết mỗi câu lệnh trên một dòng cho dễ nhìn hơn:

```js
console.log(""Hello"");
console.log(""World"");
```
`console.log(""Hello"");
console.log(""World"");` Kết quả
HelloWorld"
47,Cấu trúc code trong Javascript,Dấu chấm phẩy trong JavaScript,"Dấu chấm phẩy trong JavaScript thường có thể bỏ qua nếu bạn viết các câu lệnh trên nhiều dòng. Ở ví dụ trên, bạn bỏ qua dấu chấm phẩy như sau:

```js
console.log(""Hello"");
console.log(""World"");
```
`console.log(""Hello"");
console.log(""World"");` Kết quả
HelloWorld
Nguyên nhân là do trình thông dịchtự động thêm dấu chấm phẩydựa trên kí tự xuống dòng. Tuy nhiên, vẫn có nhiều trường hợp xuống dòng nhưng JavaScript vẫn hiểu đó là một câu lệnh, ví dụ:

```js
console.log(1 + 1 + 1);
```
`console.log(1 + 1 + 1);` Ba dòng trên vẫn chỉ là một câu lệnh. Và kết quả thu được là:3.
Bởi vì, khi hết dòng đầu tiên, bạn thấy rằng vẫn thiếu dấu đóng ngoặc)cho câu lệnhconsole.log().
`)` `console.log()` Do đó, trình thông dịch hiểu rằng, đây là câu lệnh không đầy đủ, nên sẽ không chèn dấu chấm phẩy vào cuối dòng.
Đúng là trình thông dịch JavaScript khá thông minh. Nhưng vẫn có nhiều trường hợp mà bạn sẽ nhận được một kết quả không như mong muốn.
Ví dụ một đoạn code chạy đúng:

```js
console.log(""Hello world"");
[1, 2].forEach((value) => console.log(value));
```
`console.log(""Hello world"");
[1, 2].forEach((value) => console.log(value));` Có thể bạn chưa hiểu về câu lệnh thứ hai (các bài viết sau bạn sẽ biết) - kết quả hiển thị là:
Kết quả
Hello world12
Nhưng nếu bạn bỏ qua dấu chấm phẩy thì sao?

```js
console.log(""Hello world"")[(1, 2)].forEach((value) => console.log(value));
```
`console.log(""Hello world"")[(1, 2)].forEach((value) => console.log(value));` Kết quả
Bạn sẽ bị lỗi cú phápHello worldUncaught TypeError: Cannot read properties of undefined (reading '2')
Kì lạ phải không? 🤔
Đây là một trong số những thứ gây đau đầu nhất khi lập trình JavaScript. Vì vậy, lời khuyên cho bạn là:
Có thể bạn chưa biết
Luôn luôn sử dụng dấu chấm phẩy để kết thúc một câu lệnh."
48,Cấu trúc code trong Javascript,Comment code trong JavaScript,"Theo thời gian, chương trình sẽ phức tạp dần lên. Số lượng câu lệnh JavaScript cũng sẽ tăng lên theo. Có nhiều câu lệnh mà khi xem lại, bạn sẽ không hiểu tại sao mình viết code như vậy.
Để tránh tình trạng này xảy ra, bạn nên viết lại chú thích (comment).
Có hai kiểu viết chú thích là:
`//` `/* */` Ví dụ chú thích một dòng:

```js
// Đây là chú chích trên 1 dòng
console.log(""Hello"");

console.log(""World""); // Đây cũng là chú thích 1 dòng nhưng ở cuối câu lệnh

// Tạm thời bỏ qua câu lệnh sau đây
//alert(""Hello world"");
```
`// Đây là chú chích trên 1 dòng
console.log(""Hello"");

console.log(""World""); // Đây cũng là chú thích 1 dòng nhưng ở cuối câu lệnh

// Tạm thời bỏ qua câu lệnh sau đây
//alert(""Hello world"");` Ví dụ chú thích trên nhiều dòng:

```js
/* Đây là chú thích
    trên nhiều dòng
    */
    console.log(""Hello"");

    console.log(""World""); /* Đây cũng là chú thích
    nhiều dòng nhưng ở cuối câu lệnh */

    /**
     * Tạm thời bỏ qua câu lệnh sau đây
     * alert(""Hello world"");
     * /
```
`/* Đây là chú thích
    trên nhiều dòng
    */
    console.log(""Hello"");

    console.log(""World""); /* Đây cũng là chú thích
    nhiều dòng nhưng ở cuối câu lệnh */

    /**
     * Tạm thời bỏ qua câu lệnh sau đây
     * alert(""Hello world"");
     * /` Khi chạy chương trình, JavaScript engine sẽ bỏ qua thành phần chú thích này.
Một vài trường hợp mình viết chú thích:
Có một số khái niệm mới ở đây, mình sẽ trình bày ở các bài viết sau.
Dĩ nhiên, bạn cũng đừng sợ việc viết nhiều chú thích sẽ làm cho trang web nặng lên. Vì hiện giờ đã có rất nhiều công cụ hỗ trợbỏ hết chú thíchkhi triển khai trang web ở môi trường thực tế."
49,Cấu trúc rẽ nhánh trong Javascript,Giới thiệu,"Khi lập trình, bạn sẽ thường xuyên gặp tình huống làchỉ thực hiện một hành động nếu một hoặc nhiều điều kiện thỏa mãn. Để giải quyết vấn đề này, bạn cần phải biết về cấu trúc rẽ nhánh trong JavaScript.
Có hai cấu trúc rẽ nhánh trong JavaScript là:"
50,Cấu trúc rẽ nhánh trong Javascript,Câu lệnh rẽ nhánh trong JavaScript,"Sau đây là những kiến thức cơ bản cần nhớ về câu lệnh rẽ nhánhiftrong JavaScript.
`if` `if` Câu lệnhif(...)sẽ kiểm tra điều kiện biểu thức bên trong cặp dấu ngoặc đơn(). Nếu kết quả làtruethì một khối code sẽ được thực thi.
`if(...)` `()` `true` Ví dụ về câu lệnhif:
`if` 
```js
const x = 2;

if (x % 2 === 0) console.log(""x is an even number"");
```
`const x = 2;

if (x % 2 === 0) console.log(""x is an even number"");` Vìx = 2nên x chia 2 dư 0. Do đó,x % 2 === 0làtrue. Vì vậy, câu lệnhconsole.logtrên được thực hiện.
`x = 2` `x % 2 === 0` `true` `console.log` Để thực hiện nhiều câu lệnh, bạn sử dụng cặp dấu{}:
`{}` 
```js
const x = 2;

if (x % 2 === 0) {
  console.log(""x is an even number"");
  console.log(""done!"");
}
```
`const x = 2;

if (x % 2 === 0) {
  console.log(""x is an even number"");
  console.log(""done!"");
}` Kết quả
x is an even numberdone!
💡 Theo mình, dù khối code sau câu lệnhiflà một hay nhiều câu lệnh thì bạn cũng nên dùng cặp dấu{}để code dễ đọc hơn. Ngoài ra, mình cũng nhắc lại quy luậtchuyển đổi kiểu dữ liệusang boolean như sau:
`if` `{}` `0` `""""` `null` `undefined` `NaN` `false` `true` Vì vậy, khối lệnh với điều kiện sau sẽ không bao giờ được thực thi:

```js
// 0 là giá trị falsy
if (0) {
  // các câu lệnh
}
```
`// 0 là giá trị falsy
if (0) {
  // các câu lệnh
}` Ngược lại, khối lệnh với điều kiện sau lại luôn luôn được thực thi:

```js
// 1 là giá trị truthy
if (1) {
  // các câu lệnh
}
```
`// 1 là giá trị truthy
if (1) {
  // các câu lệnh
}` Ngoài ra, bạn có thể tính toán giá trị của điều kiện trước khi dùngif:
`if` 
```js
const x = 2;
const result = x % 2 === 0; // kết quả là true
if (result) {
  console.log(""x is an even number""); // câu lệnh này được thực thi
}
```
`const x = 2;
const result = x % 2 === 0; // kết quả là true
if (result) {
  console.log(""x is an even number""); // câu lệnh này được thực thi
}` `else` Đi theo câu lệnhifcòn có mệnh đềelse- dùng để thực hiện một khối lệnh khi điều kiện trongiflà giá trịfalsy.
`if` `else` `if` `falsy` Tiếp theo ví dụ trên:

```js
const x = 3;

if (x % 2 === 0) {
  console.log(""x is an even number"");
} else {  console.log(""x is an odd number""); // câu lệnh này được thực thi}
```
`const x = 3;

if (x % 2 === 0) {
  console.log(""x is an even number"");
} else {  console.log(""x is an odd number""); // câu lệnh này được thực thi}` Vìx = 3nên x chia 2 dư 1. Do đó,x % 2 === 0làfalse. Vì vậy, khối lệnh sauelseđược thực thi.
`x = 3` `x % 2 === 0` `false` `else` `else if` Trong trường hợp, bạn cần kiểm tra nhiều điều kiện liên tiếp nhau thì có thể dùng nhiều mệnh đềelse ifnối tiếp nhau.
`else if` 
```js
const age = 24;

if (age < 18) {
  console.log(""Too young!"");
} else if (age > 50) {
  console.log(""Too old!"");
} else {
  console.log(""OK!"");
}
// OK!
```
`const age = 24;

if (age < 18) {
  console.log(""Too young!"");
} else if (age > 50) {
  console.log(""Too old!"");
} else {
  console.log(""OK!"");
}
// OK!` Đoạn code trên kiểm tra điều kiệnage < 18đầu tiên. Nếu đúng thì câu lệnhconsole.logđầu tiên được thực thi. Nếu sai thì kiểm tra tiếp đến điều kiệnage > 50. Nếu đúng thì câu lệnhconsole.logthứ hai được thực thi. Nếu vẫn sai thì câu lệnhconsole.logcuối cùng được thực thi.
`age < 18` `console.log` `age > 50` `console.log` `console.log` Ở đây,age = 24nênage < 18vàage > 50đều làfalse. Vì vậy, câu lệnhconsole.logcuối cùng được thực thi.
`age = 24` `age < 18` `age > 50` `false` `console.log` Chú ý:Mệnh đềelsecuối cùng không bắt buộc phải có.
`else` Ví dụ trên khi bỏ mệnh đềelsecuối cùng:
`else` 
```js
const age = 24;

if (age < 18) {
  console.log(""Too young!"");
} else if (age > 50) {
  console.log(""Too old!"");
}
```
`const age = 24;

if (age < 18) {
  console.log(""Too young!"");
} else if (age > 50) {
  console.log(""Too old!"");
}` Lần này, không có điều kiện nào thỏa mãn, nên không câu lệnhconsolenào được thực thi.
`console`"
51,Cấu trúc rẽ nhánh trong Javascript,Toán tử rẽ nhánh,"Sau đây là những kiến thức cơ bản cần nhớ về toán tử rẽ nhánh?trong JavaScript.
`?` `?` Trong nhiều trường hợp, bạn cần gán giá trị cho một biến dựa trên một điều kiện, ví dụ:

```js
const age = 24;

let enoughAge;
if (age < 18) {
  enoughAge = false;
} else {
  enoughAge = true;
}

console.log(enoughAge); // true
```
`const age = 24;

let enoughAge;
if (age < 18) {
  enoughAge = false;
} else {
  enoughAge = true;
}

console.log(enoughAge); // true` Để đơn giản hơn, bạn có thể dùng toán tử rẽ nhánh?(hoặc có thể gọi làtoán tử dấu hỏi), với cú pháp:
`?` 
```js
const result = condition ? value1 : value2;
```
`const result = condition ? value1 : value2;` Đây là toán tử ba ngôi với ba thành phần:
`truthy` `falsy` Ví dụ trên trở thành:

```js
const age = 24;

const enoughAge = age < 18 ? false : true;
console.log(enoughAge); // true
```
`const age = 24;

const enoughAge = age < 18 ? false : true;
console.log(enoughAge); // true` Ngoài ra, bạn có thể dùng cặp dấu ngoặc đơn()cho dễ nhìn (và chắc chắn hơn - khi bạn không rõ về thứ tự ưu tiên của các toán tử):
`()` 
```js
const age = 24;

const enoughAge = age < 18 ? false : true;
console.log(enoughAge); // true
```
`const age = 24;

const enoughAge = age < 18 ? false : true;
console.log(enoughAge); // true` Đây chỉ là ví dụ minh họa. Thực tế trong trường hợp này, bạn có thể code đơn giản hơn như sau:

```js
const age = 24;
const enoughAge = age >= 18;
console.log(enoughAge); // true
```
`const age = 24;
const enoughAge = age >= 18;
console.log(enoughAge); // true` `?` Cùng xem lại ví dụ về nhiều mệnh đềelse ifbên trên:
`else if` 
```js
const age = 24;

if (age < 18) {
  console.log(""Too young!"");
} else if (age > 50) {
  console.log(""Too old!"");
} else {
  console.log(""OK!"");
}
```
`const age = 24;

if (age < 18) {
  console.log(""Too young!"");
} else if (age > 50) {
  console.log(""Too old!"");
} else {
  console.log(""OK!"");
}` Bạn có thể sửa lại bằng cách sử dụng nhiều toán tử?như sau:
`?` 
```js
const age = 24;

const message = age < 18 ? ""Too young!"" : age > 50 ? ""Too old!"" : ""OK!"";
console.log(message); // OK!
```
`const age = 24;

const message = age < 18 ? ""Too young!"" : age > 50 ? ""Too old!"" : ""OK!"";
console.log(message); // OK!` Thoạt nhìn thì có vẻ phức tạp, nhưng bạn có thể phân tích kỹ ra như sau sẽ hiểu:
`?` `age < 18` `""Too young!""` `:` `?` `age > 50` `""Too old!""` `:` `false` `""OK!""` `?` `if` Bạn có thể dùng toán tử?để kiểm tra điều kiện và thực hiện một câu lệnh thay cho câu lệnhif, ví dụ:
`?` `if` 
```js
const x = 2;

x % 2 === 0 ? console.log(""even number"") : console.log(""odd number""); // even number
```
`const x = 2;

x % 2 === 0 ? console.log(""even number"") : console.log(""odd number""); // even number` Mặc dù, đoạn code trên là đúng. Nhưng theo mình thì không nên code như vậy. Vì code như vậy khá khó nhìn và không trực quan.
Bạn nên sử dụng đúng mục đích của câu lệnhifvà toán tử?. Với đoạn code trên, bạn nên sử dụng câu lệnhifnhư sau:
`if` `?` `if` 
```js
const x = 2;

if (x % 2 === 0) {
  console.log(""even number"");
} else {
  console.log(""odd number"");
}
// even number
```
`const x = 2;

if (x % 2 === 0) {
  console.log(""even number"");
} else {
  console.log(""odd number"");
}
// even number`"
52,Cấu trúc rẽ nhánh trong Javascript,Tổng kết về cấu trúc rẽ nhánh,"Có hai cấu trúc rẽ nhánh trong JavaScript là:
Câu lệnhif(...)sẽ kiểm tra điều kiện biểu thức bên trong cặp dấu ngoặc đơn().
`if(...)` `()` `true` `false` `else` Toán tử?thường chỉ dùng để gán giá trị cho một biến dựa trên một điều kiện. Bạn nên sử dụng đúng mục đích của toán tử?để code rõ ràng và dễ hiểu hơn.
`?` `?`"
53,Cấu trúc rẽ nhánh trong Javascript,Thực hành,"Sử dụnghàmprompt, hiển thị nội dung yêu cầu người dùng nhập vào một số nguyên dương chẵn.
`prompt` Nếu người dùng nhập vào đúng số chẵn thì hiển thịBạn đã nhập đúng!. Ngược lại, hiển thịBạn đã nhập sai!.
Giả sử, người dùng luôn nhập vào số nguyên dương.
Xem đáp án

```js
<html>
  <body>
    <script>
      const value = prompt(""Nhập vào số nguyên dương chẵn:"", 0);
      if (value % 2 === 0) {
        alert(""Bạn đã nhập đúng!"");
      } else {
        alert(""Bạn đã nhập sai!"");
      }
    </script>
  </body>
</html>
```
`<html>
  <body>
    <script>
      const value = prompt(""Nhập vào số nguyên dương chẵn:"", 0);
      if (value % 2 === 0) {
        alert(""Bạn đã nhập đúng!"");
      } else {
        alert(""Bạn đã nhập sai!"");
      }
    </script>
  </body>
</html>` Sử dụng toán tử?thay cho câu lệnhif:
`?` `if` 
```js
let a = 10;
let b = 20;
let result;

if (a + b < 10) {
  result = ""Small"";
} else {
  result = ""Big"";
}

console.log(result);
```
`let a = 10;
let b = 20;
let result;

if (a + b < 10) {
  result = ""Small"";
} else {
  result = ""Big"";
}

console.log(result);` Xem đáp án

```js
let a = 10;
let b = 20;
let result;

result = a + b < 10 ? ""Small"" : ""Big"";
console.log(result);
```
`let a = 10;
let b = 20;
let result;

result = a + b < 10 ? ""Small"" : ""Big"";
console.log(result);`"
54,Chương trình Javascript đầu tiên,Giới thiệu,"Trong toàn bộ khoá học này, chúng ta sẽ chỉ sử dụng Javascript là ngôn ngữ xây dựng ứng dụng client (front-end) trên trình duyệt."
55,Chương trình Javascript đầu tiên,Hello World JavaScript Console,"Cách đơn giản nhất để viết và chạy chương trình JavaScript đầu tiên là sử dụng tiện ích console của Dev Tools trên trình duyệt.
Tùy thuộc vào trình duyệt bạn đang sử dụng, bạn có thể nhấnF12hoặc tổ hợp phímCtrl Shift I(Windows) hoặcCtrl Opt J(macOS),...
Sau đó, bạn chọn tabconsolerồi gõ lệnh sau:console.log(""JavaScript Helloworld""). Tiếp theo, bạn nhấnEnter(để viết nhiều dòng code, bạn nhấn tổ hợpShift Enter).
`console.log(""JavaScript Helloworld"")` Kết quả
JavaScript Helloworld
Console.logtrong JavaScript là một hàm được sử dụng để in ra bất kể thứ gì (với trình duyệt thì nơi hiển thị kết quả đó là tab console của Dev Tools).
`Console.log` Bạn sẽ không cần phải cài đặt thêm bất cứ phần mềm nào khác. Bạn chỉ cần mở trình duyệt, vừa đọc hướng dẫn và thực hành trên tab console của Dev Tools.
Sau khi bạn đã nắm hết kiến thức cơ bản về ngôn ngữ JavaScript, mình sẽ bắt đầu học về trình duyệt, HTML, và cách JavaScript giao tiếp với HTML,..."
56,Chương trình Javascript đầu tiên,Chương trình JavaScript đầu tiên với HTML,"Để chạy một chương trình Javascript, bạn cần đưa mã JS vào trong một trong HTML."
57,Chương trình Javascript đầu tiên,Viết mã lệnh trực tiếp vào trang web,"Bạn đặt toàn bộ mã Javascript vào trong thẻ<script>. Điều này giúp trình duyệt phân biệt mã JS với phần còn lại. Ngoài ra, vì có các ngôn ngữ kịch bản cho client khác nữa (ví dụ: VBScript...), do đó, bạn nên chỉ định ngôn ngữ kịch bản mà bạn sử dụng trong thẻ<script>, kiểu như sau:
`<script>` `<script>` 
```js
<script type=""text/javascript"">
```
`<script type=""text/javascript"">` Bạn tạo mới một tệphtmlđặt tên làindex.html, có nội dung như sau:
`html` `index.html` 
```js
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Học lập trình Javascript</title>
  </head>
  <body>
    <h2>Xin chào độc giả kungfutech</h2>
    <span id=""content""></span>
  </body>
  <script type=""text/javascript"">
    document.getElementById(""content"").innerHTML = ""Học lập trình Javascript "";
  </script>
</html>
;
```
`<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Học lập trình Javascript</title>
  </head>
  <body>
    <h2>Xin chào độc giả kungfutech</h2>
    <span id=""content""></span>
  </body>
  <script type=""text/javascript"">
    document.getElementById(""content"").innerHTML = ""Học lập trình Javascript "";
  </script>
</html>
;` Bạn lưu lại và mở tệp lên bằng trình duyệt. Đây là kết quả thu được"
58,Chương trình Javascript đầu tiên,Viết mã lệnh JavaScript vào tập tin JavaScript,"Với cách viết Javascript trực tiếp vào trong HTML sẽ khiến cho mã nguồn trở nên ""rối rắm"", đặc biệt khi dự án ngày càng trở nên phức tạp. Đặc biệt là trong trường hợp chúng ta muốn xây dựng các plugin/module bằng javascript, tách biệt với HTML.
Chúng ta sẽ tách mã JS ra khỏi HTML, và chỉ nhúng đường dẫn trỏ tới tệp.jstrong HTML mà thôi.
`.js` 
```js
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Sách học lập trình Javascript</title>
  </head>
  <body>
    <h2>Xin chào độc giả kungfutech</h2>
    <span id=""content""></span>
  </body>
  <script src=""src/index.js""></script>
</html>
;
```
`<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Sách học lập trình Javascript</title>
  </head>
  <body>
    <h2>Xin chào độc giả kungfutech</h2>
    <span id=""content""></span>
  </body>
  <script src=""src/index.js""></script>
</html>
;` Còn nội dung tệpindex.jsnhư sau:
`index.js` 
```js
document.getElementById(""content"").innerHTML =
  ""Tài liệu học Javascript toàn tập"";
```
`document.getElementById(""content"").innerHTML =
  ""Tài liệu học Javascript toàn tập"";`"
59,Chương trình Javascript đầu tiên,Sử dụng IDE online.,"Để học Javascript, thay vì sử dụng hai cách trên, mình thường tìm tới các Text Editor Online để viết và chạy thử chương trình Javascript được nhanh và trực quan nhất.
Một số Text Editor Online gợi ý cho bạn:
Ưu điểm của những trình Text Editor Online này là dễ sử dụng, được tích hợp sẵn mọi thứ, không cần cài đặt thêm gì cả. Việc của bạn chỉ là gõ code và chạy
Đọc đến đây, mình hi vọng bạn đã hiểu được phần nào về ngôn ngữ lập trình Javascript, biết cách tạo một ứng dụng đơn giản với Javascript. Phần tiếp theo, chúng ta sẽ cùng nhau tìm hiểu các cú pháp từ cơ bản tới nâng cao của Javascript nhé"
60,Chuyển đổi kiểu dữ liệu trong Javascript,Giới thiệu,"Bài viết trước bạn đã biết về8 kiểu dữ liệu cơ bảntrong JavaScript. Và khi học vềtoán tửhay hàm, bạn sẽ thấy là các kiểu dữ liệu này có thể được chuyển đổi cho nhau. Đó gọi là ""chuyển đổi kiểu dữ liệu""."
61,Chuyển đổi kiểu dữ liệu trong Javascript,Chuyển đổi kiểu dữ liệu sang string,"Để chuyển đổi bất kỳ kiểu dữ liệu nào sang string, bạn có thể dùng hàmString(value).
`String(value)` 
```js
console.log(String(1)); // ""1""
console.log(String(NaN)); // ""NaN""
console.log(String(Infinity)); // ""Infinity""
console.log(String(true)); // ""true""
console.log(String(false)); // ""false""
console.log(String(null)); // ""null""
console.log(String(undefined)); // ""undefined""
```
`console.log(String(1)); // ""1""
console.log(String(NaN)); // ""NaN""
console.log(String(Infinity)); // ""Infinity""
console.log(String(true)); // ""true""
console.log(String(false)); // ""false""
console.log(String(null)); // ""null""
console.log(String(undefined)); // ""undefined""` Bạn có thấy rằng, chuyển đổi kiểu dữ liệu sang string khá đơn giản về dễ hiểu phải không?
Chỉ cần thêm cặp dấu nháy kép""""là xong. Còn về hình thức thì mọi thứ vẫn giữ nguyên.
`""""`"
62,Chuyển đổi kiểu dữ liệu trong Javascript,Chuyển đổi kiểu dữ liệu sang number,"Khi thực hiện tính toán, JavaScript sẽ chuyển đổi các kiểu dữ liệu về kiểu dữ liệu number.
Ví dụ phép chia giữa hai string:

```js
console.log(""10"" / ""2""); // 5
```
`console.log(""10"" / ""2""); // 5` Bởi vì string""10""và""2""được chuyển đổi về kiểu number thành số10và số2. Nên kết quả thu được là 5.
`""10""` `""2""` `10` `2` Để chuyển đổi bất kỳ kiểu dữ liệu nào thành number, bạn có thể dùng hàmNumber(value), ví dụ:
`Number(value)` 
```js
console.log(Number("""")); // 0
console.log(Number(""Hello"")); // NaN
console.log(Number(""10"")); // 10
console.log(Number("" "")); // 0
console.log(Number("" 99 "")); // 99
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0
console.log(Number(undefined)); // NaN
```
`console.log(Number("""")); // 0
console.log(Number(""Hello"")); // NaN
console.log(Number(""10"")); // 10
console.log(Number("" "")); // 0
console.log(Number("" 99 "")); // 99
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0
console.log(Number(undefined)); // NaN` Bạn để ý một số quy luật khi chuyển đổi kiểu dữ liệu về number như sau:
`null` `0` `undefined` `NaN` `true` `1` `false` `0` `""""` `0` `NaN`"
63,Chuyển đổi kiểu dữ liệu trong Javascript,Chuyển đổi kiểu dữ liệu sang boolean,"Để chuyển đổi kiểu dữ liệu sang boolean, bạn có thể dùng hàmBoolean(value).
`Boolean(value)` Quy luật chuyển đổi sang boolean như sau:
`0` `""""` `null` `undefined` `NaN` `false` `true` 
```js
console.log(Boolean(0)); // false
console.log(Boolean(1)); // true
console.log(Boolean(10n)); // true
console.log(Boolean(Infinity)); // true
console.log(Boolean("""")); // false
console.log(Boolean(""hello"")); // true
console.log(Boolean(""  "")); // true
console.log(Boolean(NaN)); // false
console.log(Boolean(undefined)); // false
```
`console.log(Boolean(0)); // false
console.log(Boolean(1)); // true
console.log(Boolean(10n)); // true
console.log(Boolean(Infinity)); // true
console.log(Boolean("""")); // false
console.log(Boolean(""hello"")); // true
console.log(Boolean(""  "")); // true
console.log(Boolean(NaN)); // false
console.log(Boolean(undefined)); // false` Trên đây là một số kiến thức cơ bản cần nhớ về chuyển đổi kiểu dữ liệu trong JavaScript. Hy vọng bạn nắm được những kiến thức cơ bản. Vì đến những bài viết sau, mình sẽ gặp vấn đề chuyển đổi kiểu dữ liệu này khá nhiều."
64,Chuyển đổi Object về kiểu dữ liệu nguyên thủy trong Javascript,Giới thiệu,"Trong bài viếtchuyển đổi kiểu dữ liệu, mình đã giới thiệu về cách chuyển đổi các kiểu dữ liệu nguyên thủy sangnumbervàstring.
Nhưng nếu toán hạngkhông phải kiểu dữ liệu nguyên thủy mà là objectthì sao? Hay làm sao để chuyển đổi object về kiểu dữ liệu nguyên thủy?
Sau đây là những kiến thức cơ bản bạn cần biết."
65,Chuyển đổi Object về kiểu dữ liệu nguyên thủy trong Javascript,Quy luật chuyển đổi object về kiểu nguyên thủy,"Có ba kiểu dữ liệu nguyên thủy bạn cần quan tâm là:string, number và boolean.
Khi chuyển đổi object về boolean thì kết quả luôn làtrue.
`true` Ví dụ sử dụng object vớicâu lệnhif:
`if` 
```js
let obj = {};

if (obj) {
  console.log(""obj is true""); // obj is true
}
```
`let obj = {};

if (obj) {
  console.log(""obj is true""); // obj is true
}` Hoặc chủ động convert sang kiểu boolean sử dụngBoolean():
`Boolean()` 
```js
let obj = {};
console.log(Boolean(obj)); // true
```
`let obj = {};
console.log(Boolean(obj)); // true` Với kiểu dữ liệu boolean là như vậy, đối vớistringvànumberthì sao?
JavaScript cóba kiểu chuyển đổi, ứng với giá trị ngầm định của ""hint"" là:string,numberhoặcdefault.
`string` `number` `default` ► Trong những ngữ cảnh cầnstringthì giá trị của ""hint"" làstring. Ví dụ sử dụng object trong hàmalerthoặc làm thuộc tính của object khác,... JavaScript sẽ chuyển đổi object về dạng string:
`string` `alert` 
```js
let obj = {};

// sử dụng trong hàm alert()
alert(obj); // kết quả hiển thị trên dialog là: [object Object]

// sử dụng làm thuộc tính của object khác
let anotherObj = {};
anotherObj[obj] = 1;

console.log(anotherObj[""[object Object]""]); // 1
```
`let obj = {};

// sử dụng trong hàm alert()
alert(obj); // kết quả hiển thị trên dialog là: [object Object]

// sử dụng làm thuộc tính của object khác
let anotherObj = {};
anotherObj[obj] = 1;

console.log(anotherObj[""[object Object]""]); // 1` Đối tượngobjđã được chuyển đổi sang string, trở thành[object Object].
`obj` `[object Object]` ► Trong những ngữ cảnh cầnnumber, giá trị của ""hint"" lànumber. Ví dụ thực hiện các phép toán số học, so sánh,... JavaScript chuyển đổi object về dạng number:
`number` 
```js
let obj = {};

// chủ động convert sang number
let num = Number(obj);
console.log(num); // NaN

// sử dụng toán tử một ngôi +
let n = +obj;
console.log(num); // NaN

// trừ date
let date1 = new Date(""December 01, 2021 00:00:00"");
let date2 = new Date(""December 02, 2021 00:00:00"");
let delta = date2 - date1;
console.log(delta); // 86400000 - giá trị miliseconds của 1 ngày

// so sánh
let p1 = { x: 1 };
let p2 = { x: 2 };
let greater = p2 > p1;
console.log(greater); // false
```
`let obj = {};

// chủ động convert sang number
let num = Number(obj);
console.log(num); // NaN

// sử dụng toán tử một ngôi +
let n = +obj;
console.log(num); // NaN

// trừ date
let date1 = new Date(""December 01, 2021 00:00:00"");
let date2 = new Date(""December 02, 2021 00:00:00"");
let delta = date2 - date1;
console.log(delta); // 86400000 - giá trị miliseconds của 1 ngày

// so sánh
let p1 = { x: 1 };
let p2 = { x: 2 };
let greater = p2 > p1;
console.log(greater); // false` ► Trong những trường hợpkhông chắc chắn, ví dụ cộng hai object với toán tử+, so sánh bằng không nghiêm ngặt==,...
`+` `==` JavaScript ""không biết"" nên chuyển object về kiểu dữ liệu nào, vì các toán tử này áp dụng được với cảnumber và string.
Khi đó, JavaScript sẽ xử lý theoquy luật mặc định.

```js
// sử dụng toán tử +
let total = obj1 + obj2;

// so sánh == với number
if (user == 1) {
  // do something
}
```
`// sử dụng toán tử +
let total = obj1 + obj2;

// so sánh == với number
if (user == 1) {
  // do something
}` Để chuyển đổi object về kiểu nguyên thủy, JavaScript sẽ tìm và gọi ba phương thức trong object:
`obj[Symbol.toPrimitive](hint)` `Symbol.toPrimitive` `string` `obj.toString()` `obj.valueOf()` `number` `default` `obj.valueOf()` `obj.toString()`"
66,Chuyển đổi Object về kiểu dữ liệu nguyên thủy trong Javascript,Chi tiết vềSymbol.toPrimitive,"`Symbol.toPrimitive` Symbol.toPrimitivelà một giá trịsymbol mặc định của hệ thốngvà thường được sử dụng như sau:
`Symbol.toPrimitive` 
```js
let obj = {};

obj[Symbol.toPrimitive] = function (hint) {
  // Code trong này dùng để chuyển đổi object về kiểu nguyên thủy.
  // Vì vậy, hàm này phải return về kiểu kiểu nguyên thủy.
  // Giá trị của hint có thể là: string, number hoặc default.
};
```
`let obj = {};

obj[Symbol.toPrimitive] = function (hint) {
  // Code trong này dùng để chuyển đổi object về kiểu nguyên thủy.
  // Vì vậy, hàm này phải return về kiểu kiểu nguyên thủy.
  // Giá trị của hint có thể là: string, number hoặc default.
};` Khi chuyển đổi object về kiểu nguyên thủy, JavaScript kiểm traSymbol.toPrimitiveđầu tiên và gọi phương thứcobj[Symbol.toPrimitive](hint)với ""hint"" là một trong các giá trịstring, number hoặc default, ví dụ:
`Symbol.toPrimitive` `obj[Symbol.toPrimitive](hint)` 
```js
let user = {
  name: ""Alex"",
  age: 28,

  // sử dụng cú pháp rút gọn khai báo phương thức
  [Symbol.toPrimitive](hint) {
    return hint === ""string"" ? `{name: ${this.name}}` : this.age;
  },
};

// hint là string
alert(user); // {name: Alex}

// hint là number
alert(+user); // 28

// hint là default
alert(user + 1); // 29
```
`let user = {
  name: ""Alex"",
  age: 28,

  // sử dụng cú pháp rút gọn khai báo phương thức
  [Symbol.toPrimitive](hint) {
    return hint === ""string"" ? `{name: ${this.name}}` : this.age;
  },
};

// hint là string
alert(user); // {name: Alex}

// hint là number
alert(+user); // 28

// hint là default
alert(user + 1); // 29` Trong ví dụ trên,usercó thể chuyển thành string hoặc number tùy thuộc vào ""hint"". Và tất cả xử lý đều nằm trong phương thứcobj[Symbol.toPrimitive](hint).
`user` `obj[Symbol.toPrimitive](hint)`"
67,Chuyển đổi Object về kiểu dữ liệu nguyên thủy trong Javascript,Chi tiết vềtoStringvàvalueOf,"`toString` `valueOf` Trường hợp object không tồn tại thuộc tínhSymbol.toPrimitivethì JavaScript sẽ tìm đến hai phương thứctoStringvàvalueOf.
`Symbol.toPrimitive` `toString` `valueOf` `string` `toString` `toString` `valueOf` `toString` `number` `default` `valueOf` `valueOf` `toString` `valueOf` toStringvàvalueOflà haiphương thức mặc định, luôn luôn tồn tại khi khởi tạo object, ví dụ:
`toString` `valueOf` 
```js
let obj = {};

console.log(obj.toString()); // [object Object]
console.log(obj.valueOf()); // {}

console.log(obj === obj.valueOf()); // true
```
`let obj = {};

console.log(obj.toString()); // [object Object]
console.log(obj.valueOf()); // {}

console.log(obj === obj.valueOf()); // true` Qua ví dụ trên, bạn thấy rằng:
`toString` `[object Object]` `valueOf` Bây giờ, mình sẽ thử tùy biến hai phương thức này mà không sử dụngSymbol.toPrimitivenữa:
`Symbol.toPrimitive` 
```js
let user = {
  name: ""Alex"",
  age: 28,

  // hint là string
  toString() {
    return `{name: ${this.name}}`;
  },
  // hint là number hoặc default
  valueOf() {
    return this.age;
  },
};

// hint là string
alert(user); // {name: Alex}

// hint là number
alert(+user); // 28

// hint là default
alert(user + 1); // 29
```
`let user = {
  name: ""Alex"",
  age: 28,

  // hint là string
  toString() {
    return `{name: ${this.name}}`;
  },
  // hint là number hoặc default
  valueOf() {
    return this.age;
  },
};

// hint là string
alert(user); // {name: Alex}

// hint là number
alert(+user); // 28

// hint là default
alert(user + 1); // 29` Như bạn thấy là kết quả hoàn toàn giống với cách sử dụngSymbol.toPrimitive.
`Symbol.toPrimitive` 📝Chú ý: hai phương thứctoStringvàvalueOfcó thể trả về bất kỳ kiểu dữ liệu nguyên thủy nào, không nhất thiết phải trả vềnumberhaystring.
`toString` `valueOf` Chỉ cần giá trị trả vềkhác objectlà được.
Ví dụ:

```js
let user = {
  name: ""Alex"",
  age: 28,

  // hint là string
  toString() {
    return true;
  },

  // hint là number hoặc default
  valueOf() {
    return null;
  },
};

// hint là string
alert(user); // true

// hint là number
alert(+user); // 0 - vì +null chuyển thành 0

// hint là default
alert(user + 1); // 1
```
`let user = {
  name: ""Alex"",
  age: 28,

  // hint là string
  toString() {
    return true;
  },

  // hint là number hoặc default
  valueOf() {
    return null;
  },
};

// hint là string
alert(user); // true

// hint là number
alert(+user); // 0 - vì +null chuyển thành 0

// hint là default
alert(user + 1); // 1`"
68,Chuyển đổi Object về kiểu dữ liệu nguyên thủy trong Javascript,Một số vấn đề khác về chuyển đổi kiểu dữ liệu,"Có thể bạn đã biết, nhiều toán tử trong JavaScript thực hiện chuyển đổi kiểu dữ liệu nếu giá trị các toán hạng không phù hợp. Ví dụ toán tử*sẽ chuyển giá trị các toán hạng thànhnumber.
`*` Khi đó, JavaScript sẽ thực hiện hai quá trình:
Ví dụ:

```js
let obj = {
  [Symbol.toPrimitive](hint) {
    return ""3"";
  },
};

console.log(obj * 2); // 6
```
`let obj = {
  [Symbol.toPrimitive](hint) {
    return ""3"";
  },
};

console.log(obj * 2); // 6` Trong ví dụ trên,objsử dụngSymbol.toPrimitiveđể chuyển đổi kiểu dữ liệu về nguyên thủy, và kết quả luôn là string""3""(không phụ thuộc giá trị của ""hint"").
`obj` `Symbol.toPrimitive` `""3""` Theo các bước trên thì:
`obj` `""3""` `""3"" * 2` `3 * 2` `""3""` `3`"
69,Chuyển đổi Object về kiểu dữ liệu nguyên thủy trong Javascript,Tổng kết,"Việc chuyển đổi object về kiểu nguyên thủy được sử dụng với nhiều hàm và toán tử trong JavaScript.
Có ba kiểu ""hint"" là:
`string` `alert` `number` `default` Quy luật chuyển đổi object về kiểu nguyên thủy là:
`obj[Symbol.toPrimitive](hint)` `string` `obj.toString()` `obj.valueOf()` `number` `default` `obj.valueOf()` `obj.toString()` Tham khảo:"
70,Clipboard với exec command,Giới thiệu,"Khi nói đến việc copy dữ liệu vào clipboard thì không thể không kể đến thư việnclipboard.js- với hơn24000 star trên Github, dung lượng sau nén khoảng 3kb, không phụ thuộc vào Flash và bất kỳ một framework nào, thì đây đúng là một thư viện rất đáng để sử dụng. Tuy nhiên, bạn cũng vẫn có thể trực tiếp giao tiếp với clipboard sử dụng execCommand một cách đơn giản.
Thực tế,Document.execCommand()hỗ trợ rất nhiều các command khác nhau như:copy, cut, paste, bold, italic, createLink, fontName, fontSize,...Tuy nhiên, bài viết này mình sẽ chỉ đề cập vào 2 phương thức chính giao tiếp với clipboard là:copy, cut(phương thứcpastehiện tại không support trên web nên mình sẽ không trình bày)."
71,Clipboard với exec command,Ví dụ giao tiếp với clipboard sử dụng execCommand,"Trong ví dụ trên, bạn có thể copy dữ liệu bằng cách nhấn vào buttonCopy Text. Sau đó, nội dung dòng text sẽ được copy vào clipboard. Tiếp theo bạn có thể test bằng cách nhấn tổ hợpCtrl + Vvào bất cứ chỗ nào cho phép gõ text như: phần textarea trong demo, thanh ghi địa chỉ address của trình duyệt, notepad,...
VớiCut Text, bạn cũng có thể làm tương tự để test.
Sau khi đã chạy thử demo xong, dưới đây là phần giải thích chi tiết từng phần."
72,Clipboard với exec command,Copy dữ liệu vào Clipboard,"Nội dung phầnhtml:

```js
<h3>Copy</h3>
<p id=""content-copy"">This text will be inserted into the clipboard.</p>
<button id=""button-copy"">Copy Text</button>
```
`<h3>Copy</h3>
<p id=""content-copy"">This text will be inserted into the clipboard.</p>
<button id=""button-copy"">Copy Text</button>` Trong đó, thẻpvới idcontent-copylà thành phần chứa nội dung mình muốn copy; button với idbutton-copyđể kích hoạt lệnhcopykhi người dùng click vào.
Chú ý
bạn có thể copy dữ liệu từ hầu hết các phần tử như:thẻ p, span, div, input, textarea,...Nhưng trong ví dụ này, mình chỉ demo với thẻp.
Tiếp theo, mình dùngquerySelectorđể lưu lạiDOM nodecủa các phần tử:

```js
const $ = document.querySelector.bind(document);
const contentCopyElm = $(""#content-copy""),
  buttonCopyElm = $(""#button-copy"");
```
`const $ = document.querySelector.bind(document);
const contentCopyElm = $(""#content-copy""),
  buttonCopyElm = $(""#button-copy"");` Sau đó, định nghĩa mộthàm sốđể kiểm tra xem command mình sử dụng có được support hay không, thông qua phương thứcdocument.queryCommandSupported():

```js
const isSupported = (cmd) => {
  return document.queryCommandSupported(cmd);
};
```
`const isSupported = (cmd) => {
  return document.queryCommandSupported(cmd);
};` Cuối cùng, xử lý khi người dùng click vào buttonCopy Text:

```js
buttonCopyElm.addEventListener(""click"", () => {
  // Khai báo đối tượng range và selection.
  const range = document.createRange(),
    selection = window.getSelection();

  // Xoá bỏ các vùng chọn hiện tại
  selection.removeAllRanges();

  // Mô phỏng việc select - bôi đen nội dung của phần tử contentCopyElm
  range.selectNodeContents(contentCopyElm);

  // Thêm range trên vào selection
  selection.addRange(range);

  // Thử lệnh copy
  try {
    if (isSupported(""copy"")) document.execCommand(""copy"");
    else alert(`execCommand(""copy"") is not supported in your browser.`);
  } catch (e) {
    console.log(e);
  }

  // Sau khi copy dữ liệu xong thì xoá bỏ các vùng chọn hiện tại
  selection.removeAllRanges();
});
```
`buttonCopyElm.addEventListener(""click"", () => {
  // Khai báo đối tượng range và selection.
  const range = document.createRange(),
    selection = window.getSelection();

  // Xoá bỏ các vùng chọn hiện tại
  selection.removeAllRanges();

  // Mô phỏng việc select - bôi đen nội dung của phần tử contentCopyElm
  range.selectNodeContents(contentCopyElm);

  // Thêm range trên vào selection
  selection.addRange(range);

  // Thử lệnh copy
  try {
    if (isSupported(""copy"")) document.execCommand(""copy"");
    else alert(`execCommand(""copy"") is not supported in your browser.`);
  } catch (e) {
    console.log(e);
  }

  // Sau khi copy dữ liệu xong thì xoá bỏ các vùng chọn hiện tại
  selection.removeAllRanges();
});`"
73,Clipboard với exec command,Cut dữ liệu vào Clipboard,"Khác vớicopy(có thể copy dữ liệu trong nhiều loại phần tử khác nhau),cutchỉ cho phép bạn thực hiện trên các phần tử như:input (text), textarea,.... Vì vậy, trong phần này mình sẽ demo với thẻinput.
Nội dung phầnhtml:

```js
<h3>Cut</h3>
<input
  id=""content-cut""
  type=""text""
  value=""This text will be cut, then inserted into the clipboard.""
/>
<button id=""button-cut"">Cut Text</button>
```
`<h3>Cut</h3>
<input
  id=""content-cut""
  type=""text""
  value=""This text will be cut, then inserted into the clipboard.""
/>
<button id=""button-cut"">Cut Text</button>` Tiếp theo là phần xử lý trongjskhi người dùng click vào buttonCut Text:

```js
buttonCutElm.addEventListener(""click"", () => {
  // Tạo select nội dung của input
  inputCutElm.select();

  // Thử cut nội dung của input
  try {
    if (isSupported(""cut"")) document.execCommand(""cut"");
    else alert(`execCommand(""cut"") is not supported in your browser.`);
  } catch (e) {
    console.log(e);
  }
});
```
`buttonCutElm.addEventListener(""click"", () => {
  // Tạo select nội dung của input
  inputCutElm.select();

  // Thử cut nội dung của input
  try {
    if (isSupported(""cut"")) document.execCommand(""cut"");
    else alert(`execCommand(""cut"") is not supported in your browser.`);
  } catch (e) {
    console.log(e);
  }
});` Cách tạo vùng chọn trong phần này dễ hơn so với phần trước vì đối tượng DOM node ứng vớiinputđã hỗ trợ sẵn phương thứcselect()."
74,Clipboard với exec command,Demo một số chức năng khác với execCommand,"Như mình đã nói ở trên,document.execCommand()cho phép bạn thực hiện rất nhiều command khác ngoàicopy, cut.
`document.execCommand()` Dưới đây là một demo đơn giản sử dụngdocument.execCommand()để chỉnh sửa nội dung - tương tự như mộtText Editor:
`document.execCommand()` https://codepen.io/completejavascript/pen/ZmKKwW
Trong ví dụ trên, bạn có thể thử bôi đen text, sau đó nhấn vào các button để test các chức năng của nó. Dĩ nhiên, các chức năng mình lấy ra làm ví dụ vẫn chưa đầy đủ hết so với khả năng hỗ trợ củadocument.execCommand(). Nhưng nó cũng phần nào giúp bạn thấy được khả năng của phương thức này.
`document.execCommand()`"
75,Clipboard với exec command,Lời kết,"Trên đây là cách giao tiếp với clipboard sử dụng execCommand. Hy vọng bài viết này hữu ích với bạn. Và nếu có gì thắc mắc hoặc góp ý thì bạn có thể để lại bình luận xuống phía dưới. Mình sẽ cố gắng giải đáp.
Xem thêm:"
76,Closure trong Javascript,Giới thiệu,Closure trong JS là một trong nhữngkhái niệm quan trọng. Việc nắm chắc JavaScript closure là gì và cách sử dụng closure trong JavaScript giúp bạn viết code tốt hơn.
77,Closure trong Javascript,JavaScript closure là gì?,"JavaScript closure là tập hợp bao gồm một hàm vàmôi trườngnơi hàm đó được khai báo, gọi làlexical environment.
Trong đó,lexical environmentđược hiểu là tất cả những biến cục bộ trong hàm và trạng thái của các biến ở phạm vi ngoài hàm.
Closure trong JS có thể truy cậpbiếnở3 phạm vikhác nhau là:
Ví dụ về các phạm vi biến:

```js
// biến global
let YEAR = ""2021"";

function greet(name) {
  // biến local trong hàm greet
  // đồng thời là biến ngoài hàm sayHello
  let intro = ""Hello"";

  function sayHello() {
    // biến local của hàm sayHello
    let message = `${intro} ${name} in ${YEAR}`;
    console.log(message);
  }

  sayHello();
}

greet(""Dev"");
// Hello Dev in 2021
```
`// biến global
let YEAR = ""2021"";

function greet(name) {
  // biến local trong hàm greet
  // đồng thời là biến ngoài hàm sayHello
  let intro = ""Hello"";

  function sayHello() {
    // biến local của hàm sayHello
    let message = `${intro} ${name} in ${YEAR}`;
    console.log(message);
  }

  sayHello();
}

greet(""Dev"");
// Hello Dev in 2021` Để hiểu hơn về phạm vi của biến, sau đây mình sẽ tìm hiểu về khái niệm ""khối code"" hay tiếng anh làcode block.
Lưu ý
Các ví dụ sau đây chỉ áp dụng cho cách khai báo biến vớilet/const. Cách khai báo biến vớivarđã lỗi thời vàvarcó logic riêng.
`let/const` `var` `var`"
78,Closure trong Javascript,Code block là gì?,"Nếu một biến được khai báobên trong một code block{...}thì biến ""chỉ được nhìn thấy"" ở khối code đó.
`{...}` Ví dụ về code block:

```js
// sau đây là một khối code
{
  let message = ""Hi""; // biến message chỉ được nhìn thấy ở trong block
  console.log(message); // Hi
}

console.log(message); // Error: message is not defined
```
`// sau đây là một khối code
{
  let message = ""Hi""; // biến message chỉ được nhìn thấy ở trong block
  console.log(message); // Hi
}

console.log(message); // Error: message is not defined` Bạn có thể ứng dụng code block để tạo ra các đoạn code riêng biệt mà không sợ bịxung đột về tên biến.

```js
// block 1
{
  let message = ""Hi"";
  console.log(message); // Hi
}

// block 2
{
  let message = ""Hello"";
  console.log(message); // Hello
}
```
`// block 1
{
  let message = ""Hi"";
  console.log(message); // Hi
}

// block 2
{
  let message = ""Hello"";
  console.log(message); // Hello
}` Nếu không có code block thì sẽ xảy ra lỗi ""biến đã được khai báo"":

```js
let message = ""Hi"";
console.log(message); // Hi

let message = ""Hello"";
// Uncaught SyntaxError: Identifier 'message' has already been declared
```
`let message = ""Hi"";
console.log(message); // Hi

let message = ""Hello"";
// Uncaught SyntaxError: Identifier 'message' has already been declared` Ví dụ vềif,for,while,... các biến được khai báo bên trong{...}cũng chỉ được nhìn thấy bên trong:
`if` `for` `while` `{...}` 
```js
if (true) {
  let message = ""hello"";
  console.log(message); // hello
}

console.log(message); // Uncaught ReferenceError: message is not defined
```
`if (true) {
  let message = ""hello"";
  console.log(message); // hello
}

console.log(message); // Uncaught ReferenceError: message is not defined` Saucâu lệnh rẽ nhánhif, biếnmessagekhông được nhìn thấy, nên đã có lỗi ""message is not defined"".
`if` `message` Tương tự vớivòng lặpfor:
`for` 
```js
for (let i = 0; i < 3; i++) {
  // biến i chỉ được nhìn thấy bên trong for
  console.log(i); // 0, 1, 2
}

console.log(i); // Uncaught ReferenceError: i is not defined
```
`for (let i = 0; i < 3; i++) {
  // biến i chỉ được nhìn thấy bên trong for
  console.log(i); // 0, 1, 2
}

console.log(i); // Uncaught ReferenceError: i is not defined` Trong ví dụ trên, bạn đấylet ikhông nằm trong{...}. Tuy nhiên, vòng lặpforlà một cú pháp đặc biệt.
`let i` `{...}` `for` Biến được khai báo bên trongfor(...)là biến cục bộ bên trong code block{...}củafor.
`for(...)` `{...}` `for`"
79,Closure trong Javascript,Hàm lồng nhau,"Hàm lồng nhau được hiểu làmột hàm được khai báo bên trong hàm khác, tiếng anh lànested function, ví dụ:

```js
function sayHiBye(firstName, lastName) {
  // getFullName là nested function
  function getFullName() {
    return `${firstName} ${lastName}`;
  }

  console.log(""Hello, "" + getFullName());
  console.log(""Bye, "" + getFullName());
}
```
`function sayHiBye(firstName, lastName) {
  // getFullName là nested function
  function getFullName() {
    return `${firstName} ${lastName}`;
  }

  console.log(""Hello, "" + getFullName());
  console.log(""Bye, "" + getFullName());
}` Trong ví dụ trên, hàmgetFullNamelà một nested function được khai báo bên trong hàmsayHiBye.
`getFullName` `sayHiBye` HàmgetFullNamecó thể truy cập tới biến ngoài hàmfirstName,lastNamevà trả về giá trị ""fullName"".
`getFullName` `firstName` `lastName` Điều đặc biệt ở đây là bạn có thể ""return"" về nested function. Sau đó, bạn có thểsử dụng hàm trả về ở bất kỳ đâumà vẫn có thể truy cập được vào biến ngoài hàm (outer function) một cách giống nhau.
Ví dụ hàmmakeCountertrả về giá trịcounttiếp theo sau mỗi lần gọi:
`makeCounter` `count` 
```js
function makeCounter() {
  // ban đầu counter bằng 0
  let count = 0;

  // trả về một hàm khác
  // hàm này return về counter rồi tăng biến counter lên 1 đơn vị
  return function () {
    return count++;
  };
}

// sử dụng -> counter chính là nested function
let counter1 = makeCounter();

// sau mỗi lần gọi hàm counter1() thì giá trị count tăng lên 1
console.log(counter1()); // 0
console.log(counter1()); // 1
console.log(counter1()); // 2

// tạo counter2, giá trị count độc lập với counter1
let counter2 = makeCounter();

// khi gọi counter2(), giá trị count vẫn bắt đầu từ 0, chứ không phải 2
console.log(counter2()); // 0
console.log(counter2()); // 1
console.log(counter2()); // 2
```
`function makeCounter() {
  // ban đầu counter bằng 0
  let count = 0;

  // trả về một hàm khác
  // hàm này return về counter rồi tăng biến counter lên 1 đơn vị
  return function () {
    return count++;
  };
}

// sử dụng -> counter chính là nested function
let counter1 = makeCounter();

// sau mỗi lần gọi hàm counter1() thì giá trị count tăng lên 1
console.log(counter1()); // 0
console.log(counter1()); // 1
console.log(counter1()); // 2

// tạo counter2, giá trị count độc lập với counter1
let counter2 = makeCounter();

// khi gọi counter2(), giá trị count vẫn bắt đầu từ 0, chứ không phải 2
console.log(counter2()); // 0
console.log(counter2()); // 1
console.log(counter2()); // 2`"
80,Closure trong Javascript,Đặc điểm của closure trong JS,"Nếu bạn muốn hiểu sâu và vận dụng được JavaScript closure thì sau đây là những đặc điểm quan trọng mà bạn cần nắm vững.
►Hàm closures có thể truy cập tới biến của hàm chứa nó, dù cho hàm đó đã return
Thông thường, khi một hàm đãreturnthì biến cục bộ trong hàm đó cũng được giải phóng.
Nhưng với closure trong JS thì khác, bạn vẫn có thể truy cập đến những biến cục bộ đó ngay cả khi outer function đã thực hiện xong.

```js
function adder(n) {
  let intro = ""This answer is "";
  let local = n;

  return function (number) {
    let result = number + local;
    console.log(intro + result);
  };
}

let adder2 = adder(2);
adder2(10);
// This answer is 12
```
`function adder(n) {
  let intro = ""This answer is "";
  let local = n;

  return function (number) {
    let result = number + local;
    console.log(intro + result);
  };
}

let adder2 = adder(2);
adder2(10);
// This answer is 12` Trong ví dụ trên, hàm closures là một hàm không tênfunction(number). Hàm closures này sử dụng biến cục bộ của outer function làintrovàlocal.
`function(number)` `intro` `local` Khi mình gọi hàmadder(2), hàm này thực hiện và kết quả trả về được gán vào biếnadder2. Nói cách khác,adder2chứanested functionđược trả về từ việc gọi hàmadder(2).
`adder(2)` `adder2` `adder2` `adder(2)` Sau đó, mình gọiadder2(10)và kết quả trả về là12.
`adder2(10)` `12` Chứng tỏ, hàm closures vẫn có thể truy cập tới biến cục bộ của outer function làintro,localngay cả khi hàm outeradder2đã thực hiện xong.
`intro` `local` `adder2` ►Hàm closures lưu trữ biến của outer function theo kiểu tham chiếu
Xét ví dụ dưới đây:

```js
function ObjId() {
  let id = 1;

  return {
    getId: function () {
      return id;
    },
    setId: function (_id) {
      id = _id;
    },
  };
}

let myObject = ObjId();
console.log(myObject.getId()); // 1

myObject.setId(10);
console.log(myObject.getId()); // 10
```
`function ObjId() {
  let id = 1;

  return {
    getId: function () {
      return id;
    },
    setId: function (_id) {
      id = _id;
    },
  };
}

let myObject = ObjId();
console.log(myObject.getId()); // 1

myObject.setId(10);
console.log(myObject.getId()); // 10` Hàm khởi tạoObjIdtrả về một đối tượng bao gồm 2 hàm closures làgetIdvàsetId. Các hàm closures này sử dụng chung một biến cục bộ làid.
`ObjId` `getId` `setId` `id` Ban đầu, mình gọimyObject.getId()thì kết quả trả về là1(giá trị của biến cục bộ). Sau đó, mình gọimyObject.setId(10)để cập nhật giá trị củaid.
`myObject.getId()` `1` `myObject.setId(10)` `id` Nếu closure trong JS chỉlưu biến cục bộ theo giá trịthì suy ra giá trị của biến cục bộidsẽ không thay đổi. Nhưng khi mình gọi tiếpmyObject.getId()thì giá trị trả về là10.
`id` `myObject.getId()` `10` Chứng tỏ, hàm closures phảilưu biến cục bộ theo kiểu tham chiếu."
81,Closure trong Javascript,Thực hành,"Cho đoạn code sau:

```js
let name = ""Alex"";

function sayHi() {
  console.log(""Hi, "" + name);
}

name = ""Anna"";

sayHi();
```
`let name = ""Alex"";

function sayHi() {
  console.log(""Hi, "" + name);
}

name = ""Anna"";

sayHi();` Hỏi kết quả khi gọisayHi()là ""Alex"" hay ""Anna""?
`sayHi()` Xem đáp án
Kết quả
Anna
Biếnnamelà biến toàn cục. Khi hàmsayHiđược gọi, giá trị củanamelà giá trị mới nhất.
`name` `sayHi` `name` Cho đoạn code sau:

```js
function makeWorker() {
  let name = ""Alex"";

  return function () {
    console.log(name);
  };
}

let name = ""Anna"";

// tạo một function mới
let work = makeWorker();

// gọi hàm
work();
```
`function makeWorker() {
  let name = ""Alex"";

  return function () {
    console.log(name);
  };
}

let name = ""Anna"";

// tạo một function mới
let work = makeWorker();

// gọi hàm
work();` Hỏi kết quả củaworker()là ""Alex"" hay ""Anna""?
`worker()` Xem đáp án
Kết quả
Alex
Nested function bên trong hàmmakeWorkertruy cập tới biến ngoài hàm làname = ""Alex"".
`makeWorker` `name = ""Alex""` Dù sau đó, mình có khai báo biến toàn cụclet name = ""Anna""thì biếnnamenày ở phạm vi khác với biếnnametrong hàm closure.
`let name = ""Anna""` `name` `name` Cho đoạn code sau:

```js
""use strict"";

let message = ""Hello"";

if (true) {
  let user = ""Alex"";

  function sayHi() {
    console.log(`${message}, ${user}`);
  }
}

sayHi();
```
`""use strict"";

let message = ""Hello"";

if (true) {
  let user = ""Alex"";

  function sayHi() {
    console.log(`${message}, ${user}`);
  }
}

sayHi();` Kết quả sau khi gọisayHi()là gì?
`sayHi()` Xem đáp án
Kết quả
Uncaught ReferenceError: sayHi is not defined
HàmsayHiđược khai báo trongif, nên chỉ được nhìn thấy trong block code củaif.
`sayHi` `if` `if` Viết hàmsum(a)(b)trả về tổnga + b, ví dụ:
`sum(a)(b)` `a + b` 
```js
sum(1)(2) = 3
sum(2)(-1) = 1
```
`sum(1)(2) = 3
sum(2)(-1) = 1` Xem đáp án
Để gọi hàm được theo cáchsum(a)(b)thì phải sử dụng closure trong JS:
`sum(a)(b)` 
```js
function sum(a) {
  return function (b) {
    return a + b;
  };
}

console.log(sum(1)(2)); // 3
console.log(sum(2)(-1)); // 1
```
`function sum(a) {
  return function (b) {
    return a + b;
  };
}

console.log(sum(1)(2)); // 3
console.log(sum(2)(-1)); // 1` Cho đoạn code sau:

```js
let x = 1;

function func() {
  console.log(x); // (*)
  let x = 2;
}

func();
```
`let x = 1;

function func() {
  console.log(x); // (*)
  let x = 2;
}

func();` Kết quả(*)là gì?
`(*)` Xem đáp án
Kết quả
Uncaught ReferenceError: Cannot access 'x' before initialization
Vì trong hàm cólet x = 2, nghĩa là biếnxcó tồn tại trong phạm vi của hàmfunc. Nhưng bạn không thể truy cập đến biếnxtrước câu lệnhlet x.
`let x = 2` `x` `func` `x` `let x` Trường hợp trong hàmfunckhông cólet x = 2thì giá trị củaxlà giá trị của biếnxbên ngoài hàm.
`func` `let x = 2` `x` `x` Cho mảnguserssau:
`users` 
```js
let users = [
  { name: ""Alex"", age: 28 },
  { name: ""Pete"", age: 20 },
  { name: ""Ann"", age: 24 },
];
```
`let users = [
  { name: ""Alex"", age: 28 },
  { name: ""Pete"", age: 20 },
  { name: ""Ann"", age: 24 },
];` Ví dụ sắp xếp mảng theonamevàage:
`name` `age` 
```js
// theo `name` (Alex, Ann, Pete)
users.sort((a, b) => (a.name > b.name ? 1 : -1));

// theo `age` (Pete, Ann, Alex)
users.sort((a, b) => (a.age > b.age ? 1 : -1));
```
`// theo `name` (Alex, Ann, Pete)
users.sort((a, b) => (a.name > b.name ? 1 : -1));

// theo `age` (Pete, Ann, Alex)
users.sort((a, b) => (a.age > b.age ? 1 : -1));` Thay vì phải viết code lặp lại như trên, hãy viết hàmbyField(fieldName)để có thể sử dụng vớisortnhư sau:
`byField(fieldName)` `sort` 
```js
users.sort(byField(""name""));
users.sort(byField(""age""));
```
`users.sort(byField(""name""));
users.sort(byField(""age""));` Xem đáp án
Để viết hàmbyField, bạn có thể sử dụng closure trong JS để trả về nested function ứng với mỗifieldNamenhư sau:
`byField` `fieldName` 
```js
function byField(fieldName) {
  return (a, b) => (a[fieldName] > b[fieldName] ? 1 : -1);
}
```
`function byField(fieldName) {
  return (a, b) => (a[fieldName] > b[fieldName] ? 1 : -1);
}`"
82,Constructor pattern trong JavaScript,Giới thiệu,"Đối với lập trình hướng đối tượng trong JavaScript, cách đơn giản nhất để tạo mới một object là sử dụng function kết hợp với từ khoánew. Bên trong hàm khởi tạo này, từ khoáthisdùng để chỉ tới đối tượng mới. Thông thường, hàm khởi tạo được viết hoa chữ cái đầu tiên, dùng để phân biệt với cáchàm sốthông thường. Sau đây, chúng ta sẽ cùng nhau tìm hiểu về một vài Constructor Pattern trong JavaScript."
83,Constructor pattern trong JavaScript,Constructor Pattern cơ bản,"```js
function Animal(name, leg) {
  this.name = name;
  this.leg = leg;
  this.about = function () {
    return this.name + "" has "" + this.leg + "" legs"";
  };
}

// Usage:
var dog = new Animal(""Dog"", 4);
var bird = new Animal(""Bird"", 2);
console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs
```
`function Animal(name, leg) {
  this.name = name;
  this.leg = leg;
  this.about = function () {
    return this.name + "" has "" + this.leg + "" legs"";
  };
}

// Usage:
var dog = new Animal(""Dog"", 4);
var bird = new Animal(""Bird"", 2);
console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs` Trong ví dụ trên,đối tượngsử dụng hàm khởi tạoAnimalsẽ có 2 thuộc tính (name,leg) và 1 phương thức (about). Tuy nhiên, cách trên có nhược điểm là khó để kế thừa và phương thứcaboutsẽ phải định nghĩa lại đối với mỗi đối tượng. Để khắc phục nhược điểm trên, ta có cách thứ hai là sử dụngPrototypes."
84,Constructor pattern trong JavaScript,Constructor Pattern với Prototypes,"Trong JavaScript, mọi object (bao gồmfunction) đều tồn tại thuộc tínhprototype- cũng là một object. Khi sử dụng hàm khởi tạo để tạo mới một object, mọi thuộc tính trongprototypeđều được kế thừa cho các đối tượng mới.

```js
function Animal(name, leg) {
  this.name = name;
  this.leg = leg;
}
Animal.prototype.about = function () {
  return this.name + "" has "" + this.leg + "" legs"";
};

// Usage:
var dog = new Animal(""Dog"", 4);
var bird = new Animal(""Bird"", 2);
console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs
```
`function Animal(name, leg) {
  this.name = name;
  this.leg = leg;
}
Animal.prototype.about = function () {
  return this.name + "" has "" + this.leg + "" legs"";
};

// Usage:
var dog = new Animal(""Dog"", 4);
var bird = new Animal(""Bird"", 2);
console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs`"
85,Constructor pattern trong JavaScript,Constructor Pattern với từ khoá class,"Từ khoáclassthực chất là một hàm số đặc biệt. Sử dụngclasscho phép khởi tạo đối tượng mới một cách trực quan, và gần với khái niệmclasstrong các ngôn ngữ lập trình khác như C++, Java,...
Một điểm khác giữaclassvàfunctionlàfunctionthuộc dạnghoisting, cònclassthì không. Nghĩa là bạn có thể sử dụng hàm số trước khi khai báo hàm. Trong khi nếu bạn sử dụng class trước khi khai báo class thì bạn sẽ nhận đượcthông báo lỗiReferenceError.

```js
class Animal {
  constructor(name, leg) {
    this.name = name;
    this.leg = leg;
  }

  about() {
    return this.name + "" has "" + this.leg + "" legs"";
  }
}

// Usage:
var dog = new Animal(""Dog"", 4);
var bird = new Animal(""Bird"", 2);
console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs
```
`class Animal {
  constructor(name, leg) {
    this.name = name;
    this.leg = leg;
  }

  about() {
    return this.name + "" has "" + this.leg + "" legs"";
  }
}

// Usage:
var dog = new Animal(""Dog"", 4);
var bird = new Animal(""Bird"", 2);
console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs` Trong class, có một hàm duy nhất và đặc biệt làconstructor, đây là hàm khởi tạo của class. Trong hàm này bạn có thể định nghĩa các thuộc tính (name,leg) giống như sử dụng function và phương thức (about). Ngoài ra, bạn có thể định nghĩa cácgetter,settervà các hàmstatic.
Trên đây là một số Constructor Pattern cơ bản. Tiếp theo, mình sẽ giới thiệu với các bạn về Module Pattern."
86,Copy Object trong Javascript,Giới thiệu,"Trong bài viếtso sánh 2 object trong JavaScript, bạn biết rằng object có kiểu dữ liệu tham chiếu. Vì vậy, copy object trong JavaScript thực chất làcopy địa chỉ.

```js
let p1 = { x: 1, y: 2 };
let p2 = p1;

p2.x = 5;
console.log(p2.x); // 5
console.log(p1.x); // 5
```
`let p1 = { x: 1, y: 2 };
let p2 = p1;

p2.x = 5;
console.log(p2.x); // 5
console.log(p1.x); // 5` Trong ví dụ trên, hai biếnp2vàp1đang cùng tham chiếu đến một địa chỉ. Khi bạn thay đổi giá trị thuộc tính củap2thìp1cũng thay đổi theo.
`p2` `p1` `p2` `p1` Nếu bạn muốn copy object thành hai đối tượng độc lập nhau thì làm thế nào?
Sau đây là một số cách để copy object thành hai đối tượng độc lập:
`for...in` `Object.assign()` `JSON.stringify()` `JSON.parse()`"
87,Copy Object trong Javascript,Copy object sử dụng vòng lặpfor...in,"`for...in` Cách đơn giản nhất để copy object trong JavaScript là sử dụng vòng lặpfor...inđể duyệt tất cả các thuộc tính của object. Rồi lấy giá trị ứng với từng thuộc tính để gán cho object mới.
`for...in` Ví dụ copy object bằngfor...in:
`for...in` 
```js
let p1 = { x: 1, y: 2 };

let p2 = {};
for (let key in p1) {
  p2[key] = p1[key];
}
console.log(p2.x); // 1
console.log(p2.y); // 2

p2.x = 5;
console.log(p2.x); // 5
console.log(p1.x); // 1
```
`let p1 = { x: 1, y: 2 };

let p2 = {};
for (let key in p1) {
  p2[key] = p1[key];
}
console.log(p2.x); // 1
console.log(p2.y); // 2

p2.x = 5;
console.log(p2.x); // 5
console.log(p1.x); // 1` Bạn thấy rằng, giá trị các thuộc tínhxvàycủap2hoàn toàn giốngp1. Nhưng khi thay đổi giá trịp2.x = 5thì giá trịp1.xvẫn không thay đổi.
`x` `y` `p2` `p1` `p2.x = 5` `p1.x` Ngoài cách sử dụng vòng lặpfor...innhư trên, bạn có thể dùng hàm tương tự làObject.assign()với cú pháp:
`for...in` `Object.assign()` 
```js
Object.assign(dest, [src1, src2, src3...]);
```
`Object.assign(dest, [src1, src2, src3...]);` Trong đó:
`dest` `[src1, src2, src3...]` Phương thức trên sẽ copy toàn bộ các thuộc tính của các object nguồnsrc1, src2,...,srcNvào object đíchdest. Và giá trị trả về chính là object đíchdest.
`src1, src2,...,srcN` `dest` `dest` Ví dụ sử dụngObject.assign:
`Object.assign` 
```js
let user = { name: ""Alex"" };
let permission1 = { canView: true };
let permission2 = { canEdit: false };

// copy toàn bộ thuộc tính từ permission1 và permission2 vào user
Object.assign(user, permission1, permission2);
// user trở thành { name: ""Alex"", canView: true, canEdit: false }
for (let key in user) {
  console.log(key, "":"", user[key]);
}

// name : Alex
// canView: true
// canEdit: false
```
`let user = { name: ""Alex"" };
let permission1 = { canView: true };
let permission2 = { canEdit: false };

// copy toàn bộ thuộc tính từ permission1 và permission2 vào user
Object.assign(user, permission1, permission2);
// user trở thành { name: ""Alex"", canView: true, canEdit: false }
for (let key in user) {
  console.log(key, "":"", user[key]);
}

// name : Alex
// canView: true
// canEdit: false` Nếutên thuộc tính giống nhauthì kết quả là giá trị của object cuối cùng:

```js
let user = { name: ""Alex"" };
let permission1 = { canView: true };
let permission2 = { canView: false, canEdit: false };
// copy toàn bộ thuộc tính từ permission1 và permission2 vào user
Object.assign(user, permission1, permission2);

// user trở thành { name: ""Alex"", canView: false, canEdit: false }
for (let key in user) {
  console.log(key, "":"", user[key]);
}

// name : Alex
// canView: false
// canEdit: false
```
`let user = { name: ""Alex"" };
let permission1 = { canView: true };
let permission2 = { canView: false, canEdit: false };
// copy toàn bộ thuộc tính từ permission1 và permission2 vào user
Object.assign(user, permission1, permission2);

// user trở thành { name: ""Alex"", canView: false, canEdit: false }
for (let key in user) {
  console.log(key, "":"", user[key]);
}

// name : Alex
// canView: false
// canEdit: false` Trong ví dụ trên, thuộc tínhcanViewđều có ởpermission1vàpermission2nên kết quả cuối cùng là giá trị ứng với objectpermission2.
`canView` `permission1` `permission2` `permission2` Để thay thế ví dụ với vòng lặpfor...inphần trước, bạn có áp dụngObject.assignnhư sau:
`for...in` `Object.assign` 
```js
let p1 = { x: 1, y: 2 };
let p2 = {};

Object.assign(p2, p1);
```
`let p1 = { x: 1, y: 2 };
let p2 = {};

Object.assign(p2, p1);`"
88,Copy Object trong Javascript,Tại sao gọi là copy nông?,"Tương tự nhưso sánh nông,copy nôngchỉ thực hiện sao chép trên một cấp độ. Nếu giá trị của thuộc tính trong objectcũng là một objectthì object copy sẽ không hoàn toàn độc lập với object nguồn.
Ví dụ:

```js
let point1 = { x: 1, y: 2, metadata: { type: ""point"" } };

let point2 = {};

Object.assign(point2, point1);
console.log(point2.metadata.type); // point

point2.metadata.type = ""CHANGED"";
console.log(point2.metadata.type); // CHANGEDconsole.log(point1.metadata.type); // CHANGED
```
`let point1 = { x: 1, y: 2, metadata: { type: ""point"" } };

let point2 = {};

Object.assign(point2, point1);
console.log(point2.metadata.type); // point

point2.metadata.type = ""CHANGED"";
console.log(point2.metadata.type); // CHANGEDconsole.log(point1.metadata.type); // CHANGED` Trong ví dụ trên, giá trị ứng vớimetadatalà một object. Với copy nông, hai biếnpoint2vàpoint1vẫn đang dùng chung bộ nhớ đối vớimetadata.
`metadata` `point2` `point1` `metadata` Vì vậy, khi thay đổi ởpoint2thìpoint1cũng thay đổi theo.
`point2` `point1` Lưu ý
📝 Ngoài cách trên để copy nông, bạn cũng có thể dùng cú pháp spread(...)như sau:
`(...)` 
```js
let p1 = { x: 1, y: 2 };
let p2 = { ...p1 };
```
`let p1 = { x: 1, y: 2 };
let p2 = { ...p1 };`"
89,Copy Object trong Javascript,Sử dụng Spread,"Cú pháp spread(...)có nhiều điều để nói và được áp dụng ở nhiều trường hợp nên mình sẽ trình bày ở bài viết sau.
`(...)` Khi object bao gồm nhiều đối tượng lồng nhau, bạn cần copy sâu (deep copy) để có thể tạo ra đối tượng độc lập.
Lấy lại ví dụ ở trên:

```js
let point1 = {
  x: 1,
  y: 2,
  metadata: { type: ""point"" },
};
```
`let point1 = {
  x: 1,
  y: 2,
  metadata: { type: ""point"" },
};` Trong ví dụ này, giá trị của thuộc tínhmetadatakhông phải giá trị nguyên thủy mà là một object.
`metadata` Để thực hiện copy sâu, bạn có thể dùng hàmJSON.stringify()để chuyển object về dạng JSON. Rồi sau đó, bạn dùng hàmJSON.parse()để tạo lại một object mới từ JSON.
`JSON.stringify()` `JSON.parse()` 
```js
let point1 = {
  x: 1,
  y: 2,
  metadata: {
    type: ""point"",
  },
};

// chuyển object về dạng JSON
let jsonPoint1 = JSON.stringify(point1);
console.log(jsonPoint1); // {""x"":1,""y"":2,""metadata"":{""type"":""point""}}

// parse JSON lại thành object mới
let point2 = JSON.parse(jsonPoint1);
console.log(point2.metadata.type); // point

point2.metadata.type = ""CHANGED"";
console.log(point2.metadata.type); // CHANGED
console.log(point1.metadata.type); // point
```
`let point1 = {
  x: 1,
  y: 2,
  metadata: {
    type: ""point"",
  },
};

// chuyển object về dạng JSON
let jsonPoint1 = JSON.stringify(point1);
console.log(jsonPoint1); // {""x"":1,""y"":2,""metadata"":{""type"":""point""}}

// parse JSON lại thành object mới
let point2 = JSON.parse(jsonPoint1);
console.log(point2.metadata.type); // point

point2.metadata.type = ""CHANGED"";
console.log(point2.metadata.type); // CHANGED
console.log(point1.metadata.type); // point` Bạn thấy là khi thay đổi giá trị củametadatatrongpoint2thì giá trị tương ứng trongpoint1vẫn không thay đổi. Chứng tỏpoint2hoàn toàn độc lập vớipoint1.
`metadata` `point2` `point1` `point2` `point1` Đó chính làcopy sâu.
Giới hạn củaJSON.stringifyvàJSON.parse
`JSON.stringify` `JSON.parse` HàmJSON.stringifycó giới hạn là nó sẽ bỏ qua thuộc tính mà giá trị của nó làhàm(mặc dù về bản chất hàm cũng là object).
`JSON.stringify` Ví dụ giá trị của thuộc tính là hàm:

```js
let point1 = {
  x: 1,
  y: 2,
  getDisplayName: function () {
    return ""(x: "" + x + "", y: "" + y + "")"";
  },
};

// chuyển object về dạng JSON
let jsonPoint1 = JSON.stringify(point1);
console.log(jsonPoint1); // {""x"":1,""y"":2}

// parse JSON lại thành object mới
let point2 = JSON.parse(jsonPoint1);
console.log(point2.getDisplayName); // undefined
```
`let point1 = {
  x: 1,
  y: 2,
  getDisplayName: function () {
    return ""(x: "" + x + "", y: "" + y + "")"";
  },
};

// chuyển object về dạng JSON
let jsonPoint1 = JSON.stringify(point1);
console.log(jsonPoint1); // {""x"":1,""y"":2}

// parse JSON lại thành object mới
let point2 = JSON.parse(jsonPoint1);
console.log(point2.getDisplayName); // undefined` Bạn thấy rằng,JSON.stringify(point1)đã bỏ qua thuộc tínhgetDisplayName. Vì vậy, khi dùngJSON.parse(jsonPoint1)để tạo ra objectpoint2thì objectpoint2không cógetDisplayName.
`JSON.stringify(point1)` `getDisplayName` `JSON.parse(jsonPoint1)` `point2` `point2` `getDisplayName` Hay nói các khác là giá trịpoint2.getDisplayNamebằngundefined.
`point2.getDisplayName` `undefined` 💡 Để giải quyết vấn đề này, bạn cần xử lý thêm nhiều trường hợp nữa (nằm ngoài phạm vi bài viết này).
Hoặc bạn có thể sử dụng hàm thư viện_.cloneDeep(value)để giải quyết bài toán nhanh hơn.
`_.cloneDeep(value)`"
90,Copy Object trong Javascript,Tổng kết,"Vì object là kiểu dữ liệu tham chiếu nên việc copy object trong JavaScript thực chất là copy địa chỉ.
Một số cách để copy object thành đối tượng độc lập:
`for...in` `Object.assign` `(...)` `JSON.stringify` `JSON.parse` `_.cloneDeep(value)`"
91,Cú pháp cơ bản của class trong Javascript,Giới thiệu,"Khi lập trình, chúng ta thường sẽ phải tạo ra nhiềuobjectvới cùng kiểu, ví dụ như: các đối tượng người dùng hay các đối tượng sản phẩm,...
Để giải quyết vấn đề này, bạn có thể sử dụnghàm khởi tạo với từ khóa new.
Tuy nhiên, từ ES6 trở đi, JavaScript có thêm từ khóaclass, với nhiều đặc điểm và tính năng hữu ích được áp dụng tronglập trình hướng đối tượng."
92,Cú pháp cơ bản của class trong Javascript,Cú pháp cơ bản của class trong JavaScript,"Cú pháp class cơ bản là:

```js
class MyClass {
  // các phương thức của class
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
```
`class MyClass {
  // các phương thức của class
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}` Bạn sử dụngnew MyClass()đểtạo mới một đối tượngchứa tất cả các phương thức được định nghĩa trên.
`new MyClass()` Phương thứcconstructor()được gọi một cáchtự độngvới từ khóanew. Do đó, bạn có thể khởi tạo các thuộc tính cho object trong hàm khởi tạo.
`constructor()` `new` Ví dụ classUsernhư sau:
`User` 
```js
class User {
  // hàm khởi tạo
  constructor(name) {
    // khởi tạo thuộc tính `this.name` với giá trị bằng `name`
    this.name = name;
  }

  // phương thức
  sayHi() {
    console.log(this.name);
  }
}

// Sử dụng:
let user = new User(""Alex"");
user.sayHi(); // Alex
```
`class User {
  // hàm khởi tạo
  constructor(name) {
    // khởi tạo thuộc tính `this.name` với giá trị bằng `name`
    this.name = name;
  }

  // phương thức
  sayHi() {
    console.log(this.name);
  }
}

// Sử dụng:
let user = new User(""Alex"");
user.sayHi(); // Alex` Khinew User(""Alex"")được gọi:
`new User(""Alex"")` `constructor` `""Alex""` `this.name` Sau đó, bạn có thể gọi phương thức của object, ví dụ:user.sayHi().
`user.sayHi()` Bạn cần chú ý để tránh nhầm lẫn giữa việcđịnh nghĩa classvới việcđịnh nghĩa object."
93,Cú pháp cơ bản của class trong Javascript,Class là gì?,"Trong JavaScript, class thực chất là một loạiFunction. Và bạn có thể xem ví dụ sau để thấy rõ điều đó:

```js
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(this.name);
  }
}

// sử dụng typeof để xác định kiểu của User
console.log(typeof User); // function
```
`class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(this.name);
  }
}

// sử dụng typeof để xác định kiểu của User
console.log(typeof User); // function` Bản chất củaclass User {...}như sau:
`class User {...}` `User` `constructor` `sayHi` `User.prototype` Sau khi đối tượng mới được tạo ra và gọi một phương thức, JavaScript sẽtự động tìm kiếmphương thức đó trong prototype (như đã miêu tả trong bàiF.prototype).
Ví dụ chứng minh:

```js
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(this.name);
  }
}

// class là function
console.log(typeof User); // function

// User.prototype.constructor chính là User
console.log(User === User.prototype.constructor); // true

// Các phương thức được lưu trong User.prototype
console.log(User.prototype.sayHi); // code của phương thức sayHi

// Có tất cả 2 phương thức trong prototype
console.log(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```
`class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(this.name);
  }
}

// class là function
console.log(typeof User); // function

// User.prototype.constructor chính là User
console.log(User === User.prototype.constructor); // true

// Các phương thức được lưu trong User.prototype
console.log(User.prototype.sayHi); // code của phương thức sayHi

// Có tất cả 2 phương thức trong prototype
console.log(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi`"
94,Cú pháp cơ bản của class trong Javascript,"Class không chỉ là ""syntactic sugar""","Khái niệmsyntactic sugardùng để chỉ mộtcú pháp mớiđược sinh ra nhằm mục đíchdễ đọc, dễ viết, chứ không tạo thêm những đặc điểm, tính chất mới so vớicú pháp cũ.
Mọi người thường coiclass là syntatic sugar của function. Vì thực chất là ta có thể định nghĩa được thứtương tự classmà không cần từ khóaclassnhư sau:

```js
// *** Viết lại `class User` sử dụng hàm ***

// 1. viết hàm khởi tạo
function User(name) {
  this.name = name;
}

// prototype của hàm luôn có thuộc tính constructor mặc định,
// nên không cần định nghĩa lại

// 2. thêm thuộc tính vào prototype
User.prototype.sayHi = function () {
  console.log(this.name);
};

// Sử dụng:
let user = new User(""Alex"");
user.sayHi(); // Alex
```
`// *** Viết lại `class User` sử dụng hàm ***

// 1. viết hàm khởi tạo
function User(name) {
  this.name = name;
}

// prototype của hàm luôn có thuộc tính constructor mặc định,
// nên không cần định nghĩa lại

// 2. thêm thuộc tính vào prototype
User.prototype.sayHi = function () {
  console.log(this.name);
};

// Sử dụng:
let user = new User(""Alex"");
user.sayHi(); // Alex` Bạn có thể thấy cách định nghĩa hàm trên cho kết quả khá giống với cách dùng class. Tuy nhiên, vẫn có một số đặc điểm khác giữa class và hàm như sau:
► Một hàm được tạo bởi từ khóaclassluôn có một thuộc tính mặc định là[[IsClassConstructor]]: true. Và JavaScript engine thường dùng thuộc tính này để phân biệt giữa hàm bình thường và class.
`[[IsClassConstructor]]: true` Ví dụ class bắt buộc phải gọi với từ khóanewtrong khi hàm bình thường thì không:
`new` 
```js
// hàm bình thường
function User1() {}

// class
class User2 {
  constructor() {}
}

User1(); // không lỗi
User2(); // lỗi: Class constructor User2 cannot be invoked without 'new'
```
`// hàm bình thường
function User1() {}

// class
class User2 {
  constructor() {}
}

User1(); // không lỗi
User2(); // lỗi: Class constructor User2 cannot be invoked without 'new'` String biểu diễn class cũng luôn bắt đầu bằngclass:

```js
// hàm bình thường
function User1() {}

// class
class User2 {
  constructor() {}
}

console.log(User1); // ƒ User1() {}
console.log(User2); // class User2 { constructor() {} }
```
`// hàm bình thường
function User1() {}

// class
class User2 {
  constructor() {}
}

console.log(User1); // ƒ User1() {}
console.log(User2); // class User2 { constructor() {} }` ► Các phương thức của class lànon-enumerable- tức là không xuất hiện trongfor...in. Bởi vì class luôn gán giá trịenumerable : falsecho tất cả các phương thức trongprototype.
`for...in` `enumerable : false` `prototype` ► Code trong class luôn sử dụng ởstrict mode.
Ngoài ra, class còn có nhiều cú pháp và tính năng hay ho khác nữa sẽ được trình bày ở các bài viết sau."
95,Cú pháp cơ bản của class trong Javascript,Class expression,"Giống như function, class cũng cóclass expression- biểu thức class. Nghĩa là nó có thể được định nghĩa bên trong một biểu thức khác, truyền giữa các hàm, làm giá trị trả về của hàm hoặc dùng để gán cho biến,...
Sau đây là ví dụ về class expression:

```js
let User = class {
  sayHi() {
    console.log(""Hello"");
  }
};
```
`let User = class {
  sayHi() {
    console.log(""Hello"");
  }
};` Tương tự nhưNamed Function Expression- NFE, class expression cũng có thể cótên. Và nếu một class expression có tên thì tên đóchỉ được nhìn thấy bên trong class, ví dụ:

```js
let User = class MyClass {
  sayHi() {
    // MyClass is chỉ được nhìn thấy bên trong class
    console.log(MyClass);
  }
};

new User().sayHi(); // hiển thị định nghĩa MyClass

// MyClass không được nhìn thấy bên ngoài
console.log(MyClass); // ReferenceError: MyClass is not defined
```
`let User = class MyClass {
  sayHi() {
    // MyClass is chỉ được nhìn thấy bên trong class
    console.log(MyClass);
  }
};

new User().sayHi(); // hiển thị định nghĩa MyClass

// MyClass không được nhìn thấy bên ngoài
console.log(MyClass); // ReferenceError: MyClass is not defined` Hoặc bạn có thểtạo độngclass như sau:

```js
function makeClass(message) {
  // khai báo class và trả về nó
  return class {
    sayHi() {
      console.log(message);
    }
  };
}

// Tạo mới một class
let User = makeClass(""Hello"");

// Tạo mới một đối tượng từ class
new User().sayHi(); // Hello
```
`function makeClass(message) {
  // khai báo class và trả về nó
  return class {
    sayHi() {
      console.log(message);
    }
  };
}

// Tạo mới một class
let User = makeClass(""Hello"");

// Tạo mới một đối tượng từ class
new User().sayHi(); // Hello`"
96,Cú pháp cơ bản của class trong Javascript,Getter/setter trong class,"Class cũng cógetter/setternhư trong object. Ví dụ sau sử dụnguser.namelàmgetter/setter:
`user.name` 
```js
class User {
  constructor(name) {
    this.name = name; // gọi hàm setter
  }

  // getter
  get name() {
    return this._name;
  }

  // setter
  set name(value) {
    if (value.length < 4) {
      alert(""Name is too short."");
      return;
    }
    this._name = value;
  }
}

// Sử dụng:
let user = new User(""Alex"");
console.log(user.name); // Alex

user = new User(""""); // Name is too short.
```
`class User {
  constructor(name) {
    this.name = name; // gọi hàm setter
  }

  // getter
  get name() {
    return this._name;
  }

  // setter
  set name(value) {
    if (value.length < 4) {
      alert(""Name is too short."");
      return;
    }
    this._name = value;
  }
}

// Sử dụng:
let user = new User(""Alex"");
console.log(user.name); // Alex

user = new User(""""); // Name is too short.` Về cơ bản, cách định nghĩagetter/settertrong class như trên cũng giống như định nghĩagetter/settertrongUser.prototype.
`User.prototype`"
97,Cú pháp cơ bản của class trong Javascript,Tạo tên phương thức qua biểu thức,"Tên của phương thức trong class có thể đượctạo động thông qua một biểu thức, ví dụ:

```js
class User {
  [""say"" + ""Hi""]() {
    console.log(""Hello"");
  }
}

new User().sayHi(); // Hello
```
`class User {
  [""say"" + ""Hi""]() {
    console.log(""Hello"");
  }
}

new User().sayHi(); // Hello` Tính năng này tương tự như trong object."
98,Cú pháp cơ bản của class trong Javascript,Thuộc tính trong class,"Trong các phần trên, mình mới đề cập đến phương thức trong class. Thực tế, bạn có thể thêm bất cứ thuộc tính nào vào class như sau:

```js
class User {
  // thêm thuộc tính name vào class
  name = ""Alex"";
  sayHi() {
    console.log(`Hello, ${this.name}!`);
  }
}
new User().sayHi(); // Hello, Alex!
```
`class User {
  // thêm thuộc tính name vào class
  name = ""Alex"";
  sayHi() {
    console.log(`Hello, ${this.name}!`);
  }
}
new User().sayHi(); // Hello, Alex!` Chú ý:
Nhiều trình duyệt cũ không hỗ trợ cách định nghĩa thuộc tính trong class như trên.
Điểm khác nhau quan trọng giữa việc định nghĩa phương thức và thuộc tính trong class là:
Ví dụ:

```js
class User {
  name = ""Alex"";
}

let user = new User();
console.log(user.name); // Alexconsole.log(User.prototype.name); // undefined
```
`class User {
  name = ""Alex"";
}

let user = new User();
console.log(user.name); // Alexconsole.log(User.prototype.name); // undefined` Bạn có thể gán giá trị cho thuộc tính thông qua một biểu thức hoặc qua gọi hàm như sau:

```js
class User {
  name = prompt(""Name, please?"", ""Alex"");
}

let user = new User();
alert(user.name); // Alex
```
`class User {
  name = prompt(""Name, please?"", ""Alex"");
}

let user = new User();
alert(user.name); // Alex`"
99,Cú pháp cơ bản của class trong Javascript,Tạo phương thức bind với thuộc tính trong class,"Như mình đã đề cập trong bài viết vềfunction binding, hàm trong JavaScript xử lýthismột cáchrất động.
`this` Vì vậy, khi một object được truyền qua lại các hàm và được gọi ở mộtngữ cảnh khácthìthiscó thể được tham chiếu đếnobject khác với object ban đầu.
`this` Ví dụ đoạn code sau sẽ hiển thịundefined:
`undefined` 
```js
class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    console.log(this.value);
  }
}

let button = new Button(""hello"");

setTimeout(button.click, 1000); // undefined
```
`class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    console.log(this.value);
  }
}

let button = new Button(""hello"");

setTimeout(button.click, 1000); // undefined` Vấn đề ở đây là khi phương thứcbutton.clickđược truyền vào hàmsetTimeout, phương thức này sẽ được gọi bởi một đối tượng khác, không phảibutton.
`button.click` `setTimeout` `button` Có ba cách để giải quyết vấn đề này là:
►Cách 1:Sử dụngarrow functionở hàmsetTimeoutnhư sau:
`setTimeout` 
```js
setTimeout(() => button.click(), 1000);
```
`setTimeout(() => button.click(), 1000);` Khi đó, đối tượng gọi hàmclickvẫn làbutton. Vì vậy, kết quả hiển thị vẫn chính xác.
`click` `button` ►Cách 2:Sử dụng arrow function khi định nghĩa hàmclick:
`click` 
```js
class Button {
  constructor(value) {
    this.value = value;
  }

  click = () => {
    console.log(this.value);
  };
}

let button = new Button(""hello"");

setTimeout(button.click, 1000); // hello
```
`class Button {
  constructor(value) {
    this.value = value;
  }

  click = () => {
    console.log(this.value);
  };
}

let button = new Button(""hello"");

setTimeout(button.click, 1000); // hello` Vì arrow functionkhông cóthisnên khi hàmclickđược gọi,thissẽ được lấy ở ngữ cảnh bên ngoài hàm - đó chính là đối tượngbutton.
`this` `click` `this` `button` ►Cách 3:bind phương thứcclickcho đối tượng trong hàm khởi tạo.
`click` 
```js
class Button {
  constructor(value) {
    this.value = value;
    this.click = this.click.bind(this);
  }

  click() {
    console.log(this.value);
  }
}

let button = new Button(""hello"");

setTimeout(button.click, 1000); // undefined
```
`class Button {
  constructor(value) {
    this.value = value;
    this.click = this.click.bind(this);
  }

  click() {
    console.log(this.value);
  }
}

let button = new Button(""hello"");

setTimeout(button.click, 1000); // undefined` Với cách này, giá trị củathisbên trong phương thứcclickluôn là đối tượngbutton.
`this` `click` `button`"
100,Cú pháp cơ bản của class trong Javascript,Tổng kết,"Cú pháp cơ bản của class trong JavaScript như sau:

```js
class MyClass {
  prop = value; // thuộc tính
  constructor(...) { // hàm khởi tạo
    // ...
  }
  method(...) {} // phương thức
  get something(...) {} // phương thức getter
  set something(...) {} // phương thức setter
  [Symbol.iterator]() {} // phương thức với tên được tính toán qua biểu thức
  // ...
}
```
`class MyClass {
  prop = value; // thuộc tính
  constructor(...) { // hàm khởi tạo
    // ...
  }
  method(...) {} // phương thức
  get something(...) {} // phương thức getter
  set something(...) {} // phương thức setter
  [Symbol.iterator]() {} // phương thức với tên được tính toán qua biểu thức
  // ...
}` MyClassthực chất là một hàm với nội dung của hàm lấy từconstructorvà các phương thức, getter/setter được viết trongMyClass.prototype.
`MyClass` `constructor` `MyClass.prototype` Trong các bài viết sau, mình sẽ tìm hiểu nhiều hơn về class, bao gồm tính kế thừa và các tính chất khác của lập trình hướng đối tượng.
Tham khảo:Class basic syntax"
101,Cú pháp new Function trong Javascript,Giới thiệu,"Cú phápnew Functiontrong JavaScript là một cách khác để định nghĩa hàm. Cách này ít khi được sử dụng, nhưng đôi khi lại rất hữu ích.
`new Function`"
102,Cú pháp new Function trong Javascript,Cú pháp new Function,"Cú phápnew Functionđể định nghĩa hàm như sau:
`new Function` 
```js
let func = new Function([arg1, arg2, ...argN], functionBody);
```
`let func = new Function([arg1, arg2, ...argN], functionBody);` Trong đó:
`[arg1, arg2, ...argN]` `functionBody` Ví dụhàm tính tổngsau nhận vào hai sốavàbrồi trả về tổnga + b:
`a` `b` `a + b` 
```js
let sum = new Function(""a"", ""b"", ""return a + b"");

console.log(sum(1, 2)); // 3
```
`let sum = new Function(""a"", ""b"", ""return a + b"");

console.log(sum(1, 2)); // 3` Hoặchàm không có tham sốtruyền vào:

```js
let sayHi = new Function('console.log(""Hello"")');

sayHi(); // Hello
```
`let sayHi = new Function('console.log(""Hello"")');

sayHi(); // Hello` Điểm khác nhau quan trọnggiữa cú phápnew Functiontrong JavaScript với các cách định nghĩa hàm khác là:
`new Function` `new Function` Với tất cả các cách khác, bạn phải định nghĩa hàm ngay từ đầu. Nhưng cú phápnew Functionlại có thể chuyểnstringthành hàm.
`new Function` Điều này cho phép bạn định nghĩa hàm bằng cách nhậnstring từ server(hoặc nguồn khác) rồi thực thi hàm:

```js
let str = /*... nhận được từ server ...*/

// khởi tạo hàm từ string nhận được trên
let func = new Function(str);

// thực thi hàm
func();
```
`let str = /*... nhận được từ server ...*/

// khởi tạo hàm từ string nhận được trên
let func = new Function(str);

// thực thi hàm
func();`"
103,Cú pháp new Function trong Javascript,Mối liên quan với closure,"Thông thường, một hàm trong JavaScript sẽ lưu những thông tin của môi trường - nơi mà hàm được tạo ra, đó chính làLexical Environment.
Nếu một hàm được định nghĩa thông qua cú phápnew Functionthì lại khác. Hàm này không lưu thông tin của môi trường nơi hàm tạo ra mà lại lưu thông tin củamôi trường global, ví dụ:
`new Function` 
```js
window.value = ""test from window"";

function getFunc() {
  let value = ""test from getFunc"";

  let func = new Function(""console.log(value)"");

  return func;
}

getFunc()(); // test from window
```
`window.value = ""test from window"";

function getFunc() {
  let value = ""test from getFunc"";

  let func = new Function(""console.log(value)"");

  return func;
}

getFunc()(); // test from window` Trong ví dụ trên, hàmfuncđược tạo ra bên trong hàmgetFuncnhưng lại không nhìn thấy biếnvaluebên ngoài.
`func` `getFunc` `value` Nói cách khác, biếnvalueở câu lệnhconsole.log(value)sẽ được tham chiếu đến đối tượng global (với trình duyệt thì đó là đối tượngwindow).
`value` `console.log(value)` `window` So sánh với cách định nghĩa hàm thông thường:

```js
window.value = ""test from window"";

function getFunc() {
  let value = ""test from getFunc"";

  let func = function () {
    console.log(value);
  };

  return func;
}

getFunc()(); // ""test from getFunc"" - giá trị của value lấy ở bên ngoài
```
`window.value = ""test from window"";

function getFunc() {
  let value = ""test from getFunc"";

  let func = function () {
    console.log(value);
  };

  return func;
}

getFunc()(); // ""test from getFunc"" - giá trị của value lấy ở bên ngoài` Đặc điểm trên của cú phápnew Functiontrong JavaScript có vẻ lạ, nhưng lại rất hợp lý.
`new Function` Tưởng tượng bạn cần phải tạo một hàm từ string. Mà nội dung của hàm lạikhông biết trướcnên không thể định nghĩa hàm theo cách thông thường.
Giả sử hàm mới này cần tương tác với mã nguồn chính, cụ thể làđọc giá trị của một biến.
Vấn đề xảy ra ở đây là: trước khi triển khai web lên môi trường thật, mã nguồn thường đượcnén lạiđể giảm thiểu dung lượng.
Cụ thể là chương trình nén sẽxóa bỏ dấu cách,ghi chú codevà đặc biệt làđổi tên biến thành dạng ngắn gọn hơn. Ví dụ biếnuserNameđược đổi thànhachẳng hạn.
`userName` `a` Nếu hàm tạo bởinew Functionmuốn đọc giá trị của biếnuserNamethì sẽ sinh ra lỗi, vì không tìm thấy biếnuserNamenữa.
`new Function` `userName` `userName` Có thể bạn chưa biết
Để đọc giá trị của biến bên ngoài với cú phápnew Function, bạn hãy truyền giá trị của biến đó vào hàm thông qua tham số.
`new Function`"
104,Cú pháp new Function trong Javascript,Tổng kết,"Cú phápnew Functiontrong JavaScript là:
`new Function` 
```js
let func = new Function([arg1, arg2, ...argN], functionBody);
```
`let func = new Function([arg1, arg2, ...argN], functionBody);` Bạn có thể truyền tham số vào hàm theo các cách khác nhau như sau:

```js
// cú pháp cơ bản
new Function(""a"", ""b"", ""return a + b"");

// các tham số cách nhau bởi dấu phẩy
new Function(""a,b"", ""return a + b"");

// các tham số cách nhau bởi dấu phẩy và có dấu cách
new Function(""a , b"", ""return a + b"");
```
`// cú pháp cơ bản
new Function(""a"", ""b"", ""return a + b"");

// các tham số cách nhau bởi dấu phẩy
new Function(""a,b"", ""return a + b"");

// các tham số cách nhau bởi dấu phẩy và có dấu cách
new Function(""a , b"", ""return a + b"");` Hàm tạo bởinew Functionkhông tham chiếu tới môi trường nơi hàm được tạo ra, mà tham chiếu đến đối tượng global.
`new Function` Vì vậy, hàm này không thể đọc được giá trị của biến ngoài hàm. Điều này là tốt vì nó giúp tránh được nhiều lỗi.
Để đọc giá trị của biến trong hàmnew Function, hãy truyền giá trị của biến vào hàm thông qua tham số.
`new Function` Tham khảo:The ""new Function"" syntax"
105,Dấu ba chấm trong Javascript,Giới thiệu,"Rất nhiều hàm trong JavaScript hỗ trợ truyền vàosố lượng tham số không giới hạn, ví dụ:
`Math.max(arg1, arg2, ..., argN)` `Object.assign(dest, src1, ..., srcN)` `src1...N` `dest` Để làm được điều đó, bạn có thể sử dụngdấu ba chấm trong JavaScript."
106,Dấu ba chấm trong Javascript,Tham số còn lại của hàm...args,"`...args` Trong JavaScript, một hàm có thể được gọi vớisố lượng tham số truyền vào tùy ý, bất kể hàm đó được định nghĩa như thế nào, ví dụ:

```js
// hàm tính tổng hai số
function sum(a, b) {
  return a + b;
}

// gọi hàm và truyền vào số lượng tham số lớn hơn định nghĩa
console.log(sum(1, 2, 3, 4, 5)); // 3
```
`// hàm tính tổng hai số
function sum(a, b) {
  return a + b;
}

// gọi hàm và truyền vào số lượng tham số lớn hơn định nghĩa
console.log(sum(1, 2, 3, 4, 5)); // 3` Hàmsumđược định nghĩa gồm hai tham sốavàb. Khi gọi hàm, mình đãtruyền vào số lượng tham số nhiều hơnvà không có lỗi xảy ra, mặc dù kết quả vẫn là tổng hai số đầu tiên.
`sum` `a` `b` Các tham số còn lại của hàmcó thể gom lại thành một mảngbằng cách sử dụngdấu ba chấm trong JavaScript, theo sau bởitên của một mảngchứa các tham số còn lại này.
Ví dụ sau gom hết các tham số vào mảngargs:
`args` 
```js
// hàm tính tổng tất cả các tham số truyền vào
function sumAll(...args) {
  let sum = 0;

  // duyệt mảng để tính tổng
  for (let arg of args) {
    sum += arg;
  }

  return sum;
}

console.log(sumAll(1)); // 1
console.log(sumAll(1, 2)); // 3
console.log(sumAll(1, 2, 3)); // 6
```
`// hàm tính tổng tất cả các tham số truyền vào
function sumAll(...args) {
  let sum = 0;

  // duyệt mảng để tính tổng
  for (let arg of args) {
    sum += arg;
  }

  return sum;
}

console.log(sumAll(1)); // 1
console.log(sumAll(1, 2)); // 3
console.log(sumAll(1, 2, 3)); // 6` Ngoài ra, bạn cũng có thể lấymột vài tham số đầu tiênthông qua biến. Các tham số còn lại cho vào mảng.
Ví dụ sau lấy hai tham số đầu tiên cho vào biến, các tham số còn lại cho vào mảng:

```js
function showName(firstName, lastName, ...titles) {
  console.log(`${firstName} ${lastName}`); // Julius Caesar

  // các biến còn lại được đưa vào mảng
  // ví dụ mảng titles = [""Consul"", ""Imperator""]
  console.log(titles[0]); // Consul
  console.log(titles[1]); // Imperator
  console.log(titles.length); // 2
}

showName(""Julius"", ""Caesar"", ""Consul"", ""Imperator"");
```
`function showName(firstName, lastName, ...titles) {
  console.log(`${firstName} ${lastName}`); // Julius Caesar

  // các biến còn lại được đưa vào mảng
  // ví dụ mảng titles = [""Consul"", ""Imperator""]
  console.log(titles[0]); // Consul
  console.log(titles[1]); // Imperator
  console.log(titles.length); // 2
}

showName(""Julius"", ""Caesar"", ""Consul"", ""Imperator"");` Lưu ý
Cú pháp dấu ba chấm trong JavaScript để lấy các tham số còn lại của hàm phải đặt ởcuối danh sách các tham số
Ví dụ sau sử dụng cú pháp dấu ba chấm ở giữa nên bị lỗi:

```js
function func(arg1, ...rest, arg2) {
      //
    }

    // Uncaught SyntaxError: Rest parameter must be last formal parameter
```
`function func(arg1, ...rest, arg2) {
      //
    }

    // Uncaught SyntaxError: Rest parameter must be last formal parameter`"
107,Dấu ba chấm trong Javascript,Đối tượngarguments,"`arguments` Trong hàm có một đối tượng đặc biệt làarguments. Đây là đối tượng kiểuarray-likevàiterablechứa tất cả các tham số của hàm xác định bởi chỉ số, ví dụ:
`arguments` 
```js
function sumAll() {
  for (let i = 0; i < arguments.length; i++) {
    console.log(arguments[i]);
  }

  // có thể dùng for...of
  // for (let arg of arguments) {
  //   console.log(arg);
  // }
}

sumAll(1, 2, 3, 4, 5);

/*
    1
    2
    3
    4
    5
    */
```
`function sumAll() {
  for (let i = 0; i < arguments.length; i++) {
    console.log(arguments[i]);
  }

  // có thể dùng for...of
  // for (let arg of arguments) {
  //   console.log(arg);
  // }
}

sumAll(1, 2, 3, 4, 5);

/*
    1
    2
    3
    4
    5
    */` Khi cú pháp dấu ba chấm trong JavaScript chưa xuất hiện thìargumentslà cách được sử dụng để lấy tất cả tham số truyền vào hàm.
`arguments` Tuy nhiên, cách sử dụngargumentscó nhược điểm là:
`arguments` `arguments` `arguments.map(...)` `arguments` `arguments`"
108,Dấu ba chấm trong Javascript,Cú pháp spread,"Bên trên bạn đã biết cách sử dụng cú pháp dấu ba chấm để lấy một mảng các tham số còn lại trong hàm. Tuy nhiên, nhiều khi bạn cần phải làmngược lại.
Ví dụ khi sử dụng hàmMath.maxđể trả về giá trị lớn nhất trong các tham số truyền vào:

```js
console.log(Math.max(4, 7, 5)); // 7
```
`console.log(Math.max(4, 7, 5)); // 7` Giả sử, bạn có một mảng[4, 7, 5]. Làm sao để gọi phương thứcMath.maxvới mảng trên?
`[4, 7, 5]` `Math.max` Bạn không thể truyền thẳng một mảng vào hàm vìMath.maxkhông nhận tham số là mảng:
`Math.max` 
```js
let arr = [4, 7, 5];

console.log(Math.max(arr)); // NaN
```
`let arr = [4, 7, 5];

console.log(Math.max(arr)); // NaN` Dĩ nhiên, bạn có thể lấy từng phần tử của mảng để truyền vào hàm:

```js
let arr = [4, 7, 5];

console.log(Math.max(arr[0], arr[1], arr[2])); // 7
```
`let arr = [4, 7, 5];

console.log(Math.max(arr[0], arr[1], arr[2])); // 7` Nhưng vấn đề ở đây là bạnkhông biết trước số lượng các phần tử của mảng. Nên cách làm trên là không hợp lý.
Để giải quyết vấn đề này, bạn có thể sử dụngcú pháp spread.
Cú pháp spread cũng sử dụng ba dấu chấm giống như cú pháp lấy các tham số còn lại của hàm như trên, nhưng cách thực hiện ngược lại.
Khi biếnarrđược sử dụng trong lời gọi hàm, mảngarrđược phân tách ra thành danh sách các tham số hàm.
`arr` `arr` Ví dụ với hàmMath.maxtrên:
`Math.max` 
```js
let arr = [4, 7, 5];

console.log(Math.max(...arr)); // 7
// vì mảng [4, 7, 5] được tách ra thành danh sách các tham số là 4, 7, 5
```
`let arr = [4, 7, 5];

console.log(Math.max(...arr)); // 7
// vì mảng [4, 7, 5] được tách ra thành danh sách các tham số là 4, 7, 5` Bạn có thể truyền nhiềuiterable objectvào hàm với cú pháp spread:

```js
let arr1 = [3, 5, 1];
let arr2 = [4, 6, 2];

console.log(Math.max(...arr1, ...arr2)); // 6
// cả hai mảng arr1, arr2 được trải ra và ghép lại thành dạng
// Math.max(3, 5, 1, 4, 6, 2)
```
`let arr1 = [3, 5, 1];
let arr2 = [4, 6, 2];

console.log(Math.max(...arr1, ...arr2)); // 6
// cả hai mảng arr1, arr2 được trải ra và ghép lại thành dạng
// Math.max(3, 5, 1, 4, 6, 2)` Bạn cũng có thểkết hợp cú pháp spread với việc truyền tham số thông thường:

```js
let arr1 = [3, 5, 1];
let arr2 = [4, 6, 2];

console.log(Math.max(5, ...arr1, 10, ...arr2)); // 10

// tương đương với:
// Math.max(5, 3, 5, 1, 10, 4, 6, 2)
```
`let arr1 = [3, 5, 1];
let arr2 = [4, 6, 2];

console.log(Math.max(5, ...arr1, 10, ...arr2)); // 10

// tương đương với:
// Math.max(5, 3, 5, 1, 10, 4, 6, 2)` 💡 Với bài toántách mảng thành các tham số để truyền vào hàm, bạn có thể sử dụng phương thức apply như sau:

```js
let arr = [4, 7, 5];
console.log(Math.max.apply(null, arr)); // 7
```
`let arr = [4, 7, 5];
console.log(Math.max.apply(null, arr)); // 7` Trước khi cú pháp spread xuất hiện thì đây là cách đơn giản nhất để giải quyết bài toán này."
109,Dấu ba chấm trong Javascript,Ứng dụng cú pháp spread để ghép mảng,"Cú pháp spread có thể dùng để ghép mảng, ví dụ:

```js
let arr1 = [3, 5, 1];
let arr2 = [4, 6, 2];
let arr = [...arr1, ...arr2];

console.log(arr); // (6) [3, 5, 1, 4, 6, 2]
```
`let arr1 = [3, 5, 1];
let arr2 = [4, 6, 2];
let arr = [...arr1, ...arr2];

console.log(arr); // (6) [3, 5, 1, 4, 6, 2]` Trong các ví dụ trên, mình dùng mảng với cú pháp spread. Thực chất, bạn có thể sử dụngbất kỳ iterable objectnào.
Ví dụ sử dụng cú pháp spread để biến string thành mảng các ký tự:

```js
let str = ""Hello"";

console.log([...str]); // (5) ['H', 'e', 'l', 'l', 'o']
```
`let str = ""Hello"";

console.log([...str]); // (5) ['H', 'e', 'l', 'l', 'o']` Cú pháp spreadsử dụng iteratorđể lấy các phần tử, giống như cú phápfor...of.
`for...of` 
```js
let str = ""Hello"";

for (let ch of str) {
  console.log(ch); // H, e, l, l, o
}
```
`let str = ""Hello"";

for (let ch of str) {
  console.log(ch); // H, e, l, l, o
}` Với string,for...oftrả về mảng các ký tự và...strtrở thành chuỗi'H', 'e', 'l', 'l', 'o'. Sau đó, danh sách các kí tự này được truyền vào[]để tạo mảng mới[...str].
`for...of` `...str` `'H', 'e', 'l', 'l', 'o'` `[]` `[...str]` Với bài toán này, bạn có thể dùngArray.from(str)cũng cho kết quả tương tự, vìArray.from()chuyển đối tượng iterable thành mảng.
`Array.from(str)` `Array.from()` 
```js
let str = ""Hello"";

console.log(Array.from(str)); // (5) ['H', 'e', 'l', 'l', 'o']
```
`let str = ""Hello"";

console.log(Array.from(str)); // (5) ['H', 'e', 'l', 'l', 'o']` Tuy nhiên,Array.fromvà cú pháp spread có sự khác nhau là:
`Array.from` `Array.from`"
110,Dấu ba chấm trong Javascript,Copy mảng và object,"Trong bài viếtcopy object trong JavaScript, mình đã đề cập tới cách sử dụngObject.assign()để copy object.
`Object.assign()` Ngoài ra, bạn cũng có thể dùng cú pháp spread để copy object và mảng.
Ví dụ về copy mảng với cú pháp spread:

```js
let arr = [1, 2, 3];

let arrCopy = [...arr];
// cú pháp spread tách mảng thành danh sách các tham số
// rồi truyền vào mảng mới

// kiểm tra lại nội dung của hai array trên
console.log(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// so sánh bằng thông qua tham chiếu
console.log(arr === arrCopy); // false - không cùng tham chiếu

// thay đổi mảng arr, nhưng mảng arrCopy không thay đổi
arr.push(4);
console.log(arr); // (4) [1, 2, 3, 4]
console.log(arrCopy); // (3) [1, 2, 3]
```
`let arr = [1, 2, 3];

let arrCopy = [...arr];
// cú pháp spread tách mảng thành danh sách các tham số
// rồi truyền vào mảng mới

// kiểm tra lại nội dung của hai array trên
console.log(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// so sánh bằng thông qua tham chiếu
console.log(arr === arrCopy); // false - không cùng tham chiếu

// thay đổi mảng arr, nhưng mảng arrCopy không thay đổi
arr.push(4);
console.log(arr); // (4) [1, 2, 3, 4]
console.log(arrCopy); // (3) [1, 2, 3]` Ví dụ dùng cú pháp spread trong JavaScript để copy object:

```js
let obj = { a: 1, b: 2, c: 3 };

let objCopy = { ...obj };
// cú pháp spread tách đối tượng thành danh sách key-value
// rồi truyền vào object mới

// kiểm tra nội dung hai obj
console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// so sánh qua tham chiếu
console.log(obj === objCopy); // false - vì không cùng tham chiếu

// sửa đối tượng obj, nhưng đối tượng objCopy không thay đổi
obj.d = 4;
console.log(JSON.stringify(obj)); // {""a"":1,""b"":2,""c"":3,""d"":4}
console.log(JSON.stringify(objCopy)); // {""a"":1,""b"":2,""c"":3}
```
`let obj = { a: 1, b: 2, c: 3 };

let objCopy = { ...obj };
// cú pháp spread tách đối tượng thành danh sách key-value
// rồi truyền vào object mới

// kiểm tra nội dung hai obj
console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// so sánh qua tham chiếu
console.log(obj === objCopy); // false - vì không cùng tham chiếu

// sửa đối tượng obj, nhưng đối tượng objCopy không thay đổi
obj.d = 4;
console.log(JSON.stringify(obj)); // {""a"":1,""b"":2,""c"":3,""d"":4}
console.log(JSON.stringify(objCopy)); // {""a"":1,""b"":2,""c"":3}` Rõ ràng, cách sử dụng cú pháp spreadngắn gọn hơnviệc sử dụngObject.assignnhư sau:
`Object.assign` 
```js
// copy object
let objCopy = Object.assign({}, obj);

// copy mảng
let arrCopy = Object.assign([], arr);
```
`// copy object
let objCopy = Object.assign({}, obj);

// copy mảng
let arrCopy = Object.assign([], arr);`"
111,Dấu ba chấm trong Javascript,Phân biệt 2 loại cú pháp dấu ba chấm,"Như mình đã trình bày ở trên, cú pháp dấu ba chấm có thể dùng để:
Cách phân biệt hai loại cú pháp trên là:
► Cú pháp lấy danh sách các tham số còn lại trong hàm
Dấu...được sử dụng ởđịnh nghĩa hàmvà luôn đặt cuối trong danh sách các tham số.
`...` 
```js
// định nghĩa hàm
function fn1(arg1, arg2, ...args) {
  //
}

// gọi hàm
fn1(1, 2, 3, 4, 5, 6);
```
`// định nghĩa hàm
function fn1(arg1, arg2, ...args) {
  //
}

// gọi hàm
fn1(1, 2, 3, 4, 5, 6);` ► Cú pháp spread
Dấu...được sử dụng ởlời gọi hàm(hoặc trong mảng, object) và có thể đặt ở bất kỳ đâu trong danh sách các tham số:
`...` 
```js
// định nghĩa hàm
function fn1(arg1, arg2, arg3, arg4) {
  //
}

// gọi hàm
let arr = [1, 2, 3, 4];
fn1(...arr);
```
`// định nghĩa hàm
function fn1(arg1, arg2, arg3, arg4) {
  //
}

// gọi hàm
let arr = [1, 2, 3, 4];
fn1(...arr);`"
112,Dấu ba chấm trong Javascript,Tổng kết,"Cú pháp ba chấm trong JavaScript có thể là cú pháp để lấy tham số còn lại trong hàm hoặc cú pháp spread.
Cách đơn giản để phân biệt hai loại trên là:
`...` `...` Ứng dụng:"
113,Debug Javascript dễ hay khó,Giới thiệu,"Với mọi ngôn ngữ lập trình, debug là một hoạt động khó và mất nhiều thời gian nhất. Trong đó, debugJavaScriptlà khó khăn hơn cả. Tại sao vậy?
Chúng ta sẽ cùng nhau tìm hiểu về debug trong JavaScript sau đây."
114,Debug Javascript dễ hay khó,Khái niệm chung về bug và debug,"Bug là lỗi của chương trình. Nhìn chung, chúng ta có 2 loại bug: lỗingữ phápvà lỗingữ nghĩa.
Nếu như bug là lỗi thì debug hay debugging chính là quá trình tìm ra bug.
Có thể bạn chưa biết
Debugging khó gấp 2 lần việc bạn viết ra code. Nếu viết code thông minh quá mức, bạn sẽ không đủ thông minh để debug nó - Brian Kernighan và P.J. Plauger, The Elements of Programming Style."
115,Debug Javascript dễ hay khó,Strict mode trong JavaScript,"Trong con mắt của nhiều lập trình viên, JavaScript là một thứ vô cùng lộn xộn. Lập trình JavaScript chẳng khác nào cực hình.
Tuy nhiên, JavaScript có cung cấp cho lập trình viên chế độ ""use strict"". Bằng việc khai báo và sử dụng chế độ này, JavaScript sẽ trở nên chính xác và nghiêm ngặt hơn. Do đó, bạn sẽ không thể viết code bừa bãi trong chế độ này.
Ví dụ 1: Không sử dụng strict mode

```js
x = 10;
var Infinity = 10;
delete Object.prototype;
```
`x = 10;
var Infinity = 10;
delete Object.prototype;` Ví dụ 2: Sử dụng strict mode

```js
""use strict"";
x = 10;
// Uncaught ReferenceError: x is not defined
var Infinity = 10;
// Uncaught TypeError: Cannot assign to read only property 'Infinity' of object '#<Window>'
delete Object.prototype;
// Uncaught TypeError: Cannot delete property 'prototype' of function Object() { [native code] }
```
`""use strict"";
x = 10;
// Uncaught ReferenceError: x is not defined
var Infinity = 10;
// Uncaught TypeError: Cannot assign to read only property 'Infinity' of object '#<Window>'
delete Object.prototype;
// Uncaught TypeError: Cannot delete property 'prototype' of function Object() { [native code] }` Qua hai ví dụ trên, ta thấy rằng: khi sử dụng 'use strict', bạn sẽ không thể sử dụngbiếnmà không cần khai báo, không thể gán giá trị cho thuộc tính read-only, không thể delete thuộc tính prototype của đối tượngobject. Và còn nhiều cáiKHÔNGnữa. Vì vậy, mình quyết định sẽ viết một bài chi tiết hơn về strict mode sau.
Như vậy, việc sử dụng strict mode trong lập trình JavaScript sẽ làm giảm thiểu đáng kể những lỗi không mong muốn."
116,Debug Javascript dễ hay khó,Testing trước khi debug JavaScript,"Khi mà việc sử dụng strict mode hay trình duyệt không thể giúp bạn tìm ra lỗi thì đây là lúc mà bạn cần phải testing - kiểm thử chương trình.
Và để tránh phát sinh lỗi khi chương trình mở rộng ra, bạn nên kiểm tra kĩ mỗi khi viết thêm một module, hay mộtfunction.
Giả sử mình có đoạn chương trình sau:

```js
function Vector(x, y) {
  this.x = x;
  this.y = y;
}
Vector.prototype.plus = function (other) {
  return new Vector(this.x + other.x, this.y + other.y);
};
```
`function Vector(x, y) {
  this.x = x;
  this.y = y;
}
Vector.prototype.plus = function (other) {
  return new Vector(this.x + other.x, this.y + other.y);
};` Bây giờ mình sẽ viết một đoạn chương trình khác để kiểm tra xem đối tượng Vector có hoạt động đúng như mong đợi hay không:

```js
function testVector() {
  var p1 = new Vector(10, 20);
  var p2 = new Vector(-10, 5);
  var p3 = p1.plus(p2);

  if (p1.x !== 10) return ""fail: x property"";
  if (p1.y !== 20) return ""fail: y property"";
  if (p2.x !== -10) return ""fail: negative x property"";
  if (p3.x !== 0) return ""fail: x from plus"";
  if (p3.y !== 25) return ""fail: y from plus"";
  return ""everything ok"";
}
console.log(testVector());
// => everything ok
```
`function testVector() {
  var p1 = new Vector(10, 20);
  var p2 = new Vector(-10, 5);
  var p3 = p1.plus(p2);

  if (p1.x !== 10) return ""fail: x property"";
  if (p1.y !== 20) return ""fail: y property"";
  if (p2.x !== -10) return ""fail: negative x property"";
  if (p3.x !== 0) return ""fail: x from plus"";
  if (p3.y !== 25) return ""fail: y from plus"";
  return ""everything ok"";
}
console.log(testVector());
// => everything ok` Việc viết test như trên gọi là viếtunit test. Tuy nhiên, thực tế chúng ta sẽ có những framework hỗ trợ viết unit test chuyên nghiệp hơn, nhanh gọn hơn."
117,Debug Javascript dễ hay khó,Debugging - Debug JavaScript,"Một khi đã xác định được chương trình có bug, công việc tiếp theo là tìm ra vị trí gây ra bug và sửa nó.
Ví dụ chương trình sau sẽ chuyển một sốn, cơ sốbasethànhstring:

```js
function numberToString(n, base) {
  var result = """",
    sign = """";
  if (n < 0) {
    sign = ""-"";
    n = -n;
  }
  do {
    result = String(n % base) + result;
    n /= base;
  } while (n > 0);
  return sign + result;
}
console.log(numberToString(13, 10));
// => 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3…
```
`function numberToString(n, base) {
  var result = """",
    sign = """";
  if (n < 0) {
    sign = ""-"";
    n = -n;
  }
  do {
    result = String(n % base) + result;
    n /= base;
  } while (n > 0);
  return sign + result;
}
console.log(numberToString(13, 10));
// => 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3…` Rõ ràng là chương trình hoạt động không đúng mong đợi. Bây giờ ta sẽ phải tìm ra đoạn gây ra lỗi và sửa nó.
Chiến lược hiệu quả trong trường hợp này là ta sẽ ghi ra log kết quả sau từng đoạn con của chương trình, để xem đoạn bắt đầu gây ra lỗi.

```js
function numberToString(n, base) {
  var result = """",
    sign = """";
  if (n < 0) {
    sign = ""-"";
    n = -n;
  }
  console.log(""sign:"", sign);
  console.log(""n:"", n);
  do {
    result = String(n % base) + result;
    console.log(""result:"", result);
    n /= base;
    console.log(""n"", n);
  } while (n > 0);
  return sign + result;
}
console.log(numberToString(13, 10));
```
`function numberToString(n, base) {
  var result = """",
    sign = """";
  if (n < 0) {
    sign = ""-"";
    n = -n;
  }
  console.log(""sign:"", sign);
  console.log(""n:"", n);
  do {
    result = String(n % base) + result;
    console.log(""result:"", result);
    n /= base;
    console.log(""n"", n);
  } while (n > 0);
  return sign + result;
}
console.log(numberToString(13, 10));` Kết quả ta có log như sau:
Kết quả
sign:n: 13result: 3n 1.3result: 1.33n 0.13result: 0.131.33...
Bạn đã thấy sự bất ổn chưa? Giá trị log thứ 3 cho thấy n /= base => 1.3. Trong khi giá trị mong đợi phải là 1. À thì ra JavaScript khác với C/C++ và Java. Nếu như trong C/C++, Java, 13/10 = 1 thì trong JavaScript 13/10=1.3. Do đó, ta phải sửa thành n = Math.floor(n/base). Chương trình sẽ hoạt động đúng.

```js
function numberToString(n, base) {
  var result = """",
    sign = """";
  if (n < 0) {
    sign = ""-"";
    n = -n;
  }
  do {
    result = String(n % base) + result;
    n = Math.floor(n / base);
  } while (n > 0);
  return sign + result;
}
console.log(numberToString(13, 10));
// => 13
```
`function numberToString(n, base) {
  var result = """",
    sign = """";
  if (n < 0) {
    sign = ""-"";
    n = -n;
  }
  do {
    result = String(n % base) + result;
    n = Math.floor(n / base);
  } while (n > 0);
  return sign + result;
}
console.log(numberToString(13, 10));
// => 13` Đó chính là một cách mà mình thường làm khi debug JS.
Ngoài cách viết log, bạn cũng có thể set breakpoint giống như bạn debug trên IDE khi lập trình C/C++ hay Java. Đây cũng là một cách debug trong JavaScript khá hay mà mình mới biết, nên chắc chắn sẽ thử cách này."
118,Debug Javascript dễ hay khó,Kết luận,"Trên đây là một số cách giúp bạn debug JavaScript. Mình có thể tóm tắt ngắn ngọn như sau:
Hy vọng qua bài viết này bạn sẽ thấy rằng debug JS không phải là một công việc quá khó khăn. Nó cũng chỉ giống như mọi ngôn ngữ lập trình khác thôi."
119,"Decorator, forwarding của hàm Javascript",Giới thiệu,"JavaScript giúp bạn xử lý hàm rất linh động. Bạn có thểtruyền hàm vào hàm khác qua tham sốhoặcsử dụng hàm như object. Và sau đây, mình sẽ giới thiệu về kỹ thuật decorator và forwarding hàm trong JavaScript."
120,"Decorator, forwarding của hàm Javascript",Caching hàm trong JavaScript,"Giả sử bạn có một hàm khá nặngslow(x)- tốn nhiều CPU khi chạy. Tuy nhiên, kết quả của hàm lạiổn định. Nghĩa là với mỗi giá trị của tham sốxgiống nhau thì kết quả trả về của hàmslow(x)cũng giống nhau.
`slow(x)` `x` `slow(x)` Nếu hàmslow(x)được gọi thường xuyên, bạn có thể sẽ muốncache(ghi nhớ) kết quả để tránh việc phải tính toán lại.
`slow(x)` Thay vì phải sửa logic của hàmslow(x), bạn có thể tạo ra mộthàm wrapper. Hàm này nhận hàmslow()làm tham số và xử lý thêm phần caching, ví dụ:
`slow(x)` `slow()` 
```js
function slow(x) {
  // có thể có các tác vụ nặng, tốn CPU
  console.log(`Đã được gọi với ${x}`);
  return x;
}

// hàm wrapper
function cachingDecorator(func) {
  let cache = new Map(); // tạo map để cache

  return function (x) {
    if (cache.has(x)) {
      // nếu tồn tại key là x thì trả về kết quả đã tương ứng
      return cache.get(x);
    }

    let result = func(x); // ngược lại thì gọi hàm

    cache.set(x, result); // thêm kết quả vào cache

    return result; // trả về kết quả
  };
}

slow = cachingDecorator(slow);

console.log(slow(1)); // cache lại kết quả của slow(1) rồi trả về kết quả
console.log(""Gọi lại: "" + slow(1)); // kết quả của slow(1) được lấy từ cache

console.log(slow(2)); // cache lại kết quả của slow(2) rồi trả về kết quả
console.log(""Gọi lại: "" + slow(2)); // kết quả của slow(1) được lấy từ cache
```
`function slow(x) {
  // có thể có các tác vụ nặng, tốn CPU
  console.log(`Đã được gọi với ${x}`);
  return x;
}

// hàm wrapper
function cachingDecorator(func) {
  let cache = new Map(); // tạo map để cache

  return function (x) {
    if (cache.has(x)) {
      // nếu tồn tại key là x thì trả về kết quả đã tương ứng
      return cache.get(x);
    }

    let result = func(x); // ngược lại thì gọi hàm

    cache.set(x, result); // thêm kết quả vào cache

    return result; // trả về kết quả
  };
}

slow = cachingDecorator(slow);

console.log(slow(1)); // cache lại kết quả của slow(1) rồi trả về kết quả
console.log(""Gọi lại: "" + slow(1)); // kết quả của slow(1) được lấy từ cache

console.log(slow(2)); // cache lại kết quả của slow(2) rồi trả về kết quả
console.log(""Gọi lại: "" + slow(2)); // kết quả của slow(1) được lấy từ cache` Kết quả
Đã được gọi với 11Gọi lại: 1Đã được gọi với 22Gọi lại: 2
Trong ví dụ trên, hàmcachingDecoratorđược gọi làdecorator- một hàm đặc biệt, nhận tham số đầu vào là một hàm khác và bổ sung thêm các tính năng.
`cachingDecorator` Ý tưởng ở đây là bạn có thể gọi hàmcachingDecoratorvới bất kỳ hàm nào và trả về một hàm wrapper đã có tính năng cache. Bởi vì thực tế, bạn sẽ có nhiều hàm cần sử dụng tính năng caching này.
`cachingDecorator` Những lợi ích của việc sử dụng hàmcachingDecoratorlà:
`cachingDecorator` `cachingDecorator` `slow()`"
121,"Decorator, forwarding của hàm Javascript",Sử dụngfunc.call,"`func.call` Thực tế, cách triển khai hàmcachingDecoratornhư trên là không phù hợp vớiphương thức của object, ví dụ:
`cachingDecorator` 
```js
""use strict"";

// hàm slow là phương thức của object worker
let worker = {
  someMethod() {
    return 1;
  },
  slow(x) {
    // có thể có thao tác tốn CPU
    console.log(""Được gọi với "" + x);
    return x * this.someMethod(); // (*)  },
};
}
// code giống như trên
function cachingDecorator(func) {
  let cache = new Map();
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // (**)    cache.set(x, result);
    return result;
  };
}
console.log(worker.slow(1)); // gọi code bình thường vẫn đúng
worker.slow = cachingDecorator(worker.slow); // khi sử dụng với caching
console.log(worker.slow(2));
// Lỗi:
// Cannot read properties of undefined (reading 'someMethod')
```
`""use strict"";

// hàm slow là phương thức của object worker
let worker = {
  someMethod() {
    return 1;
  },
  slow(x) {
    // có thể có thao tác tốn CPU
    console.log(""Được gọi với "" + x);
    return x * this.someMethod(); // (*)  },
};
}
// code giống như trên
function cachingDecorator(func) {
  let cache = new Map();
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // (**)    cache.set(x, result);
    return result;
  };
}
console.log(worker.slow(1)); // gọi code bình thường vẫn đúng
worker.slow = cachingDecorator(worker.slow); // khi sử dụng với caching
console.log(worker.slow(2));
// Lỗi:
// Cannot read properties of undefined (reading 'someMethod')` Lỗi trên xảy ra ở(*)khi gọithis.someMethod. Bởi vì ở(**), hàmcachingDecoratorgọi hàmfunc(x)theo cách này thì giá trị củathissẽ làundefined.
`(*)` `this.someMethod` `(**)` `cachingDecorator` `func(x)` `this` `undefined` Bạn có thể thấy lỗi tương tự nếu làm như sau:

```js
let func = worker.slow;
func(2);
```
`let func = worker.slow;
func(2);` Nguyên nhân gây ra lỗi trên là vì hàm wrapper đã gọi hàm gốc mà không có biến contextthis.
`this` Để giải quyết vấn đề trên, bạn có thể sử dụng phương thứcfunc.call(context,...args). Phương thức này cho phép truyền vào giá trị củathisvới cú pháp đầy đủ là:
`func.call(context,...args)` `this` 
```js
func.call(context, arg1, arg2, ...)
```
`func.call(context, arg1, arg2, ...)` Phương thứcfunc.callgọi hàmfuncvới tham số đầu tiên tương ứng giá trị củathisvà theo sau là danh sách các tham số của hàm, ví dụ:
`func.call` `func` `this` 
```js
func(1, 2, 3);
func.call(obj, 1, 2, 3);
```
`func(1, 2, 3);
func.call(obj, 1, 2, 3);` Hai cách gọi hàm trêncơ bản giống nhau, chỉ khác ở cách gọifunc.callthì giá trị củathisbằngobj.
`func.call` `this` `obj` Ví dụ hàmsayHisau đây được gọi với hai ngữ cảnhthiskhác nhau:
`sayHi` `this` 
```js
function sayHi() {
  console.log(this.name);
}

let user = { name: ""Alex"" };
let admin = { name: ""Admin"" };

// gọi hàm sayHi với giá trị của `this` khác nhau
sayHi.call(user); // Alex
sayHi.call(admin); // Admin
```
`function sayHi() {
  console.log(this.name);
}

let user = { name: ""Alex"" };
let admin = { name: ""Admin"" };

// gọi hàm sayHi với giá trị của `this` khác nhau
sayHi.call(user); // Alex
sayHi.call(admin); // Admin` Quay lại ví dụ về caching trên, bây giờ bạn có thể áp dụng phương thứcfunc.callnhư sau:
`func.call` 
```js
""use strict"";

// hàm slow là phương thức của object worker
let worker = {
  someMethod() {
    return 1;
  },
  slow(x) {
    // có thể có thao tác tốn CPU
    console.log(""Được gọi với "" + x);
    return x * this.someMethod(); // (*)  },
  },
};
// code giống như trên
function cachingDecorator(func) {
  let cache = new Map();
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // (**)    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow);
console.log(worker.slow(2));
console.log(worker.slow(2));
```
`""use strict"";

// hàm slow là phương thức của object worker
let worker = {
  someMethod() {
    return 1;
  },
  slow(x) {
    // có thể có thao tác tốn CPU
    console.log(""Được gọi với "" + x);
    return x * this.someMethod(); // (*)  },
  },
};
// code giống như trên
function cachingDecorator(func) {
  let cache = new Map();
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // (**)    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow);
console.log(worker.slow(2));
console.log(worker.slow(2));` Bây giờ, mọi thứ đã bình thường và không có lỗi xảy ra. Và đoạn code trên có thể hiểu như sau:
`cachingDecorator` `worker.slow` `function(){...}` `worker.slow(2)` `2` `this=worker` `worker` `.`"
122,"Decorator, forwarding của hàm Javascript",Caching hàm với nhiều tham số,"Cách triển khai hàmcachingDecoratornhư trên chỉ áp dụng được vớihàm có 1 tham số đầu vào. Giả sử, mình muốn sử dụngcachingDecoratorvới nhiều tham số thì sao?
`cachingDecorator` `cachingDecorator` 
```js
let worker = {
  slow(min, max) {
    // giả sử có thao tác tốn CPU
    return min + max;
  },
};

// ghi nhớ kết quả với các tham số truyền vào
worker.slow = cachingDecorator(worker.slow);
```
`let worker = {
  slow(min, max) {
    // giả sử có thao tác tốn CPU
    return min + max;
  },
};

// ghi nhớ kết quả với các tham số truyền vào
worker.slow = cachingDecorator(worker.slow);` Với hàm một tham sốx, bạn có thể sử dụngcache.set(x, result)để lưu kết quả và dùngcache.get(x)để lấy kết quả đã cache.
`x` `cache.set(x, result)` `cache.get(x)` Nhưng với trường hợp bạn cần ghi nhớ hai tham số(min, max)thì cách trên lại không dùng được ngay. Vìkiểu dữ liệu Mapchỉ áp dụng được với1 key.
`(min, max)` Có nhiều cách để giải quyết vấn đề này:
`cache.set(min, value)` `value` `(max, result)` `cache.get(min).get(max)` `min,max` `(min,max)` `hash` Ví dụ cách sử dụng hàmhashnhư sau:
`hash` 
```js
let worker = {
  slow(min, max) {
    console.log(`Được gọi với ${min},${max}`);
    return min + max;
  },
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function () {
    let key = hash(arguments); // (*)    if (cache.has(key)) {
    return cache.get(key);
  };

  let result = func.call(this, ...arguments); // (**)
  cache.set(key, result);
  return result;
}

function hash(args) {
  return args[0] + "","" + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

console.log(worker.slow(3, 5)); // hoạt động bình thường
console.log(""Gọi lại "" + worker.slow(3, 5)); // kết quả từ cache
```
`let worker = {
  slow(min, max) {
    console.log(`Được gọi với ${min},${max}`);
    return min + max;
  },
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function () {
    let key = hash(arguments); // (*)    if (cache.has(key)) {
    return cache.get(key);
  };

  let result = func.call(this, ...arguments); // (**)
  cache.set(key, result);
  return result;
}

function hash(args) {
  return args[0] + "","" + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

console.log(worker.slow(3, 5)); // hoạt động bình thường
console.log(""Gọi lại "" + worker.slow(3, 5)); // kết quả từ cache` Ví dụ trên có hai thay đổi là:
`(*)` `key` `hash(arguments)` `hash` `,` `(**)` `func.call(this, ...arguments)` `this` `...`"
123,"Decorator, forwarding của hàm Javascript",Sử dụngfunc.apply,"`func.apply` Thay vì sử dụng cú phápfunc.call(this, ...arguments), bạn có thể dùngfunc.apply(this, arguments)với cú pháp đầu đủ là:
`func.call(this, ...arguments)` `func.apply(this, arguments)` 
```js
func.apply(context, args);
```
`func.apply(context, args);` Phương thức trên gọi hàmfuncvớithis=contextvà tham số đầu vào làargscó kiểu dữ liệuarray-like.
`func` `this=context` `args` Khác nhau cơ bản giữafunc.applyvàfunc.calllà ở cách truyền tham số:
`func.apply` `func.call` `func.apply` `func.call` 
```js
func.call(context, ...args);
func.apply(context, args);
```
`func.call(context, ...args);
func.apply(context, args);` Trong hai cách gọi trên,func.applycó vẻ nhanh hơn, bởi vì JavaScript Engine tối ưu cách này hơn.
`func.apply` Ngoài ra, cách chuyển hết các tham số từ hàm này sang hàm khác gọi làkỹ thuật forwarding, ví dụ:

```js
let wrapper = function () {
  return func.apply(this, arguments);
};
```
`let wrapper = function () {
  return func.apply(this, arguments);
};` Khi hàmwrapperđược gọi, thực chất hàm này lại chuyển hết tham số sang hàmfuncđể gọi hàmfunc.
`wrapper` `func` `func`"
124,"Decorator, forwarding của hàm Javascript",Kỹ thuật mượn phương thức,"Hàmhashbên trên đang chỉ xử lý trường hợp cóhai tham số đầu vào.
`hash` 
```js
function hash(args) {
  return args[0] + "","" + args[1];
}
```
`function hash(args) {
  return args[0] + "","" + args[1];
}` Nhưng tốt hơn hết là hàmhashhoạt động được vớisố lượng tham số tùy ý. Và cách sử dụng cơ bản nhất là sử dụng phương thứcarr.join.
`hash` `arr.join` 
```js
function hash(args) {
  return args.join();
}
```
`function hash(args) {
  return args.join();
}` Tuy nhiên, cách trên lại không dùng được. Bởi vì cách gọihash(arguments)trước đó lại truyền vào tham sốargumentsvừa làiterable objectvà vừa là array-like, nhưngkhông phải array.
`hash(arguments)` `arguments` 
```js
function hash() {
  console.log(arguments.join());
}

hash(1, 2);

// Uncaught TypeError: arguments.join is not a function
```
`function hash() {
  console.log(arguments.join());
}

hash(1, 2);

// Uncaught TypeError: arguments.join is not a function` Để giải quyết vấn đề trên, bạn có thể sửa lại như sau:

```js
function hash() {
      console.log([].join.call(arguments)); // 1,2}

    hash(1, 2);
```
`function hash() {
      console.log([].join.call(arguments)); // 1,2}

    hash(1, 2);` Cách trên gọi làkỹ thuật mượn phương thức- borrowing method.
Cụ thể là mình đã mượn phương thức[].joincủa mảng[]và sử dụng[].join.callvới context làthis=arguments.
`[].join` `[]` `[].join.call` `this=arguments`"
125,"Decorator, forwarding của hàm Javascript",Decorator và thuộc tính của hàm,"Nhìn chung, việc sử dụng decorator thể thay thế hàm hoặc phương thức của object là an toàn, ngoại trừ một trường hợp. Nếu hàm gốc sử dụng kiểufunction object, nghĩa là có thuộc tính, kiểufunc.calledCount.
`func.calledCount` Nếu truyền hàmfunctrên qua decorator thì hàm wrapper sẽ không có thuộc tínhcalledCount. Vì thực chất là decorator đã tạo ra một hàm mới.
`func` `calledCount`"
126,"Decorator, forwarding của hàm Javascript",Tổng kết,"Kĩ thuật decoratorlà cách tạo ra hàm wrapper chứa hàm gốc và bổ sung thêm một số tính năng khác, với ưu điểm:
Để triển khai decorator, bạn có thể sử dụng các phương thức:
`func.call(context, ...args)` `func` `this=context` `args` `func.apply(context, args)` `func` `this=context` `args` Kỹ thuật forwardinglà cách chuyển toàn bộ tham số từ hàm này sang hàm khác:

```js
let wrapper = function () {
  return original.apply(this, arguments);
};
```
`let wrapper = function () {
  return original.apply(this, arguments);
};` Kỹ thuật mượn phương thứclà cách mượn phương thức của một object và gọi nó với object khác. Phổ biến nhất là cách lấy các phương thức hàm để áp dụng cho kiểu array-like như đối tượngarguments.
`arguments`"
127,"Decorator, forwarding của hàm Javascript",Thực hành,"Viết hàm decoratorspy(func)trả về hàm wrapper giúp lưu lại tất cả các tham số của các lời gọi hàm, ví dụ:
`spy(func)` 
```js
function work(a, b) {
  console.log(a + b);
}

work = spy(work);
work(1, 2); // 3
work(4, 5); // 9

for (let args of work.calls) {
  console.log(""call:"" + args.join()); // ""call:1,2"", ""call:4,5""
}
```
`function work(a, b) {
  console.log(a + b);
}

work = spy(work);
work(1, 2); // 3
work(4, 5); // 9

for (let args of work.calls) {
  console.log(""call:"" + args.join()); // ""call:1,2"", ""call:4,5""
}` Xem đáp án

```js
function work(a, b) {
  console.log(a + b);
}

function spy(func) {
  function f() {
    // push vào mảng các tham số    f.calls.push([...arguments]);    // forwarding lại về hàm func    return func.apply(this, arguments);  }  // khai báo thuộc tính hàm  f.calls = [];  return f;}
    work = spy(work);

    work(1, 2); // 3
    work(4, 5); // 9

    for (let args of work.calls) {
      console.log(""call:"" + args.join()); // ""call:1,2"", ""call:4,5""
    }
  }
}
```
`function work(a, b) {
  console.log(a + b);
}

function spy(func) {
  function f() {
    // push vào mảng các tham số    f.calls.push([...arguments]);    // forwarding lại về hàm func    return func.apply(this, arguments);  }  // khai báo thuộc tính hàm  f.calls = [];  return f;}
    work = spy(work);

    work(1, 2); // 3
    work(4, 5); // 9

    for (let args of work.calls) {
      console.log(""call:"" + args.join()); // ""call:1,2"", ""call:4,5""
    }
  }
}` Viết hàm decoratordelay(f, ms)trì hoãn lại gọi hàmfsaumsmili giây, ví dụ:
`delay(f, ms)` `f` `ms` 
```js
function f(x) {
  console.log(x);
}

// hàm wrapper
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);
f1000(""test""); // hiển thị ""test"" sau 1000ms
f1500(""test""); // hiển thị ""test"" sau 1500ms
```
`function f(x) {
  console.log(x);
}

// hàm wrapper
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);
f1000(""test""); // hiển thị ""test"" sau 1000ms
f1500(""test""); // hiển thị ""test"" sau 1500ms` Xem đáp án

```js
function f(x) {
  console.log(x);
}

function delay(func, ms) {
  return function () {
    setTimeout(() => func.apply(this, arguments), ms);
  };
}
// hàm wrapper
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000(""test""); // hiển thị ""test"" sau 1000ms
f1500(""test""); // hiển thị ""test"" sau 1500ms
```
`function f(x) {
  console.log(x);
}

function delay(func, ms) {
  return function () {
    setTimeout(() => func.apply(this, arguments), ms);
  };
}
// hàm wrapper
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000(""test""); // hiển thị ""test"" sau 1000ms
f1500(""test""); // hiển thị ""test"" sau 1500ms` Tham khảo:Decorators and forwarding, call/apply"
128,Destructuring assignment trong Javascript,Giới thiệu,"Destructuring Assignment trong JavaScriptlà một cú pháp đặc biệt cho phép bạnlấy ra dữ liệutừObjecthoặcArrayvà gán chúng vào các biến thông thường.
Tuy nhiên, việc ""lấy ra dữ liệu"" nàychỉ copy mà không làm thay đổi cấu trúccủa Object hoặc Array.
Dưới đây, mình sẽ tìm hiểu về cách sử dụng và ứng dụng của Destructuring Assignment trong JavaScript vớiArray và Object."
129,Destructuring assignment trong Javascript,Destructuring Assignment với Array,"Sau đây là những kiến thức cơ bản và ứng dụng của Destructuring Assignment trong JavaScript với Array.
Ví dụ về destructuring assignment với array:

```js
let [firstName, lastName] = [""David"", ""Walsh""];
/*
 * firstName = David
 * lastName = Walsh
 */
```
`let [firstName, lastName] = [""David"", ""Walsh""];
/*
 * firstName = David
 * lastName = Walsh
 */` Ví dụ trên thực hiệnkhai báo và gánluôn giá trị cho các biếnfirstNamevàlastName. Ngoài ra, bạn có thể tách biệt việc khai báo và gán giá trị như sau:
`firstName` `lastName` 
```js
let firstName, lastName;

[firstName, lastName] = [""David"", ""Walsh""];
/*
 * firstName = David
 * lastName = Walsh
 */
```
`let firstName, lastName;

[firstName, lastName] = [""David"", ""Walsh""];
/*
 * firstName = David
 * lastName = Walsh
 */` Ở đây, JavaScript thực hiện việc gán giá trị ởvế phảicho biến ởvế tráitheo đúng thứ tự chỉ số xuất hiện trong mảng.
Đoạn code trên sẽ tương đương với:

```js
let arr = [""David"", ""Walsh""];
let firstName, lastName;

firstName = arr[0];
lastName = arr[1];
```
`let arr = [""David"", ""Walsh""];
let firstName, lastName;

firstName = arr[0];
lastName = arr[1];` Chú ý: trong trường hợpsố lượng phần tử vế trái nhiều hơn vế phảithì thành phần thừa ra có giá trị làundefined.

```js
let [firstName, lastName] = [""David""];
/*
 * firstName = David
 * lastName = undefined - vế phải có 1 phần tử nên lastName là undefined
 */
```
`let [firstName, lastName] = [""David""];
/*
 * firstName = David
 * lastName = undefined - vế phải có 1 phần tử nên lastName là undefined
 */` Để tránh trường hợp này, bạn có thể khai báo giá trịdefaultcho biến như dưới đây.
Để khai báo giá trị default (mặc định), bạn sử dụng toán tử gán=như sau:
`=` 
```js
let [firstName, lastName = ""Anonymous""] = [""David""];
/*
 * firstName = David
 * lastName = Anonymous
 */
```
`let [firstName, lastName = ""Anonymous""] = [""David""];
/*
 * firstName = David
 * lastName = Anonymous
 */` Vế phải có một phần tử nênlastNamenhận giá trị mặc định bằngAnonymous.
`lastName` `Anonymous` Trong mảng có thể chứa nhiều phần tử và bạn chỉ muốn lấy ramột vài giá trị trong đóthì có thể sử dụng toán tử dấu phẩy,như sau:
`,` 
```js
let [title, , , color] = [""window"", 300, 400, ""#000""];
/*
 * title = ""window""
 * color = ""#000""
 */
```
`let [title, , , color] = [""window"", 300, 400, ""#000""];
/*
 * title = ""window""
 * color = ""#000""
 */` Lúc này, phần tử ứng chỉ số1(bằng300) và2(bằng400) bị bỏ qua.
`1` `300` `2` `400` Khác với trường hợp trên, ở đây mình lấy ra một phần tử và các phần tử còn lại được gán vào một biến khác, bằng cách sử dụng cú phápspread...:
`...` 
```js
let [title, ...others] = [""window"", 300, 400, ""#000""];
/*
 * title = ""window""
 * others = [300, 400, ""#000""]
 */
```
`let [title, ...others] = [""window"", 300, 400, ""#000""];
/*
 * title = ""window""
 * others = [300, 400, ""#000""]
 */` Khi đó, biếnotherscó giá trị là một mảng các phần tử còn lại.
`others` Trước khi có destructuring assignment trong JavaScript, bạn có thểhoán đổi giá trị của hai biếnbằng một số cách sau đây.
►Sử dụng biến trung gian

```js
// khai báo hai biến a, b
let a = 1;
let b = 2;

// sử dụng biến trung gian c, gán bằng a
let c = a;

// hoán đổi giá trị của a, b thông qua c
a = b;
b = c;
/*
 * a = 2
 * b = 1
 */
```
`// khai báo hai biến a, b
let a = 1;
let b = 2;

// sử dụng biến trung gian c, gán bằng a
let c = a;

// hoán đổi giá trị của a, b thông qua c
a = b;
b = c;
/*
 * a = 2
 * b = 1
 */` ►Sử dụng tính toán số học

```js
// khai báo hai biến a, b
let a = 1;
let b = 2;

// cộng dồn b vào a
// khi đó giá trị mới của a là tổng của a + b
a = a + b;

// thực hiện phép trừ để được kết quả
b = a - b;
a = a - b;
/*
 * a = 2
 * b = 1
 */
```
`// khai báo hai biến a, b
let a = 1;
let b = 2;

// cộng dồn b vào a
// khi đó giá trị mới của a là tổng của a + b
a = a + b;

// thực hiện phép trừ để được kết quả
b = a - b;
a = a - b;
/*
 * a = 2
 * b = 1
 */` Khiáp dụng destructuring assignmenttrong JavaScript, việc hoán đổi giá trị hai biến trở nên vô cùng đơn giản:

```js
let a = 1;
let b = 2;

[a, b] = [b, a];
/*
 * a = 2
 * b = 1
 */
```
`let a = 1;
let b = 2;

[a, b] = [b, a];
/*
 * a = 2
 * b = 1
 */` Ở đây, mình tạo ra một mảng tạm[b, a]ở vế phải. Sau đó, mình sử dụng destructuring assignment để đảo lại giá trị hai biến.
`[b, a]` Chú ý:cách hoán đổi trên có thể áp dụng được với nhiều biến (lớn hơn 2).
Mảng trong JavaScript làkiểu dữ liệu tham chiếu, nên việc sử dụng toán tử gán=thực chất làcopy địa chỉ, ví dụ:
`=` 
```js
const a = [1, 2];
const b = a;

console.log(b); // [1, 2]
console.log(b === a); // true
```
`const a = [1, 2];
const b = a;

console.log(b); // [1, 2]
console.log(b === a); // true` Nếu bạn muốnbvẫn có giá trị giốnganhưngb === alàfalsethì có thể sử dụng destructuring assignment trong JavaScript với cú pháp spread...như sau:
`b` `a` `b === a` `false` `...` 
```js
const a = [1, 2];
const [...b] = a;

console.log(b); // [1, 2]
console.log(b === a); // false
```
`const a = [1, 2];
const [...b] = a;

console.log(b); // [1, 2]
console.log(b === a); // false`"
130,Destructuring assignment trong Javascript,Destructuring Assignment với Object,"Sau đây là những kiến thức cơ bản và ứng dụng của Destructuring Assignment trong JavaScript với Object.
Ví dụ destructuring assignment với object:

```js
let { firstName, lastName } = { firstName: ""David"", lastName: ""Walsh"" };
/*
 * firstName = David
 * lastName = Walsh
 */
```
`let { firstName, lastName } = { firstName: ""David"", lastName: ""Walsh"" };
/*
 * firstName = David
 * lastName = Walsh
 */` Ví dụ trên thực hiệnkhai báo và gánluôn giá trị cho các biếnfirstNamevàlastName. Ngoài ra, bạn có thểtách biệtviệc khai báo và gán như sau:
`firstName` `lastName` 
```js
let firstName, lastName;
({ firstName, lastName } = { firstName: ""David"", lastName: ""Walsh"" });
/*
 * firstName = David
 * lastName = Walsh
 */
```
`let firstName, lastName;
({ firstName, lastName } = { firstName: ""David"", lastName: ""Walsh"" });
/*
 * firstName = David
 * lastName = Walsh
 */` Ở đây, JavaScript thực hiện việc gán giá trị ởvế phảicho biến ởvế tráitương ứng với giá trị củakeytrong Object mà không phân biệt thứ tự.
Giả sử, mình đổi thứ tự củafirstNamevàlastNamenhư sau thì kết quả vẫn không đổi:
`firstName` `lastName` 
```js
let firstName, lastName;
({ lastName, firstName } = { firstName: ""David"", lastName: ""Walsh"" });
/*
 * firstName = David
 * lastName = Walsh
 */
```
`let firstName, lastName;
({ lastName, firstName } = { firstName: ""David"", lastName: ""Walsh"" });
/*
 * firstName = David
 * lastName = Walsh
 */` Không biết bạn có thắc mắctại sao đoạn code thực hiện Destructuring Assignment bên trên phải đặt trong cặp dấu ngoặc đơnhay không.
Vì nếu thiếu cặp dấu()thì sẽ bị lỗi cú pháp.
`()` 
```js
let firstName, lastName;
    { lastName, firstName } = { firstName: ""David"", lastName: ""Walsh"" };
    // Lỗi: Uncaught SyntaxError: Unexpected token =
```
`let firstName, lastName;
    { lastName, firstName } = { firstName: ""David"", lastName: ""Walsh"" };
    // Lỗi: Uncaught SyntaxError: Unexpected token =` JavaScript hiểu rằngcặp dấu ngoặcđầu tiên là mộtblock code(khối code), chứ không phải destructuring assignment.
Ví dụ về khối code như sau:

```js
let firstName = ""David"";
let lastName = ""Walsh"";

// bắt đầu một block code
{
  // biến bên trong trùng tên với bên ngoài nhưng có giá trị khác.
  // vì chúng ở các phạm vi khác nhau.
  let firstName, lastName;
  console.log(firstName, lastName); // undefined undefined
}
```
`let firstName = ""David"";
let lastName = ""Walsh"";

// bắt đầu một block code
{
  // biến bên trong trùng tên với bên ngoài nhưng có giá trị khác.
  // vì chúng ở các phạm vi khác nhau.
  let firstName, lastName;
  console.log(firstName, lastName); // undefined undefined
}` Ngoài ra, đoạn code phía trên tương đương với cách làm thông thường như sau:

```js
let obj = { firstName: ""David"", lastName: ""Walsh"" };

let firstName = obj.firstName;
let lastName = obj.lastName;
```
`let obj = { firstName: ""David"", lastName: ""Walsh"" };

let firstName = obj.firstName;
let lastName = obj.lastName;` Trong trường hợp objectthiếu thuộc tínhmà bạn muốn lấy ra giá trị thì giá trị đó làundefined.
`undefined` 
```js
let { firstName, lastName } = { firstName: ""David"" };
/*
 * firstName = David
 * lastName = undefined - về phải không có thuộc tính lastName
 */
```
`let { firstName, lastName } = { firstName: ""David"" };
/*
 * firstName = David
 * lastName = undefined - về phải không có thuộc tính lastName
 */` Để giải quyết vấn đề này, bạn có thể khai báo giá trịdefault(mặc định) như dưới đây.
Để khai báo giá trị default (mặc định), bạn có thể sử dụng toán tử gán=, ví dụ:
`=` 
```js
let { firstName, lastName = ""Anonymous"" } = { firstName: ""David"" };
/*
 * firstName = David
 * lastName = Anonymous - lastName bằng Anonymous vì vế phải không có lastName
 */
```
`let { firstName, lastName = ""Anonymous"" } = { firstName: ""David"" };
/*
 * firstName = David
 * lastName = Anonymous - lastName bằng Anonymous vì vế phải không có lastName
 */` Nhiều khi thuộc tính mà bạn muốn thực hiện destructuring assignment ở objectquá dài hoặc tên trùng với một biến khác.
Để ngắn gọn, bạn có thểđặt tên mới cho biếnkhi thực hiện destructuring như sau:

```js
let { firstName: fn, lastName: ln } = { firstName: ""David"", lastName: ""Walsh"" };
/*
 * fn = David
 * ln = Walsh
 */
```
`let { firstName: fn, lastName: ln } = { firstName: ""David"", lastName: ""Walsh"" };
/*
 * fn = David
 * ln = Walsh
 */` Ý nghĩa đoạn code trên là:
`firstName` `fn` `lastName` `ln` Để gán giá trịmặc địnhcho biến trong trường hợp này, bạn có thể thực hiện theo cách:

```js
let { firstName: fn, lastName: ln = ""Anonymous"" } = { firstName: ""David"" };
/*
 * fn = David
 * ln = Anonymous
 */
```
`let { firstName: fn, lastName: ln = ""Anonymous"" } = { firstName: ""David"" };
/*
 * fn = David
 * ln = Anonymous
 */` Tương tự như mảng, bạn có thể sử dụngcú pháp spread...để gán các thuộc tính còn lại cho object khi thực hiện destructuring.
`...` 
```js
let { a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 };
/*
 * a = 10
 * b = 20
 * rest = { c: 30, d: 40 }
 */
```
`let { a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 };
/*
 * a = 10
 * b = 20
 * rest = { c: 30, d: 40 }
 */` Trong ví dụ trên, bạn lấy ra hai thuộc tínhavàb. Các thuộc tính còn lại được sao chép vào đối tượngrest.
`a` `b` `rest` Bạn cũng có thể sử dụng destructuring assignment trong JavaScript vớiobject và array lồng nhau nhiều tầng, ví dụ:

```js
let options = {
  size: {
    width: 100,
    height: 200,
  },
  items: [""Cake"", ""Donut""],
  extra: true, // trường này không destruct
};

// cấu trúc để destruct phải giống với cấu trúc của Object
let {
  size: { width, height },
  items: [item1, item2],
  title = ""Menu"", // gán giá trị bởi default
} = options;

/*
 * Kết quả các biến thu được sau khi destructuring:
 * title = ""Menu"" - giá trị mặc định, vì vế phải không có thuộc tính title
 * width = 100
 * height = 200
 * item1 = ""Cake""
 * item2 = ""Donut""
 */
```
`let options = {
  size: {
    width: 100,
    height: 200,
  },
  items: [""Cake"", ""Donut""],
  extra: true, // trường này không destruct
};

// cấu trúc để destruct phải giống với cấu trúc của Object
let {
  size: { width, height },
  items: [item1, item2],
  title = ""Menu"", // gán giá trị bởi default
} = options;

/*
 * Kết quả các biến thu được sau khi destructuring:
 * title = ""Menu"" - giá trị mặc định, vì vế phải không có thuộc tính title
 * width = 100
 * height = 200
 * item1 = ""Cake""
 * item2 = ""Donut""
 */` Bạn có thể áp dụng destructuring assignment trong JavaScript đểcài đặt giá trị mặc định cho các tham sốkhi truyền vào hàm.
Sau đây, mình so sánh cách làm thông thường và cách dùng destructuring assignment để thấy sự khác biệt.
Sau đây là cách bình thường để cài đặtgiá trị mặc địnhcho các tham số của hàm:

```js
function drawCicle(x = 0, y = 0, radius = 1, color = ""black"") {
  // code xử lý
}

// Sử dụng
drawCicle(); // hợp lệ
drawCicle(1, 2, 3); // hợp lệ
drawCicle(1, 2, 3, ""red""); // hợp lệ
drawCicle(""red""); // không hợp lệ
drawCicle(""red"", 1, 2, 3); // không hợp lệ
```
`function drawCicle(x = 0, y = 0, radius = 1, color = ""black"") {
  // code xử lý
}

// Sử dụng
drawCicle(); // hợp lệ
drawCicle(1, 2, 3); // hợp lệ
drawCicle(1, 2, 3, ""red""); // hợp lệ
drawCicle(""red""); // không hợp lệ
drawCicle(""red"", 1, 2, 3); // không hợp lệ` Cách trên cómột số nhược điểmlà:
Giả sử, bạn muốn áp dụng giá trị default choyvàradiusbằng cách gọi hàm:
`y` `radius` 
```js
drawCicle(1, ""red"");
```
`drawCicle(1, ""red"");` Cách gọi hàm trênkhông sai về cú phápnhưng sai về mặt ý nghĩa. Vì JavaScript sẽ hiểux = 1,y = ""red"",radius = 1vàcolor = ""black"".
`x = 1` `y = ""red""` `radius = 1` `color = ""black""` Để tránh việcphải ghi nhớ thứ tự các tham số, bạn có thể gộp chúng vào một object. Sau đó, bạn chỉ cần truyền 1 tham số vàofunctionnhư dưới đây.
Tương tự như ví dụ trên, nhưng giờ chỉ còn một tham số là object:

```js
function drawCicle(options) {
  let x = options.x || 0;
  let y = options.y || 0;
  let radius = options.radius || 1;
  let color = options.color || ""black"";
  // code xử lý
}

// Sử dụng:
drawCicle({}); // hợp lệ
drawCicle({ x: 1, y: 2, radius: 3 }); // hợp lệ
drawCicle({ x: 1, y: 2, radius: 3, color: ""red"" }); // hợp lệ
drawCicle({ color: ""red"", y: 2, x: 1, radius: 3 }); // hợp lệ
```
`function drawCicle(options) {
  let x = options.x || 0;
  let y = options.y || 0;
  let radius = options.radius || 1;
  let color = options.color || ""black"";
  // code xử lý
}

// Sử dụng:
drawCicle({}); // hợp lệ
drawCicle({ x: 1, y: 2, radius: 3 }); // hợp lệ
drawCicle({ x: 1, y: 2, radius: 3, color: ""red"" }); // hợp lệ
drawCicle({ color: ""red"", y: 2, x: 1, radius: 3 }); // hợp lệ` Khi các tham số được gộp vào thành một objectoptionsthì bạn viết chúng theo thứ nào cũng không quan trọng (vì object không phân biệt thứ tự các thuộc tính).
`options` Tuy nhiên, cách cài đặt giá trị default như trên (dùng toán tử OR||) vẫn còn khá dài dòng và phức tạp.
`||` Sau đây, mình thử áp dụng destructuring assigment trong JavaScript để thấy sự khác biệt.
Ví dụ trên có thể thay đổi như sau:

```js
function drawCicle({ x = 0, y = 0, radius = 1, color = ""black"" }) {
  // code xử lý
}

// Sử dụng
drawCicle({}); // hợp lệ
drawCicle({ x: 1, y: 2, radius: 3 }); // hợp lệ
drawCicle({ x: 1, y: 2, radius: 3, color: ""red"" }); // hợp lệ
drawCicle({ color: ""red"", y: 2, x: 1, radius: 3 }); // hợp lệ
```
`function drawCicle({ x = 0, y = 0, radius = 1, color = ""black"" }) {
  // code xử lý
}

// Sử dụng
drawCicle({}); // hợp lệ
drawCicle({ x: 1, y: 2, radius: 3 }); // hợp lệ
drawCicle({ x: 1, y: 2, radius: 3, color: ""red"" }); // hợp lệ
drawCicle({ color: ""red"", y: 2, x: 1, radius: 3 }); // hợp lệ` Bây giờ, mình đãkhắc phục được hai nhược điểmđề cập bên trên. Tuy nhiên, cách làm này vẫn chưa thật hoàn thiện.
Vì sao?
Giả sử, bạn muốn sử dụng giá trị default chotất cả các thuộc tínhbên trong object. Bạn vẫn phải truyền vào một object rỗng ({}).
`{}` Để khắc phục vấn đề này, bạn có thể sửa lại đoạn code trên một chút:

```js
function drawCicle({ x = 0, y = 0, radius = 1, color = ""black"" } = {}) {
  // code xử lý
}

drawCicle({}); // hợp lệ
drawCircle(); // vẫn hợp lệ
```
`function drawCicle({ x = 0, y = 0, radius = 1, color = ""black"" } = {}) {
  // code xử lý
}

drawCicle({}); // hợp lệ
drawCircle(); // vẫn hợp lệ` Khi bạnkhông truyền bất kỳ tham số nàovào hàm trên,optionssẽ lấy giá trị mặc định là object rỗng{}.
`options` `{}`"
131,Destructuring assignment trong Javascript,Tổng kết,"Destructuring assignment trong JavaScript cho phép bạn ""mapping"" object hoặc array vào các biến một cách đơn giản.
► Cú pháp destructuring assignment với array:

```js
let [item1 = default, item2, ...rest] = array
```
`let [item1 = default, item2, ...rest] = array` Trong đó, phần tử đầu tiên được gán vào biếnitem1, phần tử thứ hai được gán vào biếnitem2và các phần tử còn lại được gán vào biếnrest(mảng).
`item1` `item2` `rest` ► Cú pháp destructuring assignment với object:

```js
let {prop : varName = default, ...rest} = object
```
`let {prop : varName = default, ...rest} = object` Trong đó, giá trị thuộc tínhpropđược gán vào biếnvarName. Nếu thuộc tínhpropkhông tồn tại trongobjectthì biếnvarNamecó giá trị mặc định làdefault. Và các thuộc tính còn lại được copy vào đối tượngrest.
`prop` `varName` `prop` `object` `varName` `default` `rest` Ngoài ra, bạn có thể áp dụng destructuring assignment trong JavaScript với object và mảng lồng nhau. Khi đó, cấu trúc ở vế trái phải tương đồng với cấu trúc vế phải."
132,Destructuring assignment trong Javascript,Thực hành,"Cho object:

```js
let user = {
  name: ""Alex"",
  years: 28,
};
```
`let user = {
  name: ""Alex"",
  years: 28,
};` Sử dụng destructuring assignment trong JavaScript thực hiện các yêu cầu sau:
`name` `name` `years` `age` `isAdmin` `isAdmin` `false` Xem đáp án

```js
let user = {
  name: ""Alex"",
  years: 28,
};

let { name, years: age, isAdmin = false } = user;

console.log(name, age, isAdmin); // Alex 28 false
```
`let user = {
  name: ""Alex"",
  years: 28,
};

let { name, years: age, isAdmin = false } = user;

console.log(name, age, isAdmin); // Alex 28 false` Cho đối tượng sau:

```js
let people = {
  Ana: 25,
  Alex: 28,
  John: 27,
};
```
`let people = {
  Ana: 25,
  Alex: 28,
  John: 27,
};` Viết hàmtopAge(people)trả về tên của người nhiều tuổi nhất.
`topAge(people)` `people` `null` Xem đáp án

```js
function topAge(people) {
  // nếu people không tồn tại thì trả về null
  if (!people) {
    return null;
  }

  // khai báo biến để lưu thông tin lớn nhất
  let nameOfLargest = """";
  let ageOfLargest = -Infinity;

  // sử dụng destructuring assignment với mỗi phần tử
  // khi sử dụng for...of với Object.entries(people)
  // chú ý: Object.entries(people) trả về iterable object
  // với mỗi phần tử có dạng [key, value]
  for (let [name, age] of Object.entries(people)) {
    // nếu phần tử đang xét có age lớn hơn ageOfLargest thì cập nhật
    if (age > ageOfLargest) {
      ageOfLargest = age;
      nameOfLargest = name;
    }
  }

  // trả về tên của người lớn tuổi nhất
  return nameOfLargest;
}

let people = {
  Ana: 25,
  Alex: 28,
  John: 27,
};

let ret = topAge(people);
console.log(ret); // Alex
```
`function topAge(people) {
  // nếu people không tồn tại thì trả về null
  if (!people) {
    return null;
  }

  // khai báo biến để lưu thông tin lớn nhất
  let nameOfLargest = """";
  let ageOfLargest = -Infinity;

  // sử dụng destructuring assignment với mỗi phần tử
  // khi sử dụng for...of với Object.entries(people)
  // chú ý: Object.entries(people) trả về iterable object
  // với mỗi phần tử có dạng [key, value]
  for (let [name, age] of Object.entries(people)) {
    // nếu phần tử đang xét có age lớn hơn ageOfLargest thì cập nhật
    if (age > ageOfLargest) {
      ageOfLargest = age;
      nameOfLargest = name;
    }
  }

  // trả về tên của người lớn tuổi nhất
  return nameOfLargest;
}

let people = {
  Ana: 25,
  Alex: 28,
  John: 27,
};

let ret = topAge(people);
console.log(ret); // Alex` Tham khảo:"
133,Dev Tools là gì? Code javascript tại sao cần console.log,Giới thiệu,"Trong lập trình, việc code lỗi là không thể tránh khỏi. Nhưng trên trình duyệt, bạn thường sẽ không nhìn thấy những lỗi này. Mà thay vào đó, bạn cần xem thông qua một công cụ. Đó chính là Dev Tools."
134,Dev Tools là gì? Code javascript tại sao cần console.log,Dev Tools là gì?,"Dev Tools (developer tools) là công cụ được tích hợp sẵn trong trình duyệt, giúp các lập trình viên có thể dễ dàng truy cập vào nội bộ của trình duyệt và ứng dụng trang web của họ.
Dev Tools có nhiều tính năng. Nhưng trong phạm vi bài viết này, mình sẽ tìm hiểu cơ bản về cách mở Dev Tools, cách xem lỗi, và cách để chạy code JavaScript trên đó.
Ngoài ra, vì dev tools trên các trình duyệt cũng gần giống nhau nên mình sẽ tập trung vào một loại trình duyệt phổ biến, hỗ trợ đa nền tảng (Windows, macOS và Linux). Đó là ""Google Chrome Developer Tools"" hay gọi tắt là ""Chrome Dev Tools""."
135,Dev Tools là gì? Code javascript tại sao cần console.log,Ví dụ sử dụng Chrome Dev Tools,"Trước tiên, bạn hãy mở trang demo này:bug.html.
Trong trang này, mình đã cố tình tạo ra một lỗi. Nhưng rõ ràng là bạn vẫn nhìn thấy trang web hiển thị bình thường phải không?
Để xem lỗi chi tiết, bạn cần mở Chrome Dev Tools lên bằng cách nhấn phímF12hoặc tổ hợp phímCtrl Shift Itrên Windows (Ctrl Opt Jtrên macOS).
Chrome Dev Tools sẽ mở tab ""Console"" đầu tiên (hoặc nếu không thì bạn chủ động nhấn vào tab đó). Kết quả sẽ như sau:
Giao diện chính xác có thể khác nhau đôi chút tùy theo phiên bản trình duyệt Chrome. Nhưng thường thì nội dung sẽ bao gồm:
Bên dưới dòng lỗi màu đỏ là kí tự>màu xanh. Đó là nơi bạn có thể gõ lệnh JavaScript vào và chạy trực tiếp bằng cách nhấnEnter. Kết quả sẽ hiển thị ngay lập tức ở dưới.
`>` Ngoài ra, để gõ mã nguồn trên nhiều dòng, bạn hãy nhấn tổ hợp phímShift Enter.
Đến đây là bạn đã biết mở Dev Tools, xem lỗi và chạy code JavaScript trên đó rồi. Chi tiết hơn về các tính năng ""bá đạo"" của Chrome Dev Tools sẽ được trình bày ở các bài viết sau nhé!"
136,Dev Tools là gì? Code javascript tại sao cần console.log,Tổng kết,Vậy Dev Tools là gì?
137,Đối tượng bất biến trong Javascript,Giới thiệu,"Thông thường,objecttrong JavaScript làmutable- nghĩa là trạng thái của object có thể thay đổi được. Nói cách khác làgiá trị các thuộc tính trong Object có thể thay đổi được, ví dụ:

```js
let obj = {}; // khởi tạo object rỗng

obj.a = 1; // thêm thuộc tính a và gán giá trị 1
obj[""a""] = 2; // cập nhật giá trị thuộc tính a bằng 2

console.log(obj.a); // 2
```
`let obj = {}; // khởi tạo object rỗng

obj.a = 1; // thêm thuộc tính a và gán giá trị 1
obj[""a""] = 2; // cập nhật giá trị thuộc tính a bằng 2

console.log(obj.a); // 2` Có nhiều trường hợp bạn muốn object đó làimmutable- trạng thái không thể thay đổi được. Sau đây, mình sẽ giới thiệu với bạn2 cách tạo immutable objecttrong JavaScript."
138,Đối tượng bất biến trong Javascript,Tạo immutable object sử dụngObject.defineProperty,"`Object.defineProperty` Object.defineProperty()định nghĩa một thuộc tính mớihoặccập nhật thuộc tính có sẵntrên object.
`Object.defineProperty()` `Object.defineProperty` Để tạo immutable object sử dụngObject.defineProperty, bạn chỉ cần định nghĩa property với thuộc tínhwritable(có thể ghi đè) làfalse, ví dụ:
`Object.defineProperty` `writable` `false` 
```js
let obj = {};

    // định nghĩa thuộc tính a trong obj
    Object.defineProperty(obj, ""a"", {
      value: 1, // giá trị là 1
      writable: false, // writable: false - nghĩa là không thể ghi đè});

    obj.a = 2; // thử ghi đè giá trị khác vào a
    console.log(obj.a); // 1 - kết quả giá trị của a vẫn không đổi
```
`let obj = {};

    // định nghĩa thuộc tính a trong obj
    Object.defineProperty(obj, ""a"", {
      value: 1, // giá trị là 1
      writable: false, // writable: false - nghĩa là không thể ghi đè});

    obj.a = 2; // thử ghi đè giá trị khác vào a
    console.log(obj.a); // 1 - kết quả giá trị của a vẫn không đổi` Bạn thấy rằng giá trị củaobj.akhông thay đổi so với giá trị ban đầu, vẫn là1. Đó chính làtính bất biến.
`obj.a` `1` Nếu sử dụng ởstrict modethì đoạn code trên sẽ sinh ra lỗi:

```js
""use strict"";
let obj = {};

// định nghĩa thuộc tính a trong obj
Object.defineProperty(obj, ""a"", {
  value: 1, // giá trị là 1
  writable: false, // writable: false - nghĩa là không thể ghi đè
});

obj.a = 2;
// Uncaught TypeError:// Cannot assign to read only property 'a' of object '#<Object>'
console.log(obj.a);
```
`""use strict"";
let obj = {};

// định nghĩa thuộc tính a trong obj
Object.defineProperty(obj, ""a"", {
  value: 1, // giá trị là 1
  writable: false, // writable: false - nghĩa là không thể ghi đè
});

obj.a = 2;
// Uncaught TypeError:// Cannot assign to read only property 'a' of object '#<Object>'
console.log(obj.a);` Đúng vậy, nếuwritablebằngfalsethì thuộc tính gọi làread only(thuộc tính chỉ đọc).
`writable` `false` Thực tế, giá trị mặc định của thuộc tínhwritablelàfalse, nên bạn có thể bỏ qua thuộc tính này:
`writable` `false` 
```js
let obj = {};
Object.defineProperty(obj, ""a"", { value: 1 });
obj.a = 2;
console.log(obj.a); // 1
```
`let obj = {};
Object.defineProperty(obj, ""a"", { value: 1 });
obj.a = 2;
console.log(obj.a); // 1` `writable` `Object.defineProperty` Câu hỏi đặt ra là:nếu mình muốn thay đổi giá trị củawritabletừfalsethànhtruecó được không?
`writable` `false` `true` Câu trả lời:mặc định là KHÔNG.
Khi định nghĩa thuộc tính bằngObject.defineProperty, ngoàiwritablera thì còn cóconfigurable(có thể chỉnh sửa).
`Object.defineProperty` `writable` `configurable` Mặc định, giá trị củaconfigurablelàfalse, nên đoạn code sau sẽ bị lỗi:TypeError: Cannot redefine property: a(không thể định nghĩa lại thuộc tính a).
`configurable` `false` 
```js
let obj = {};
Object.defineProperty(obj, ""a"", { value: 1, writable: false });
Object.defineProperty(obj, ""a"", { writable: true }); // => TypeError: Cannot redefine property: a
```
`let obj = {};
Object.defineProperty(obj, ""a"", { value: 1, writable: false });
Object.defineProperty(obj, ""a"", { writable: true }); // => TypeError: Cannot redefine property: a` Để giải quyết vấn đề này, bạn phải sửaconfigurablethànhtrue:
`configurable` `true` 
```js
let obj = {};

Object.defineProperty(obj, ""a"", {
  value: 1,
  writable: false,
  configurable: true,
});

Object.defineProperty(obj, ""a"", { writable: true });
obj.a = 2;
console.log(obj.a); // 2 - giá trị của thuộc tính a đã thay đổi
```
`let obj = {};

Object.defineProperty(obj, ""a"", {
  value: 1,
  writable: false,
  configurable: true,
});

Object.defineProperty(obj, ""a"", { writable: true });
obj.a = 2;
console.log(obj.a); // 2 - giá trị của thuộc tính a đã thay đổi` Nghĩa là bạn có thể biếnimmutable objectthànhmutable objectđược bằng cách này."
139,Đối tượng bất biến trong Javascript,Tạo immutable object sử dụngObject.freeze,"`Object.freeze` Phương thứcObject.freeze()làm cho object không thể thay đổi, bao gồm:
Object.freeze()có thể dịch ra là ""đóng băng object"".
`Object.freeze()` `Object.freeze` Ví dụ sử dụngObject.freeze()để tạo immutable object:
`Object.freeze()` 
```js
let obj = { a: 1 };

Object.freeze(obj); // đóng băng object
obj.a = 2; // cập nhật thuộc tính đã có
obj.b = 3; // thêm thuộc tính mới

console.log(obj); // { a: 1 }
```
`let obj = { a: 1 };

Object.freeze(obj); // đóng băng object
obj.a = 2; // cập nhật thuộc tính đã có
obj.b = 3; // thêm thuộc tính mới

console.log(obj); // { a: 1 }` Bạn thấy rằngobjvẫn không hề thay đổi.
`obj` Nếu sử dụng ởstrict modethì đoạn code sau sẽ bị lỗi:

```js
""use strict"";
let obj = { a: 1 };

Object.freeze(obj); // đóng băng object

obj.a = 2;
// Uncaught TypeError:
// Cannot assign to read only property 'a' of object '#<Object>'
```
`""use strict"";
let obj = { a: 1 };

Object.freeze(obj); // đóng băng object

obj.a = 2;
// Uncaught TypeError:
// Cannot assign to read only property 'a' of object '#<Object>'` Vì khi sử dụngObject.freeze(), tất cả các thuộc tính trong object đều trở thànhread-only.
`Object.freeze()` Tương tự như câu hỏi ở trên.
Nếu mình muốn unfreeze object, để biến immutable object thành mutable object thì có được không?
Câu trả lời làKHÔNG.
Bạnkhông thể unfreeze objectmột khi nó đã freeze."
140,Đối tượng bất biến trong Javascript,Tổng kết,"Trên đây là 2 cách tạo immutable object trong JavaScript.
`Object.defineProperty` `writable` `false` `Object.freeze` Mỗi cách đều có những ưu, nhược điểm riêng. Tuỳ vào từng yêu cầu cụ thể mà bạn lựa chọn cách làm hợp lý.
Liên quan đến chủ đề immutable object, có một bài viết khá hay mà bạn có thể tham khảo thêm:Tuyệt chiêu đảm bảo tính bất biến trong JavaScript."
141,Đối tượng Date trong Javascript,Giới thiệu,"Date trong JavaScript là mộtđối tượng sẵn cógiúp bạn lưu trữdate (ngày, tháng, năm),time (giờ, phút, giây)và quản lý date/time.
Ví dụ, bạn có thể sử dụngDateđể lưu thời gian tạo và chỉnh sửa dữ liệu, đo lường thời gian hay hiển thị thời gian hiện tại.
`Date`"
142,Đối tượng Date trong Javascript,Khởi tạo Date trong JavaScript,"Để khởi tạo một đối tượngDatetrong JavaScript, bạn chỉ cần gọi hàm khởi tạonew Date()với một trong các tham số sau đây.
`Date` `new Date()` ►new Date()
`new Date()` Hàm khởi tạokhông tham sốtạo mới một đối tượngDatevới thời gian hiện tại, ví dụ:
`Date` 
```js
let currentDate = new Date();
console.log(currentDate);

// hiển thị thời gian hiện tại, ví dụ:
// Sun Dec 19 2021 09:25:51 GMT+0700 (Indochina Time)
```
`let currentDate = new Date();
console.log(currentDate);

// hiển thị thời gian hiện tại, ví dụ:
// Sun Dec 19 2021 09:25:51 GMT+0700 (Indochina Time)` ►new Date(milliseconds)
`new Date(milliseconds)` Tạo mới đối tượngDatevới thời gian tương ứng vớimilliseconds(mili giây) sau ngày 01/01/1970 UTC+0.
`Date` `milliseconds` 
```js
// 0 tương ứng với ngày 01/01/1970 UTC+0
let jan01_1970 = new Date(0);
console.log(jan01_1970); // Thu Jan 01 1970 07:00:00 GMT+0700 (Indochina Time)

// cộng thêm 24 giờ => ngày 02/01/1970 UTC+0
let jan02_1970 = new Date(24 * 3600 * 1000);
console.log(jan02_1970); // Fri Jan 02 1970 07:00:00 GMT+0700 (Indochina Time)
```
`// 0 tương ứng với ngày 01/01/1970 UTC+0
let jan01_1970 = new Date(0);
console.log(jan01_1970); // Thu Jan 01 1970 07:00:00 GMT+0700 (Indochina Time)

// cộng thêm 24 giờ => ngày 02/01/1970 UTC+0
let jan02_1970 = new Date(24 * 3600 * 1000);
console.log(jan02_1970); // Fri Jan 02 1970 07:00:00 GMT+0700 (Indochina Time)` Số nguyênứng với tham sốmillisecondsbiểu diễn sốmili giâysau ngày 01/01/1970 UTC+0 được gọi làtimestamp.
`milliseconds` Chú ý: kết quả của câu lệnhconsole.log(jan01_1970)trên là ứng với múi giờ+0700tại Việt Nam.
`console.log(jan01_1970)` `+0700` Vì vậy, thời gian hiển thị là07:00:00(7 giờ 00 phút 00 giây), thay vì00:00:00(0 giờ 00 phút 00 giây) tại múi giờ+0000.
`07:00:00` `00:00:00` `+0000` Bạn có thể tạo mới đối tượngDatetừ timestamp (như trên). Ngược lại, bạn cũng có thểchuyển đổi kiểu dữ liệutừ đối tượngDatera timestamp bằng phương thứcdate.getTime()(được trình bày bên dưới).
`Date` `Date` `date.getTime()` Thời gian trước ngày 01/01/1970 cótimestamp âm, ví dụ ngày 31/12/1969:

```js
// ngày 31/12/1969 trước ngày 01/01/1970 là 1 ngày
let dec31_1969 = new Date(0 - 24 * 3600 * 1000);
console.log(dec31_1969); // Wed Dec 31 1969 07:00:00 GMT+0700 (Indochina Time)
```
`// ngày 31/12/1969 trước ngày 01/01/1970 là 1 ngày
let dec31_1969 = new Date(0 - 24 * 3600 * 1000);
console.log(dec31_1969); // Wed Dec 31 1969 07:00:00 GMT+0700 (Indochina Time)` ►new Date(string)
`new Date(string)` Nếu hàm khởi tạo Date trong JavaScript có một tham số và đó là string thì string sẽ được chuyển đổi tự động sangDate.
`Date` Thuật toán chuyển đổistringsang đối tượngDatetương tự như cách sử dụng của phương thứcDate.parse()(được trình bày bên dưới).
`Date` `Date.parse()` 
```js
let date = new Date(""2021-12-19"");
console.log(date); // Sun Dec 19 2021 07:00:00 GMT+0700 (Indochina Time)

// Thời gian không được cài đặt, nên mặc định đó là 00:00:00 tại GMT+0000,
// hoặc 07:00:00 tại GMT+0700.
```
`let date = new Date(""2021-12-19"");
console.log(date); // Sun Dec 19 2021 07:00:00 GMT+0700 (Indochina Time)

// Thời gian không được cài đặt, nên mặc định đó là 00:00:00 tại GMT+0000,
// hoặc 07:00:00 tại GMT+0700.` ►new Date(year, month, date, hours, minutes, seconds, ms)
`new Date(year, month, date, hours, minutes, seconds, ms)` Đây là hàm khởi tạođầy đủ các thông tincủa Date trong JavaScript với múi giờ local. Trong đó, hai tham số đầu tiênyearvàmonthlà bắt buộc.
`year` `month` `year` `2021` `21` `month` `0` `11` `date` `date` `1` `hours` `minutes` `seconds` `ms` `0` Ví dụ hai câu lệnh sau khởi tạo đối tượng Date giống nhau:

```js
new Date(2021, 0, 1, 0, 0, 0, 0); // 1 Jan 2021, 00:00:00
new Date(2021, 0, 1); // giống câu lệnh trên
```
`new Date(2021, 0, 1, 0, 0, 0, 0); // 1 Jan 2021, 00:00:00
new Date(2021, 0, 1); // giống câu lệnh trên` Độ chính xác tối đa là1 mili giây:

```js
let date = new Date(2021, 0, 1, 2, 3, 4, 567);
// 01/01/2021, 02:03:04.567
```
`let date = new Date(2021, 0, 1, 2, 3, 4, 567);
// 01/01/2021, 02:03:04.567`"
143,Đối tượng Date trong Javascript,Truy cập các phần tử của Date,"Sau đây là những phương thức phổ biến để truy cập vào các phần tử của Date trong JavaScript:
`getFullYear()` `getMonth()` `getDate()` `getHours()` `getMinutes()` `getSeconds()` `getMilliseconds()` `getYear()` `getYear()` Ngoài ra, bạn có thể lấyngày trong tuầnbằng phương thứcgetDay()- trả về giá trị từ0(thứ 2) đến6(chủ nhật).
`getDay()` `0` `6` Tất cả phương thức trên đều trả về giá trị tương đối ứng với múi giờ trên máy tính. Múi giờ của Việt Nam là+0700.
`+0700` Để lấy giá trị ngày, tháng, năm,... tại múi giờUTC+0, bạn chỉ cần viết thêmUTCvào các phương thức trên, phía sauget, ví dụ:getUTCFullYear(),getUTCMonth(),getUTCDate(),...
`UTC` `get` `getUTCFullYear()` `getUTCMonth()` `getUTCDate()` 
```js
let date = new Date();
console.log(date.getHours()); // 10
console.log(date.getUTCHours()); // 3
```
`let date = new Date();
console.log(date.getHours()); // 10
console.log(date.getUTCHours()); // 3` Ngoài các phương thức trên, còn hai phương thức khác không cóUTClà:
`UTC` `getTime()` `getTimezoneOffset()` 
```js
let date = new Date();
console.log(date.getTime()); // 1639883864463
console.log(date.getTimezoneOffset()); // -420 (ứng với -7 giờ)
```
`let date = new Date();
console.log(date.getTime()); // 1639883864463
console.log(date.getTimezoneOffset()); // -420 (ứng với -7 giờ)`"
144,Đối tượng Date trong Javascript,Thay đổi các phần tử của Date,"Để thay đổi giá trị các phần tử của Date trong JavaScript, bạn sử dụng một trong các phương thức sau đây:
`setFullYear(year, [month], [date])` `setMonth(month, [date])` `setDate(date)` `setHours(hour, [min], [sec], [ms]` `setMinutes(min, [sec], [ms])` `setSeconds(sec, [ms])` `setMilliseconds(ms)` `setTime(milliseconds)` Tất cả các phương thức trên - ngoại trừsetTime(), đều có dạngUTC, ví dụ:setUTCHours().
`setTime()` `UTC` `setUTCHours()` Và một số phương thức bên trên có nhiều tham số. Trong đó, tham số đầu tiên là bắt buộc, các tham số sau nếu không set thì bỏ qua, ví dụsetHours(hour, [min], [sec], [ms]).
`setHours(hour, [min], [sec], [ms])` 
```js
let today = new Date();
console.log(today); // thời gian hiện tại

today.setHours(0);
console.log(today); // ngày hiện tại, nhưng giờ được set thành 0

today.setHours(0, 0, 0, 0);
console.log(today); // ngày hiện tại, nhưng giờ, phút, giây, mili giây đều = 0
```
`let today = new Date();
console.log(today); // thời gian hiện tại

today.setHours(0);
console.log(today); // ngày hiện tại, nhưng giờ được set thành 0

today.setHours(0, 0, 0, 0);
console.log(today); // ngày hiện tại, nhưng giờ, phút, giây, mili giây đều = 0`"
145,Đối tượng Date trong Javascript,Tự động điều chỉnh date,"Đối tượng Date trong JavaScript có một tính năng khá hữu ích đó là:tự động điều chỉnh thời gian, ví dụ:

```js
let date = new Date(2021, 0, 32); // 32/01/2021 - ngày không hợp lệ
console.log(date); // tự động điều chỉnh thành 01/02/2021!
```
`let date = new Date(2021, 0, 32); // 32/01/2021 - ngày không hợp lệ
console.log(date); // tự động điều chỉnh thành 01/02/2021!` Tham số truyền vào vượt ngoài giá trị cho phép của ngày, tháng, năm,... được tự động điều chỉnhtăng hoặc giảm.
Giả sử, bạn muốn tăng từ ngày 28/02/2021 lên2 ngày. Bạn không chắc đó là ngày 01/03/2021 hay 02/03/2021. Vì bạn không rõ năm 2021 có phải lànăm nhuận hay không.
Với đối tượng Date trong JavaScript, bạn chỉ cần cộng thêm 2 ngày. JavaScript engine sẽ xử lý cho bạn.

```js
let date = new Date(2021, 1, 28);
date.setDate(date.getDate() + 2);

console.log(date); // Tue Mar 02 2021 00:00:00 GMT+0700 (Indochina Time)
```
`let date = new Date(2021, 1, 28);
date.setDate(date.getDate() + 2);

console.log(date); // Tue Mar 02 2021 00:00:00 GMT+0700 (Indochina Time)` Tính năng này còn được áp dụng để lấy Date sau một khoảng thời gian. Ví dụ lấy thông tin Date sau khoảng thời gian80 giâytính từ hiện tại:

```js
let date = new Date();
console.log(date); // Sun Dec 19 2021 10:50:50 GMT+0700 (Indochina Time)

date.setSeconds(date.getSeconds() + 80);
console.log(date); // Sun Dec 19 2021 10:52:10 GMT+0700 (Indochina Time)
```
`let date = new Date();
console.log(date); // Sun Dec 19 2021 10:50:50 GMT+0700 (Indochina Time)

date.setSeconds(date.getSeconds() + 80);
console.log(date); // Sun Dec 19 2021 10:52:10 GMT+0700 (Indochina Time)` Ngoài ra, bạn có thể truyền tham số là0hoặcsố âm. Khi đó, thời gian được lấy lùi lại quá khứ:
`0` 
```js
let date = new Date(2021, 0, 2); // 02/01/2021

date.setDate(1); // set ngày của tháng thành mùng 1
console.log(date); // 01/01/2021

date.setDate(0); // set ngày của tháng bằng 0 => ngày cuối cùng của tháng trước
console.log(date); // 31/12/2020
```
`let date = new Date(2021, 0, 2); // 02/01/2021

date.setDate(1); // set ngày của tháng thành mùng 1
console.log(date); // 01/01/2021

date.setDate(0); // set ngày của tháng bằng 0 => ngày cuối cùng của tháng trước
console.log(date); // 31/12/2020`"
146,Đối tượng Date trong Javascript,Chuyển Date về number,"Khi đối tượng Date trong JavaScript được chuyển đổi về dạng số,Datesẽ trở thànhtimestamp, giống như cách sử dụngdate.getTime().
`Date` `date.getTime()` 
```js
let date = new Date();
console.log(+date); // 1639886372852
console.log(date.getTime()); // 1639886372852
```
`let date = new Date();
console.log(+date); // 1639886372852
console.log(date.getTime()); // 1639886372852` Ngoài ra, bạn có thểtrừhai giá trị Date trong JavaScript cho nhau. Kết quả trả về làsố mili giây chênh lệch.
Tính năng này được áp dụng để tính thời gian của một tác vụ:

```js
// bắt đầu tính thời gian
let start = new Date();

// bắt đầu tác vụ
for (let i = 0; i < 1000000; i++) {
  let doSomething = i * i * i;
}

// kết thúc tính thời gian
let end = new Date();

// Tổng thời gian thực hiện vòng lặp là:
console.log(`${end - start} ms`); // 3 ms
```
`// bắt đầu tính thời gian
let start = new Date();

// bắt đầu tác vụ
for (let i = 0; i < 1000000; i++) {
  let doSomething = i * i * i;
}

// kết thúc tính thời gian
let end = new Date();

// Tổng thời gian thực hiện vòng lặp là:
console.log(`${end - start} ms`); // 3 ms`"
147,Đối tượng Date trong Javascript,Date.now trong JavaScript,"Nếu chỉ cần tính thời gian của một tác vụ, bạn không cần thiết phải khởi tạo đối tượngDate. Thay vào đó, bạn có thể dùng phương thứcDate.now()để trả về giá trị timestamp hiện tại.
`Date` `Date.now()` Phương thứcDate.now()về cơ bản là giốngnew Date().getTime(). Tuy nhiên,Date.now()không cần khởi tạo đối tượngDatemới, nên phương thức này không ảnh hưởng tới quá trìnhgarbage collection.
`Date.now()` `new Date().getTime()` `Date.now()` `Date` 
```js
// bắt đầu tính thời gian
let start = Date.now();
// bắt đầu tác vụ
for (let i = 0; i < 1000000; i++) {
  let doSomething = i * i * i;
}

// kết thúc tính thời gian
let end = Date.now();
// Tổng thời gian thực hiện vòng lặp là:
console.log(`${end - start} ms`); // 3 ms
```
`// bắt đầu tính thời gian
let start = Date.now();
// bắt đầu tác vụ
for (let i = 0; i < 1000000; i++) {
  let doSomething = i * i * i;
}

// kết thúc tính thời gian
let end = Date.now();
// Tổng thời gian thực hiện vòng lặp là:
console.log(`${end - start} ms`); // 3 ms` các cách tính thời gian vớiDatetrên có độ chính xác cao nhất là1 ms.
`Date` `1 ms` Nếu bạn cần độ chính xác cao hơn thì bạn có thể dùng phương thứcperformance.now().
`performance.now()` 
```js
// bắt đầu tính thời gian
let start = performance.now();
// bắt đầu tác vụ
for (let i = 0; i < 1000000; i++) {
  let doSomething = i * i * i;
}

// kết thúc tính thời gian
let end = performance.now();
// Tổng thời gian thực hiện vòng lặp là:
console.log(`${end - start} ms`); // 2.7000000029802322 ms
```
`// bắt đầu tính thời gian
let start = performance.now();
// bắt đầu tác vụ
for (let i = 0; i < 1000000; i++) {
  let doSomething = i * i * i;
}

// kết thúc tính thời gian
let end = performance.now();
// Tổng thời gian thực hiện vòng lặp là:
console.log(`${end - start} ms`); // 2.7000000029802322 ms`"
148,Đối tượng Date trong Javascript,Date.parse trong JavaScript,"Bạn có thể dùng phương thứcDate.parse(string)để parse date trong JavaScript từ mộtstring.
`Date.parse(string)` `string` Định dạng Date đầy đủ với string là:YYYY-MM-DDTHH:mm:ss.sssZ.
`YYYY-MM-DDTHH:mm:ss.sssZ` Trong đó:
`YYYY-MM-DD` `T` `HH:mm:ss.sss` `Z` `+-hh:mm` `Z` Định dạng date ngắn gọn hơn có thể là:YYYY-MMMM-DD,YYYY-MMhoặc thậm chí làYYYY,...
`YYYY-MMMM-DD` `YYYY-MM` `YYYY` Phương thứcDate.parse(str)sẽ parse string ở định dạng tương ứng và trả về giá trị timestamp, nếu định dạng hoặc giá trị không hợp lệ thì trả vềNaN, ví dụ:
`Date.parse(str)` `NaN` 
```js
let ms = Date.parse(""2012-12-19T11:30:50.217+07:00"");
console.log(ms); // 1355891450217  (timestamp)
```
`let ms = Date.parse(""2012-12-19T11:30:50.217+07:00"");
console.log(ms); // 1355891450217  (timestamp)` Bạn có thể tạo luôn đối tượngDatemới từ timestamp như sau:
`Date` 
```js
let date = new Date(Date.parse(""2021-12-19T11:30:50.217+07:00""));
console.log(date); // Sun Dec 19 2021 11:30:50 GMT+0700 (Indochina Time)
```
`let date = new Date(Date.parse(""2021-12-19T11:30:50.217+07:00""));
console.log(date); // Sun Dec 19 2021 11:30:50 GMT+0700 (Indochina Time)`"
149,Đối tượng Date trong Javascript,Tổng kết,"Date trong JavaScript được biểu diễn bởi đối tượngDate, trong đó:
`Date` `0` `11` `0` `6` Đối tượngDatecó tính năng tự động điều chỉnhtăng hay giảmnếu giá trị truyền vào vượt quá phạm vi biểu diễn của ngày, tháng, năm,... Tính năng này đặc biệt hữu ích khi bạn muốn cộng/trừ với ngày/tháng/giờ,...
`Date` Ngoài ra, bạn có thểtrừ hai giá trị datecho nhau, kết quả trả về làsố mili giây chênh lệch. Bởi vì,Datetrở thànhtimestampkhi chuyển thànhnumber.
`Date` Phương thứcDate.now()trả về timestamp hiện tại mà không cần tạo mới đối tượngDate.
`Date.now()` `Date`"
150,Đối tượng Date trong Javascript,Thực hành,"Tạo đối tượngDatebởi thời gianFeb 20, 2021, 11:12amvới múi giờ của bạn.
`Date` Xem đáp án
Bạn có thể sử dụng hàm khởi tạonew Date(year, month, date, hour, minute)với:
`new Date(year, month, date, hour, minute)` `year` `month` `1` `date` `hour` `minute` 
```js
let date = new Date(2021, 1, 20, 11, 12);
console.log(date); // Sat Feb 20 2021 11:12:00 GMT+0700 (Indochina Time)
```
`let date = new Date(2021, 1, 20, 11, 12);
console.log(date); // Sat Feb 20 2021 11:12:00 GMT+0700 (Indochina Time)` Viết hàmgetWeekDay(date)trả về ngày trong tuần dạng rút gọn:SU(chủ nhật),MO(thứ hai),TU(thứ 3),WE(thứ 4),TH(thứ 5),FR(thứ 6),SA(thứ 7).
`getWeekDay(date)` `SU` `MO` `TU` `WE` `TH` `FR` `SA` Xem đáp án
Phương thứcdate.getDay()trả về các ngày trong tuần bắt đầu từ0(chủ nhật) đến6(thứ 7) - giống với chỉ số của mảng.
`date.getDay()` `0` `6` Vì vậy, bạn có thể tạo mảng string chứa thông tin các ngày trong tuần. Rồi sau đó, bạn lấy kết quả củadate.getDay()làm chỉ số để truy cập giá trị của mảng.
`date.getDay()` 
```js
function getWeekDay(date) {
  let weekDays = [""SU"", ""MO"", ""TU"", ""WE"", ""TH"", ""FR"", ""SA""];
  return weekDays[date.getDay()];
}

let date = new Date(2021, 1, 1); // 01/01/2021
console.log(getWeekDay(date)); // MO
```
`function getWeekDay(date) {
  let weekDays = [""SU"", ""MO"", ""TU"", ""WE"", ""TH"", ""FR"", ""SA""];
  return weekDays[date.getDay()];
}

let date = new Date(2021, 1, 1); // 01/01/2021
console.log(getWeekDay(date)); // MO` Viết hàmgetDateAgo(date, days)trả về ngày trong tháng vớidaysngày trước ngàydate.
`getDateAgo(date, days)` `days` `date` Ví dụ hôm nay là ngày 19/12/2021. Khi đó, 1 ngày trước ngày hiện tại là ngày 18/12/2021.
Chú ý: hàmgetDateAgokhông làm thay đổi giá trị của tham sốdatetruyền vào.
`getDateAgo` `date` Xem đáp án

```js
function getDateAgo(date, days) {
  // khởi tạo biến dateAgo bằng với date hiện tại
  // để không làm thay đổi giá trị của tham số date
  let dateAgo = new Date(date.getTime());

  // lùi về số ngày là: days
  dateAgo.setDate(dateAgo.getDate() - days);

  // trả về giá trị ngày trong tháng
  return dateAgo.getDate();
}

// ví dụ ngày hôm nay
let toDay = new Date();

// hôm qua
let yesterday = getDateAgo(toDay, 1);
console.log(yesterday); // 18

// ngày này năm trước
let lastYear = getDateAgo(toDay, 365);
console.log(lastYear); // 19
```
`function getDateAgo(date, days) {
  // khởi tạo biến dateAgo bằng với date hiện tại
  // để không làm thay đổi giá trị của tham số date
  let dateAgo = new Date(date.getTime());

  // lùi về số ngày là: days
  dateAgo.setDate(dateAgo.getDate() - days);

  // trả về giá trị ngày trong tháng
  return dateAgo.getDate();
}

// ví dụ ngày hôm nay
let toDay = new Date();

// hôm qua
let yesterday = getDateAgo(toDay, 1);
console.log(yesterday); // 18

// ngày này năm trước
let lastYear = getDateAgo(toDay, 365);
console.log(lastYear); // 19` Viết hàmgetLastDayOfMonth(year, month)trả về ngày cuối cùng của tháng, trong đó:
`getLastDayOfMonth(year, month)` `year` `month` `0` `11` Xem đáp án

```js
function getLastDayOfMonth(year, month) {
  // lấy date ứng với ngày đầu tiên của tháng tiếp theo
  let date = new Date(year, month + 1);

  // giảm date đi 1 đơn vị để lấy ngày cuối cùng của tháng hiện tại
  date.setDate(date.getDate() - 1);

  // trả về date
  return date.getDate();
}

console.log(getLastDayOfMonth(2021, 0)); // 31 - tháng 1
console.log(getLastDayOfMonth(2021, 1)); // 28 - tháng 2
console.log(getLastDayOfMonth(2021, 2)); // 31 - tháng 3
console.log(getLastDayOfMonth(2021, 3)); // 30 - tháng 4
console.log(getLastDayOfMonth(2021, 4)); // 31 - tháng 5
console.log(getLastDayOfMonth(2021, 5)); // 30 - tháng 6
console.log(getLastDayOfMonth(2021, 6)); // 31 - tháng 7
console.log(getLastDayOfMonth(2021, 7)); // 31 - tháng 8
console.log(getLastDayOfMonth(2021, 8)); // 30 - tháng 9
console.log(getLastDayOfMonth(2021, 9)); // 31 - tháng 10
console.log(getLastDayOfMonth(2021, 10)); // 30 - tháng 11
console.log(getLastDayOfMonth(2021, 11)); // 31 - tháng 12
```
`function getLastDayOfMonth(year, month) {
  // lấy date ứng với ngày đầu tiên của tháng tiếp theo
  let date = new Date(year, month + 1);

  // giảm date đi 1 đơn vị để lấy ngày cuối cùng của tháng hiện tại
  date.setDate(date.getDate() - 1);

  // trả về date
  return date.getDate();
}

console.log(getLastDayOfMonth(2021, 0)); // 31 - tháng 1
console.log(getLastDayOfMonth(2021, 1)); // 28 - tháng 2
console.log(getLastDayOfMonth(2021, 2)); // 31 - tháng 3
console.log(getLastDayOfMonth(2021, 3)); // 30 - tháng 4
console.log(getLastDayOfMonth(2021, 4)); // 31 - tháng 5
console.log(getLastDayOfMonth(2021, 5)); // 30 - tháng 6
console.log(getLastDayOfMonth(2021, 6)); // 31 - tháng 7
console.log(getLastDayOfMonth(2021, 7)); // 31 - tháng 8
console.log(getLastDayOfMonth(2021, 8)); // 30 - tháng 9
console.log(getLastDayOfMonth(2021, 9)); // 31 - tháng 10
console.log(getLastDayOfMonth(2021, 10)); // 30 - tháng 11
console.log(getLastDayOfMonth(2021, 11)); // 31 - tháng 12` Viết hàmgetSecondsDay()trả về số giây đã qua của ngày hôm nay.
`getSecondsDay()` Xem đáp án

```js
function getSecondsDay() {
  // lấy thời điểm hiện tại
  let nowDate = new Date();

  // lấy thời điểm 0 giờ 0 phút 0 giây của ngày hiện tại
  let beginingDate = new Date(
    nowDate.getFullYear(),
    nowDate.getMonth(),
    nowDate.getDate()
  );

  return Math.round((nowDate - beginingDate) / 1000);
}

console.log(getSecondsDay());
```
`function getSecondsDay() {
  // lấy thời điểm hiện tại
  let nowDate = new Date();

  // lấy thời điểm 0 giờ 0 phút 0 giây của ngày hiện tại
  let beginingDate = new Date(
    nowDate.getFullYear(),
    nowDate.getMonth(),
    nowDate.getDate()
  );

  return Math.round((nowDate - beginingDate) / 1000);
}

console.log(getSecondsDay());` Viết hàmgetSecondsToTomorrow()trả về số giây từ hiện tại cho đến ngày mai.
`getSecondsToTomorrow()` Xem đáp án

```js
function getSecondsToTomorrow() {
  // thời điểm hiện tại
  let nowDate = new Date();

  // 0 giờ, 0 phút, 0 giây ngày tiếp theo
  let tomorrowDate = new Date(
    nowDate.getFullYear(),
    nowDate.getMonth(),
    nowDate.getDate() + 1
  );

  return Math.round((tomorrowDate - nowDate) / 1000);
}
ư;

console.log(getSecondsToTomorrow());
```
`function getSecondsToTomorrow() {
  // thời điểm hiện tại
  let nowDate = new Date();

  // 0 giờ, 0 phút, 0 giây ngày tiếp theo
  let tomorrowDate = new Date(
    nowDate.getFullYear(),
    nowDate.getMonth(),
    nowDate.getDate() + 1
  );

  return Math.round((tomorrowDate - nowDate) / 1000);
}
ư;

console.log(getSecondsToTomorrow());` Tham khảo:Date and time"
151,Đối tượng global trong Javascript,Giới thiệu,"Bài viết này giúp bạn tìm hiểu về đối tượng global trong JavaScript. Qua đây, bạn biết khi nào nên sử dụng đối tượng global."
152,Đối tượng global trong Javascript,Đối tượng global là gì?,"Đối tượng global trong JavaScriptcung cấp các biến và hàm được sử dụng ở mọi nơi trong chương trình.
`window` `global` Gần đây, đối tượngglobalThismới được thêm vào JavaScript. Đây là tên chuẩn được dùng cho đối tượng global ở tất cả các môi trường và tất cả các trình duyệt khác nhau.
`globalThis` Chú ý:
trong bài viết này, mình chủ yếu dùngwindowkhi nói về đối tượng global trong JavaScript.
`window` Vì mình giả sử rằng, bạn đang đọc và thử nghiệm code ngay trênDev Toolcủa trình duyệt. Nếu bạn chạy code trên môi trường khác thì có thể thay thếwindowbằngglobalThis.
`window` `globalThis` Tất cả các thuộc tính của đối tượng global trong JavaScript có thể được truy cập ở mọi nơi:

```js
console.log(""Hello"");

// tương đương với
window.console.log(""Hello"");
```
`console.log(""Hello"");

// tương đương với
window.console.log(""Hello"");` Trên trình duyệt, hàm và biến toàn cục được khai báo vớivar(không phảilet/const) đều trở thành thuộc tính của global object:
`var` `let/const` 
```js
// khai báo biến với var
var gVar = 6;
console.log(window.gVar); // 6
// gVar trở thành thuộc tính của đối tượng global

// khai báo hàm với function
function sayHi() {
  console.log(""Hi!"");
}
window.sayHi(); // Hi!
// hàm sayHi cũng trở thành thuộc tính của window
```
`// khai báo biến với var
var gVar = 6;
console.log(window.gVar); // 6
// gVar trở thành thuộc tính của đối tượng global

// khai báo hàm với function
function sayHi() {
  console.log(""Hi!"");
}
window.sayHi(); // Hi!
// hàm sayHi cũng trở thành thuộc tính của window` Nếu bạn sử dụngletđể khai báo biến thì biến đó không trở thành thuộc tính của đối tượng global trong JavaScript:
`let` 
```js
// khai báo biến với let
let gLet = 6;
console.log(window.gLet); // undefined
```
`// khai báo biến với let
let gLet = 6;
console.log(window.gLet); // undefined` Nếu một biến quan trọng và bạn thật sự muốn sử dụng biến đó ở mọi nơi trong chương trình. Bạn nên chủ động gán biến đó vào đối tượng global như sau:

```js
// tạo đối tượng global: currentUser
window.currentUser = {
  name: ""Alex"",
};

// sử dụng ở nơi nào đó trong code
console.log(currentUser.name); // Alex

// hoặc nếu bạn có biến cục bộ nào đó trùng tên
// bạn nên chủ động gọi thông qua window
console.log(window.currentUser.name); // Alex
```
`// tạo đối tượng global: currentUser
window.currentUser = {
  name: ""Alex"",
};

// sử dụng ở nơi nào đó trong code
console.log(currentUser.name); // Alex

// hoặc nếu bạn có biến cục bộ nào đó trùng tên
// bạn nên chủ động gọi thông qua window
console.log(window.currentUser.name); // Alex` Nhìn chung, bạn không nên sử dụng biến toàn cục. Việc sử dụng biến toàn cục nhiều sẽ khiến bạn khó theo dõi logic code khi số lượng code bắt đầu nhiều lên."
153,Đối tượng global trong Javascript,Sử dụng polyfills,"Bạn có thể sử dụng global object để kiểm tra xem một tính năng có đang được hỗ trợ hay không.
Ví dụ, bạn muốn kiểm tra đối tượngPromisecó tồn tại trênwindowhay không (chú ý đối tượngPromisekhông tồn tại ở trình duyệt cũ):
`Promise` `window` `Promise` 
```js
if (!window.Promise) {
  console.log(""You're using an old browser!"");
}
```
`if (!window.Promise) {
  console.log(""You're using an old browser!"");
}` Nếu đối tượngPromisethật sự không tồn tại trênwindow, bạn có thể tạopolyfillsđể thay thếPromise. Việc này giúp code của bạn hoạt động được trên các phiên bản trình duyệt khác nhau:
`Promise` `window` `Promise` 
```js
if (!window.Promise) {
  window.Promise = ... // triển khai Promise nếu trình duyệt chưa hỗ trợ
}
```
`if (!window.Promise) {
  window.Promise = ... // triển khai Promise nếu trình duyệt chưa hỗ trợ
}`"
154,Đối tượng global trong Javascript,Tổng kết,"Đối tượng global chứa các biến và hàm có thể sử dụng ở mọi nơi trong chương trình. Bao gồm các kiểu dữ liệu đặc biệt và có sẵn nhưArray,Map,Set,... và một số giá trị của môi trường nhưwindow.innerHeight- chiều cao của window trên trình duyệt...
`Array` `Map` `Set` `window.innerHeight` Gần đây, đối tượngglobalThisđược thêm vào JavaScript, trở thành tên tiêu chuẩn cho đối tượng global. Đối tượngglobalThistồn tại trên các môi trường khác nhau và các trình duyệt khác nhau.
`globalThis` `globalThis` Tuy nhiên, có thể mọi người vẫn hay sử dụng tên cũ hơn, đó làwindowtrên trình duyệt vàglobaltrong Node.js.
`window` `global` Trên trình duyệt, trừ khi bạn đangsử dụng module, các hàm và biến toàn cục được khai báo vớivarđều trở thành thuộc tính của đối tượng global.
`var` Để code dễ hiểu hơn, khi truy cập vào các thuộc tính của đối tượng global, bạn nên chủ động sử dụng đối tượng global, ví dụwindow.x.
`window.x` Nhìn chung, bạn nên hạn chế sử dụng biến toàn cục. Vì sử dụng biến toàn cục khiến logic chương trình trở nên khó theo dõi và khó debug khi có lỗi xảy ra.
Hãy chỉ sử dụng đối tượng global trong JavaScript khi thực sự cần thiết.
Tham khảo:Global object"
155,DOM là gì? Tìm hiểu về DOM,Giới thiệu,"Những bài viết trước, mình đã giới thiệu với bạn kiến thức cơ bản về mặtngôn ngữcủaJavaScript. Bài viết này mình sẽ giới thiệu sự liên kết của JavaScript với trình duyệt. Và cái đầu tiên mà mình muốn nói đến, chính làDOM. Vậy DOM là gì? Cách sử dụng DOM trong JavaScript thế nào? Sau đây là câu trả lời."
156,DOM là gì? Tìm hiểu về DOM,DOM là gì?,"DOM là viết tắt của Document Object Model - một thành phần javascript cơ bản. Hiểu đơn giản thì DOM trong JavaScript chính là những phần tử biểu diễn cấu trúc dữ liệu của một trang web.
Hãy xem xét một ví dụ đơn giản sau:

```js
<!DOCTYPE html>
<html>
  <head>
    <title>My home page</title>
  </head>
  <body>
    <h1>My home page</h1>
    <p>Hello, I am Marijn and this is my home page.</p>
    <p>
      I also wrote a book! Read it
      <a href=""https://kungfutech.edu.vn"">here</a>.
    </p>
  </body>
</html>
```
`<!DOCTYPE html>
<html>
  <head>
    <title>My home page</title>
  </head>
  <body>
    <h1>My home page</h1>
    <p>Hello, I am Marijn and this is my home page.</p>
    <p>
      I also wrote a book! Read it
      <a href=""https://kungfutech.edu.vn"">here</a>.
    </p>
  </body>
</html>` Đây là cấu trúc đơn giản của một trang web.
Ở đây, mỗi hình vuông cùng với nội dung bên trong nó chính là DOM."
157,DOM là gì? Tìm hiểu về DOM,Cấu trúc biểu diễn DOM JavaScript,"Thực tế, cấu trúc dữ liệu của một trang web được biểu diễn dạng cây (tree). Trong đó, mỗi node sẽ tương ứng với một DOM.
Mỗi DOM node sẽ có thuộc tínhnodeType- là một số nguyên - để biểu diễn kiểu của node, với giá trị như sau:
`document.ELEMENT_NODE (1)` `document.TEXT_NODE (3)` `document.COMMENT_NODE (8)` Ví dụ trên được biểu diễn dạng cây:"
158,DOM là gì? Tìm hiểu về DOM,Liên kết giữa các DOM node trong cây,"Mỗi DOM node luôn chứa rất nhiều liên kết đến các DOM node khác.
trỏ đến node cha của một node.
Nếu một node không có node cha (document) thì parentNode là null.
Ví dụ: với mỗi nodepvàh1thìparentNodelàbody.
trỏ đến mộtđối tượnggần giống vớiarray, chứa những node con của một node.
Tại sao lại là ""gần giống với array"" ?
Vì đối tượng này không chứa các method nhưslice,forEach.
Ví dụ: với nodebody,childNodeslà một danh sách với các node con làh1, p, p.
trỏ đến node con đầu tiên của một node trongchildNodes.
Ví dụ: với nodebody,firstChildlàh1.
trỏ đến node con cuối cùng của một node trongchildNodes.
Ví dụ: với nodebody,lastChildlàp(thứ 2).
trỏ đến node liền kề phía trước (có cùngparentNode).
Ví dụ: với nodep(thứ nhất),previousSiblinglàh1.
trỏ đến node liền kề phía sau (có cùngparentNode).
Ví dụ: với nodep(thứ nhất),nextSiblinglà _p _(thứ 2)."
159,DOM là gì? Tìm hiểu về DOM,Một số phương thức phổ biến khi sử dụng DOM,"trả về một danh sách các node con, cháu của một node với tag là 'tagName'.
Ở đây,tagNamecó thể làbody, h1, p, img, ...
Tương tự như phương thức trên, phương phức này trả về một danh sách các node con, cháu của một node với thuộc tính class = 'className'.
trả về node có thuộc tính id = 'id'.
bỏ đi nodechildcủa một node và trả về node bị bỏ đi.
thêm nodechildvào cuối danh sáchchildNodescủa một node.
chèn thêm nodenewNodevào phía trước nodereferenceNode.
thay thế nodeoldChildbằng nodenewChild.
Tạo ra một node kiểu text với giá trị text làdata.
Tạo ra một node mới có kiểu làtagName(h1, h2, p, img, div,...)
Trả về node đầu tiên thoả mãnselectors. Trong đó,selectorslà một string chứa một hay nhiềuCSS-selectorphân cách nhau bằng dấu phẩy.
Trả về danh sách các node thoả mãnselectors, theo thứ tự sử dụng thuật toán DFS."
160,DOM là gì? Tìm hiểu về DOM,Ví dụ sử dụng DOM trong JavaScript,"""Cách học tốt nhất là học từ thực hành"". Sau đây là một số bài tập thực hành sử dụng DOM và các phương thức trên mà mình đã thực hiện (phần đề bài ở trang mà mình đã tham khảo, xem phía dưới).
Tham khảo code tạiđây.
Tham khảo code tạiđây.
Tham khảo code tạiđây."
161,DOM là gì? Tìm hiểu về DOM,Tham khảo,The Document Object Model
162,ES6 Modules trên trình duyệt,Giới thiệu,"Hiện tại,ES Modulesđã đượcsupport bởi khá nhiều các trình duyệt. Điều đó nghĩa là bạn có thể sử dụng ES Modules trực tiếp trên trình duyệt mà không cần phải cài đặt Node.js cùng với các công cụ nhưBrowserify,RequireJS,Webpack,...
Sau đây, mình sẽ tìm hiểu về ES Modules và cách sử dụng nó trực tiếp trên trình duyệt. Mời bạn theo dõi bài viết!"
163,ES6 Modules trên trình duyệt,Cơ bản về ES Modules,"ES Modules (hay còn gọi là ""JavaScript Modules"", ""JS Modules"" hay ""ECMAScript modules"") là một tính năng mới của trình duyệt cho phép bạn làm việc với modules. Nhờ vậy, bạn có thể chia nhỏ chương trình ra thành các modules, với mỗi module có một chức năng riêng biệt.
Trong một module, bạn có thể sử dụng từ khoáexportđể export bất kỳ kiểu dữ liệu nào như: biến số với var, let hay const, class,function,... Sau đó, bạn sử dụng từ khoáimportđể sử dụng chúng ở một file khác.
Sử dụng ES Modules có một số lợi ích như:
Nói vậy thì cách sử dụng ES Modules có gì khác với JavaScript thông thường?"
164,ES6 Modules trên trình duyệt,ES Modules với JavaScript thông thường,"Bởi vì, ES Modules là một tính năng mới (từ ES6) dành cho các trình duyệt hiện đại. Do đó, nó luôn luôn được sử dụng ở chế độStrict mode.
Tiếp theo, comment code theo kiểu HTML không được support ở modules, mặc dù nó vẫn hợp lệ ở JS thông thường. Ví dụ:

```js
/*
* Sử dụng comment kiểu HTML trong JavaScript thông thường,
* không sai, nhưng không nên dùng.
*/
const x = 42; <!-- TODO: Rename x to y.
// Cách sử dụng comment chuẩn
const x = 42; // TODO: Rename x to y.
```
`/*
* Sử dụng comment kiểu HTML trong JavaScript thông thường,
* không sai, nhưng không nên dùng.
*/
const x = 42; <!-- TODO: Rename x to y.
// Cách sử dụng comment chuẩn
const x = 42; // TODO: Rename x to y.` Modules có phạm vi ""lexical top-level"". Nghĩa là khi bạn chạyvar foo = 42;trong modules, JS sẽ không tạo ra một biến ở global với tênfoo. Hay nói cách khác làwindow.foosẽ trả vềundefined.
`var foo = 42;` `window.foo` Cuối cùng, từ khoáexportvàimportchỉ sử dụng được ở modules mà không gọi được ở JavaScript thông thường.
Với những sự khác nhau trên, rõ ràng trình duyệt cần phải phân biệt được: đâu là JavaScript cho ES Modules và đâu là JavaScript thông thường để có thể xử lý cho đúng.
Vì vậy, phần dưới đây sẽ trình bày cách sử dụng ES Modules trên trình duyệt."
165,ES6 Modules trên trình duyệt,Cách sử dụng ES Modules trên trình duyệt,"Để khai báo một script là ES Modules, bạn phải thêmattributecho nó là:type=""module"".
`type=""module""` 
```js
<script type=""module"" src=""main.js""></script>
```
`<script type=""module"" src=""main.js""></script>` Nghĩa là với những trình duyệt hiện đại, nó sẽ hiểu được thuộc tính này. Và trình duyệt sẽ xử lý filemain.jstheo kiểu của module.
Nói vậy, đối với những trình duyệt cũ, không support ES modules thì sao?
Để chương trình có thể chạy được ở cả trình duyệt cũ và mới thì mình phải định nghĩa thêm như này:

```js
<script type=""module"" src=""main.js""></script>
<script nomodule src=""fallback.js""></script>
```
`<script type=""module"" src=""main.js""></script>
<script nomodule src=""fallback.js""></script>` Khi đó, đối với trình duyệt mới (support modules): nó sẽ hiểu thuộc tínhtype=""module""và bỏ quascriptvới thuộc tínhnomodule. Hay nói cách khác, chương trình sẽ nhậnmain.jsvà bỏ quafallback.js.
`type=""module""` Với trình duyệt cũ (không support modules): nó không hiểu thuộc tínhtype=""module""mà chỉ hiểu thuộc tínhtype=""text/javascript""hoặc trường hợp không khai báo thuộc tínhtypethì mặc định vẫn làtype=""text/javascript"". Do đó, chương trình sẽ bỏ quamain.jsvà chỉ nhậnfallback.js.
`type=""module""` `type=""text/javascript""` `type=""text/javascript""` Chú ý:2 filemain.jsvàfallback.jscó ý nghĩa tương đương nhau, chỉ khác nhau về cú pháp, cách viết."
166,ES6 Modules trên trình duyệt,Ví dụ đơn giản về chương trình sử dụng ES Modules,"Mình sẽ demo một chương trình cực kỳ đơn giản sử dụng Modules với các file là:index.html,main.jsvàlib.js.
index.html:

```js
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <meta http-equiv=""X-UA-Compatible"" content=""ie=edge"" />
    <title>Document</title>
  </head>
  <body>
    <script type=""module"" src=""./main.js""></script>
  </body>
</html>
```
`<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <meta http-equiv=""X-UA-Compatible"" content=""ie=edge"" />
    <title>Document</title>
  </head>
  <body>
    <script type=""module"" src=""./main.js""></script>
  </body>
</html>` main.js:

```js
import { repeat, shout } from ""./lib.js"";

console.log(""main.js"");
console.log(repeat(""hello""));
console.log(shout(""Modules in action""));
```
`import { repeat, shout } from ""./lib.js"";

console.log(""main.js"");
console.log(repeat(""hello""));
console.log(shout(""Modules in action""));` lib.js:

```js
export const repeat = (string) => `${string} ${string}`;

export function shout(string) {
  return `${string.toUpperCase()}!`;
}
```
`export const repeat = (string) => `${string} ${string}`;

export function shout(string) {
  return `${string.toUpperCase()}!`;
}` Trong file,index.htmlmình khai báo script vớitype=""module""và nội dung file làmain.js. Tức filemain.jsđóng vai trò là ES Modules. Trong file này, mình có sử dụng từ khoáimportđể import nội dung từ một file modules kháclib.js. Dĩ nhiên, filelib.jscũng là một ES Modules. Trong file này, mình sử dụng từ khoáexportđể export ra 2 hàm chomain.jssử dụng.
`type=""module""` Kết quả hiện thị ra console là:

```js
/*
* => main.js
* => hello hello
* => MODULES IN ACTION
*/
```
`/*
* => main.js
* => hello hello
* => MODULES IN ACTION
*/`"
167,ES6 Modules trên trình duyệt,Cú pháp cơ bản của ES Modules,"Khi sử dụng modules, mình phải quan tâm đến cả phầnexport(tạo modules) vàimport(sử dụng modules). Có 2 kiểu export modules:
Bạn có thể export bất kỳ kiểu dữ liệu nào với từ khoá export đặt trước khai báo biến:

```js
export let x = 1;
export var y = ""a"";
export const z = { x: 1, y: 2 };
export function add(a, b) {
  return a + b;
}
export class Utils {
  print(text) {
    console.log(text);
  }
}
```
`export let x = 1;
export var y = ""a"";
export const z = { x: 1, y: 2 };
export function add(a, b) {
  return a + b;
}
export class Utils {
  print(text) {
    console.log(text);
  }
}` Hoặc gộp chúng vào thành 1objectvới một từ khoáexport:

```js
let x = 1;
var y = ""a"";
const z = { x: 1, y: 2 };
function add(a, b) {
  return a + b;
}
class Utils {
  print(text) {
    console.log(text);
  }
}

export { x, y, z, add, Utils };
```
`let x = 1;
var y = ""a"";
const z = { x: 1, y: 2 };
function add(a, b) {
  return a + b;
}
class Utils {
  print(text) {
    console.log(text);
  }
}

export { x, y, z, add, Utils };` Hoặc cũng có thể đổi tên chúng khi export:

```js
export { x as publicX, y as publicY, z as publicZ, add as sum, Utils as Tools };
```
`export { x as publicX, y as publicY, z as publicZ, add as sum, Utils as Tools };` Mình phải import theo đúng tên đã export:

```js
import { x, y, z, add, Utils } from ""./lib.js"";

console.log(x); // 1
console.log(y); // a
console.log(z); // {x: 1, y: 2}
console.log(add(1, 2)); // 3
console.log(new Utils().print(""hi"")); // hi
```
`import { x, y, z, add, Utils } from ""./lib.js"";

console.log(x); // 1
console.log(y); // a
console.log(z); // {x: 1, y: 2}
console.log(add(1, 2)); // 3
console.log(new Utils().print(""hi"")); // hi` Bên trên, mìnhimporthết tất cả các giá trị. Tuy nhiên, bạn có thể chỉimportnhững thứ cần để sử dụng:
`import` `import` 
```js
import { x, y, z } from ""./lib.js"";

console.log(x); // 1
console.log(y); // a
console.log(z); // {x: 1, y: 2}
```
`import { x, y, z } from ""./lib.js"";

console.log(x); // 1
console.log(y); // a
console.log(z); // {x: 1, y: 2}` Ngoải ra, để tránh trường hợp trùng tên với biến khác, bạn có thểimportvà đồng thời đặt tên mới cho biến:
`import` 
```js
import { x as newX, y as newY, z as newZ } from ""./lib.js"";

console.log(newX); // 1
console.log(newY); // a
console.log(newZ); // {x: 1, y: 2}
```
`import { x as newX, y as newY, z as newZ } from ""./lib.js"";

console.log(newX); // 1
console.log(newY); // a
console.log(newZ); // {x: 1, y: 2}` Hoặc import tất cả các giá trị ứng với một object với tên mới:

```js
import * as myModule from ""./lib.js"";

console.log(myModule.x); // 1
console.log(myModule.y); // a
console.log(myModule.z); // {x: 1, y: 2}
console.log(myModule.add(1, 2)); // 3
console.log(new myModule.Utils().print(""hi"")); // hi
```
`import * as myModule from ""./lib.js"";

console.log(myModule.x); // 1
console.log(myModule.y); // a
console.log(myModule.z); // {x: 1, y: 2}
console.log(myModule.add(1, 2)); // 3
console.log(new myModule.Utils().print(""hi"")); // hi` Lưu ý
Trong trường hợp này, module export và import luôn luôn là một object.
Khác với trường hợp trên, trường hợp này luôn export và import trực tiếp với bất kỳ kiểu giá trị nào. Nghĩa là bạn export function thì khi import cũng là function,...
Vì khi export default, mỗi file sẽ chỉ cho phép export default 1 giá trị, nên mình sẽ lấy ví dụ đồng thời cho cả export và import luôn.

```js
// export ở file lib.js
let x = 1;
export default x;

// import ở file main.js
import variable from ""./lib.js"";
console.log(variable); // 1
```
`// export ở file lib.js
let x = 1;
export default x;

// import ở file main.js
import variable from ""./lib.js"";
console.log(variable); // 1` Khi bạn import, giá trị của variable sẽ tương ứng với giá trị export default. Do đó, variable tương ứng với x, nên có giá trị là 1.

```js
// export ở file lib.js
export default function(a, b) {
  return a + b;
}

// hoặc
function add(a, b) {
  return a + b;
}
export default add;

// import ở file main.js
import func from './lib.js';
console.log(func(1, 2));         // 3
```
`// export ở file lib.js
export default function(a, b) {
  return a + b;
}

// hoặc
function add(a, b) {
  return a + b;
}
export default add;

// import ở file main.js
import func from './lib.js';
console.log(func(1, 2));         // 3` 
```js
// export ở file lib.js
export default class Utils {
  print(text) {
    console.log(text);
  }
}

// hoặc
class Utils {
  print(text) {
    console.log(text);
  }
}
export default Utils;

// import ở file main.js
import Tools from './lib.js';
console.log(new Tools().print(""hi"")); // hi
```
`// export ở file lib.js
export default class Utils {
  print(text) {
    console.log(text);
  }
}

// hoặc
class Utils {
  print(text) {
    console.log(text);
  }
}
export default Utils;

// import ở file main.js
import Tools from './lib.js';
console.log(new Tools().print(""hi"")); // hi` Bên trên, mình ví dụ tách biệt 2 kiểu export, import. Nhưng thực tế, bạn có thể sử dụng kết hợp chúng:

```js
export let x = 1;
export var y = ""a"";
export const z = { x: 1, y: 2 };
export function add(a, b) {
  return a + b;
}
export default class Utils {
  print(text) {
    console.log(text);
  }
}
```
`export let x = 1;
export var y = ""a"";
export const z = { x: 1, y: 2 };
export function add(a, b) {
  return a + b;
}
export default class Utils {
  print(text) {
    console.log(text);
  }
}` Bên trên, mình chỉ export default Utils, còn lại là export thông thường. Khi đó, mình sẽ import như sau:

```js
import Tools, { x, y, z, add } from ""./lib.js"";

console.log(x); // 1
console.log(y); // a
console.log(z); // {x: 1, y: 2}
console.log(add(1, 2)); // 3
console.log(new Tools().print(""hi"")); // hi
```
`import Tools, { x, y, z, add } from ""./lib.js"";

console.log(x); // 1
console.log(y); // a
console.log(z); // {x: 1, y: 2}
console.log(add(1, 2)); // 3
console.log(new Tools().print(""hi"")); // hi` Thực tế, cách import bên trên làstatic. Nghĩa là đoạn code liên quan đến module luôn luôn load ngay từ thời điểm đầu. Tuy nhiên, bạn cũng có thể import theo kiểudynamic. Tức là bạn sẽ chỉ load script khi nào cần thiết.
Ví dụ export:

```js
export let x = 1;
export var y = ""a"";
export const z = { x: 1, y: 2 };
export function add(a, b) {
  return a + b;
}
export class Utils {
  print(text) {
    console.log(text);
  }
}
```
`export let x = 1;
export var y = ""a"";
export const z = { x: 1, y: 2 };
export function add(a, b) {
  return a + b;
}
export class Utils {
  print(text) {
    console.log(text);
  }
}` Khi đó, cách dynamic import là:

```js
setTimeout(async () => {
  let { x, y, z, add, Utils } = await import(""./lib.js"");

  console.log(x); // 1
  console.log(y); // a
  console.log(z); // {x: 1, y: 2}
  console.log(add(1, 2)); // 3
  console.log(new Utils().print(""hi"")); // hi
}, 2000);
```
`setTimeout(async () => {
  let { x, y, z, add, Utils } = await import(""./lib.js"");

  console.log(x); // 1
  console.log(y); // a
  console.log(z); // {x: 1, y: 2}
  console.log(add(1, 2)); // 3
  console.log(new Utils().print(""hi"")); // hi
}, 2000);` Lưu ý
HàmsetTimeouttrên chỉ là ví dụ để thể hiện việc delay khi load module.
Với cáchdynamic importnày,importsẽ trả về một Promise. Do đó, bạn có thể sử dụng kết hợp vớiasync/awaitnhư trên."
168,ES6 Modules trên trình duyệt,Lời kết,"Như vậy là mình đã trình bày xong những kiến thức cơ bản về ES Modules, cũng như cách sử dụng nó ngay trên trình duyệt.
Theo bạn, việc sử dụng ES Modules trực tiếp trên trình duyệt có thực sự cần thiết? Để lại quan điểm của bạn xuống phần bình luận nhé!
Xin chào và hẹn gặp lại, thân ái!
Tham khảo:"
169,ES6 template string trong Javascript,Giới thiệu,"Có thể bạn thừa biết, phiên bản ES6 của JavaScript đã giới thiệu rất nhiều nhữngtính năng hay hấp dẫncủa ngôn ngữ lập trình này. Một trong số đó làTemplate literalshayTemplate String. Nếu vậy thì sử dụng ES6 Template String có gì hay hơn so với string thông thường? Sau đây, mình và bạn sẽ cùng nhau tìm hiểu."
170,ES6 template string trong Javascript,ES6 Template String là gì?,"ES6 Template String tạm gọi là một cú pháp, cho phép bạn viết biểu thức ngay bên trongstring. Trong đó, thay vì sử dụng cặp dấu nháy đơn''hay nháy kép"""", bạn sử dụng cặp dấubacktickhaybackqoute, để biểu diễn string.
`''` `""""` Ví dụ biểu diễn string sử dụng dấu backtick:

```js
`string`;
```
``string`;` Khi đó, biểu thức bên trong template string sẽ được biểu diễn với cú pháp:${expression}, ví dụ:
`${expression}` 
```js
let name = ""Lam Pham"";
let greeting = `I'm ${name}`;

console.log(greeting); // I'm Lam Pham
```
`let name = ""Lam Pham"";
let greeting = `I'm ${name}`;

console.log(greeting); // I'm Lam Pham` Ở ví dụ này, biếnnamebiểu diễn string thông thường và biếngreetingbiểu diễn template string.
`name` `greeting` Đến đây có lẽ bạn đã mường tượng ra cách sử dụng của Template String rồi và đang tự hỏi:vậy thì template string có ưu điểm gì hơn so với việc sử dụng string thông thường không?"
171,ES6 template string trong Javascript,Những ưu điểm nổi bật của ES6 Template String,"Thông thường để ghép nối string trong JavaScript bạn có thể sử dụng phương thứcconcathoặc toán tử+.
`concat` `+` Ví dụ sử dụng phương thứcconcat:
`concat` 
```js
let intro = ""Hello everyone, I'm"";
let firstName = ""Lam"";
let lastName = ""Pham"";

let full1 = intro.concat("" "", firstName, "" "", lastName, ""."");
console.log(full1); // Hello everyone, I'm Lam Pham.
```
`let intro = ""Hello everyone, I'm"";
let firstName = ""Lam"";
let lastName = ""Pham"";

let full1 = intro.concat("" "", firstName, "" "", lastName, ""."");
console.log(full1); // Hello everyone, I'm Lam Pham.` Ví dụ sử dụng toán tử+:
`+` 
```js
let intro = ""Hello everyone, I'm"";
let firstName = ""Lam"";
let lastName = ""Pham"";

let full2 = intro + "" "" + firstName + "" "" + lastName + ""."";
console.log(full2); // Hello everyone, I'm Lam Pham.
```
`let intro = ""Hello everyone, I'm"";
let firstName = ""Lam"";
let lastName = ""Pham"";

let full2 = intro + "" "" + firstName + "" "" + lastName + ""."";
console.log(full2); // Hello everyone, I'm Lam Pham.` Cả hai cách trên đều cho ra kết quả như mong muốn. Tuy nhiên, cách viết lại không trực quan và đôi khi còn khó theo dõi.
Trong khi đó, nếu sử dụng ES6 Template String thì bạn sẽ thấy cách viếtgọn gàng, dễ nhìn và đẹp hơn nhiều.

```js
let intro = ""Hello everyone, I'm"";
let firstName = ""Lam"";
let lastName = ""Pham"";

let full3 = `${intro} ${firstName} ${lastName}.`;
console.log(full3); // Hello everyone, I'm Lam Pham.
```
`let intro = ""Hello everyone, I'm"";
let firstName = ""Lam"";
let lastName = ""Pham"";

let full3 = `${intro} ${firstName} ${lastName}.`;
console.log(full3); // Hello everyone, I'm Lam Pham.` Để sử dụngdấu nháy đơn hoặc nháy képtrong string, bạn có thể sử dụng các cách sau đây:
► Sử dụng kí tự backslash\:
`\` let str = 'I\'m a ""JavaScript Lover"".'; console.log(str); // I'm a ""JavaScript Lover"".
`let str = 'I\'m a ""JavaScript Lover"".'; console.log(str); // I'm a ""JavaScript Lover"".` ► Nếu muốn hiển thịnháy đơn, bạn có thể sử dụngnháy képđể biểu diễn string:
let str = ""I'm Lam Pham.""; console.log(str); // I'm Lam Pham.
`let str = ""I'm Lam Pham.""; console.log(str); // I'm Lam Pham.` ► Nếu muốn hiển thịnháy kép, bạn có thể sử dụngnháy đơnđể biểu diễn string:
let str = 'Call me ""JavaScript Lover""'; console.log(str); // Call me ""JavaScript Lover""
`let str = 'Call me ""JavaScript Lover""'; console.log(str); // Call me ""JavaScript Lover""` Nếu so sánh với những ngôn ngữ khác, việc JavaScript hỗ trợ sử dụngnháy đơn hoặc nháy képđể biểu diễn string đã tiện lợi hơn rất nhiều rồi.
Hơn nữa, khi sử dụng ES6 Template String, bạn chẳng cần phải quan tâm đến vấn đề này nữa, vì bạn đã có cặp dấubacktickrồi.
let str =I'm a ""JavaScript Lover"".; console.log(str); // I'm a ""JavaScript Lover"".
`let str =` `; console.log(str); // I'm a ""JavaScript Lover"".` Với template string, bạn vừa có thể hiển thị dấunháy đơn và dấu nháy képmà không cần sử dụng đến kí tự\.
`\` Thông thường, để viết string trên nhiều dòng, bạn có thể sử dụng kí tự\n-newline.
`\n` 
```js
let str =
  ""Hello everyone!\n"" +
  ""This is line 1 of multiline string example.\n"" +
  ""This is line 2 of multiline string example."";

console.log(str);
/*
    Hello everyone!
    This is line 1 of multiline string example.
    This is line 2 of multiline string example.
    */
```
`let str =
  ""Hello everyone!\n"" +
  ""This is line 1 of multiline string example.\n"" +
  ""This is line 2 of multiline string example."";

console.log(str);
/*
    Hello everyone!
    This is line 1 of multiline string example.
    This is line 2 of multiline string example.
    */` Khi sử dụng ES6 Template String, bạn không cần dùng kí tự đó nữa:

```js
let str = `Hello everyone!
    This is line 1 of multiline string example.
    This is line 2 of multiline string example.`;

console.log(str);
/*
    Hello everyone!
    This is line 1 of multiline string example.
    This is line 2 of multiline string example.
    */
```
`let str = `Hello everyone!
    This is line 1 of multiline string example.
    This is line 2 of multiline string example.`;

console.log(str);
/*
    Hello everyone!
    This is line 1 of multiline string example.
    This is line 2 of multiline string example.
    */` Cách thông thường:

```js
let x = 1;
let y = 2;
let sum = (x, y) => x + y;

console.log(""Sum of x and y is: "" + (x + y)); // Sum of x and y is: 3

console.log(""Sum of x and y is: "" + sum(x, y)); // Sum of x and y is: 3
```
`let x = 1;
let y = 2;
let sum = (x, y) => x + y;

console.log(""Sum of x and y is: "" + (x + y)); // Sum of x and y is: 3

console.log(""Sum of x and y is: "" + sum(x, y)); // Sum of x and y is: 3` Khi sử dụng ES6 Template String:

```js
let x = 1;
let y = 2;
let sum = (x, y) => x + y;

console.log(`Sum of x and y is: ${x + y}`); // Sum of x and y is: 3

console.log(`Sum of x and y is: ${sum(x, y)}`); // Sum of x and y is: 3
```
`let x = 1;
let y = 2;
let sum = (x, y) => x + y;

console.log(`Sum of x and y is: ${x + y}`); // Sum of x and y is: 3

console.log(`Sum of x and y is: ${sum(x, y)}`); // Sum of x and y is: 3`"
172,ES6 template string trong Javascript,Tổng kết,"Sau đây là những kiến thức cần nhớ để sử dụng ES6 template string trong JavaScript:
`+` `concat` `\` Trên đây là một số tính năng mình thấy rất hữu ích của ES6 Template String. Ngoài ra, mình cũng có một số bài viết khác về template string:"
173,FPrototype của hàm trong JavaScript,Giới thiệu,"Trong bài viết vềkhởi tạo object với new trong JavaScript, bạn biết rằng một object có thể được tạo ra bằng cách sử dụng từ khóanewvà hàm khởi tạo, ví dụ:
`new` 
```js
let obj = new F();
```
`let obj = new F();` Và đặc biệt, nếuF.prototypelà một object thì toán tửnewsẽ sử dụng thuộc tính đó để gán cho[[Prototype]]của đối tượng mới.
`F.prototype` `new` `[[Prototype]]` Chú ý:vớiF.prototypethìprototypechính làtên của một thuộc tínhtrongF.
`F.prototype` `prototype` `F` Ví dụ vềF.prototypenhư sau:
`F.prototype` 
```js
let animal = {
  eats: true,
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit(""White Rabbit""); //  rabbit.__proto__ == animal

console.log(rabbit.eats); // true
```
`let animal = {
  eats: true,
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit(""White Rabbit""); //  rabbit.__proto__ == animal

console.log(rabbit.eats); // true` Trong ví dụ trên, câu lệnhRabbit.prototype = animalgán giá trịanimalcho thuộc tínhprototypetrong hàm khởi tạoRabbit.
`Rabbit.prototype = animal` `animal` `prototype` `Rabbit` Điều này có ý nghĩa là: mỗi một đối tượng mới được tạo ra bởinew Rabbitthì đối tượnganimalsẽ được gán cho[[Prototype]]của object.
`new Rabbit` `animal` `[[Prototype]]`"
174,FPrototype của hàm trong JavaScript,Đặc điểm củaF.prototype,"`F.prototype` F.prototypechỉ được sử dụngtại thời điểmgọinew F(). Khi đó, giá trịprototypecủa hàmFsẽ được gán cho[[Prototype]]của object mới.
`F.prototype` `new F()` `prototype` `F` `[[Prototype]]` NếuF.prototypebị thay đổi giá trị thìđối tượng được tạo trước đóvẫn giữ nguyên giá trị[[Prototype]]cũ, ví dụ:
`F.prototype` `[[Prototype]]` 
```js
let animal = {
  eats: true,
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit(""White Rabbit""); //  rabbit.__proto__ == animal
console.log(rabbit.eats); // true

// Thay đổi giá trị của Rabbit.prototypeRabbit.prototype = {  legs: 4,};// prototype của đối tượng rabbit vẫn không đổiconsole.log(rabbit.eats); // trueconsole.log(rabbit.legs); // undefined
```
`let animal = {
  eats: true,
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit(""White Rabbit""); //  rabbit.__proto__ == animal
console.log(rabbit.eats); // true

// Thay đổi giá trị của Rabbit.prototypeRabbit.prototype = {  legs: 4,};// prototype của đối tượng rabbit vẫn không đổiconsole.log(rabbit.eats); // trueconsole.log(rabbit.legs); // undefined`"
175,FPrototype của hàm trong JavaScript,Giá trị mặc định của prototype trong hàm,"Mỗi hàm trong JavaScript đều có thuộc tínhprototypekể cả khi bạn không định nghĩa.
`prototype` Và giá trị mặc định củaprototypelà một object vớimột thuộc tính duy nhấtconstructortrỏ về chínhhàmđó, ví dụ:
`prototype` `constructor` 
```js
function Rabbit() {}

/* prototype mặc định
    Rabbit.prototype = { constructor: Rabbit };
    */

console.log(Rabbit.prototype.constructor === Rabbit);
```
`function Rabbit() {}

/* prototype mặc định
    Rabbit.prototype = { constructor: Rabbit };
    */

console.log(Rabbit.prototype.constructor === Rabbit);` Vì giá trị củaRabbit.prototypesẽ được gán cho[[Prototype]]của mỗi object được tạo ra bởi việc gọinew Rabbit(), nên bạn có thể truy cập vàoconstructortừ mỗi đối tượng:
`Rabbit.prototype` `[[Prototype]]` `new Rabbit()` `constructor` 
```js
function Rabbit() {}
// mặc định:
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit(); // kế thừa prototype từ {constructor: Rabbit}

console.log(rabbit.constructor === Rabbit); // true
```
`function Rabbit() {}
// mặc định:
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit(); // kế thừa prototype từ {constructor: Rabbit}

console.log(rabbit.constructor === Rabbit); // true` Và bạn có thể sử dụng giá trịconstructorđó để khởi tạo đối tượng mới như sau:
`constructor` 
```js
function Rabbit(name) {
  this.name = name;
}

let rabbit = new Rabbit(""White Rabbit"");
console.log(rabbit.name);

let rabbit2 = new rabbit.constructor(""Black Rabbit"");
console.log(rabbit2.name);
```
`function Rabbit(name) {
  this.name = name;
}

let rabbit = new Rabbit(""White Rabbit"");
console.log(rabbit.name);

let rabbit2 = new rabbit.constructor(""Black Rabbit"");
console.log(rabbit2.name);` Tính năng này đặc biệt hữu ích khi bạnkhông biết hàm khởi tạocủa một object (ví dụ đối tượng được tạo ra từ thư viện bên thứ 3).
Lưu ý
JavaScript không đảm bảo giá trị chính xác choconstructor. Thực chất,constructorlà thuộc tính mặc định của mỗi hàm. Nhưng giá trị củaconstructorthì hoàn toàn có thể thay đổi được.
`constructor` `constructor` `constructor` Ví dụ thay đổi giá trị củaprototype:
`prototype` 
```js
function Rabbit() {}
Rabbit.prototype = {
  jumps: true,
};

let rabbit = new Rabbit();
console.log(rabbit.constructor === Rabbit); // false
```
`function Rabbit() {}
Rabbit.prototype = {
  jumps: true,
};

let rabbit = new Rabbit();
console.log(rabbit.constructor === Rabbit); // false` Trong ví dụ trên, giá trị củaprototypeđược gán bằng một object hoàn toàn mới và không chứa thuộc tínhconstructornữa.
`prototype` `constructor` Để giữa lại giá trị mặc định củaconstructor, bạn chỉ cầnthêm/bớtthuộc tính, thay vì gán object mới hoàn toàn choprototypenhư sau:
`constructor` `prototype` 
```js
function Rabbit() {}

// thay vì ghi đè giá trị của prototype, bạn chỉ thêm thuộc tính mới
Rabbit.prototype.jumps = true;

// giá trị mặc định của Rabbit.prototype.constructor không đổi
console.log(Rabbit.prototype.constructor === Rabbit);
```
`function Rabbit() {}

// thay vì ghi đè giá trị của prototype, bạn chỉ thêm thuộc tính mới
Rabbit.prototype.jumps = true;

// giá trị mặc định của Rabbit.prototype.constructor không đổi
console.log(Rabbit.prototype.constructor === Rabbit);` Hoặc chủ động gán lại giá trị cho thuộc tínhconstructor:
`constructor` 
```js
Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit,
};

// prototype được gán bằng object mới,
// nhưng constructor được tạo lại như mặc định
```
`Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit,
};

// prototype được gán bằng object mới,
// nhưng constructor được tạo lại như mặc định`"
176,FPrototype của hàm trong JavaScript,Tổng kết,"Sau đây là những kiến thức cơ bản cần nhớ về prototype của hàm trong JavaScriptF.prototype:
`F.prototype` `F.prototype` `[[Prototype]]` `new F()` `F.prototype` `null` `prototype` `new F()` Trong đối tượng thông thường,prototypechỉ đơn giản là một thuộc tính mà không có ý nghĩa gì đặc biệt:
`prototype` 
```js
let user = {
  name: ""Alex"",
  prototype: ""abc"",
};
```
`let user = {
  name: ""Alex"",
  prototype: ""abc"",
};` Mặc định, mỗi hàm đều cóF.prototype = { constructor: F }. Vì vậy, bạn có thể truy cập đến hàm khởi tạo của mỗi object thông qua giá trị của thuộc tínhconstructor.
`F.prototype = { constructor: F }` `constructor` Tham khảo:F.prototype"
177,Function binding trong Javascript,Giới thiệu,"Khi sử dụngphương thức của objectlàm hàm callback, ví dụ sử dụng với hàmsetTimeout, thường xảy ra vấn đề là: ""mất giá trịthis"".
`setTimeout` `this` Sau đây, mình sẽ cùng tìm hiểu cách sử dụngfunction bindingđể khắc phục tình trạng này."
178,Function binding trong Javascript,Vấn đề mấtthis,"`this` Ví dụ sử dụng hàmsetTimeoutnhư sau:
`setTimeout` 
```js
let user = {
  firstName: ""Alex"",
  sayHi() {
    console.log(`Hello, ${this.firstName}!`);
  },
};

setTimeout(user.sayHi, 1000); // Hello, undefined! (*)
```
`let user = {
  firstName: ""Alex"",
  sayHi() {
    console.log(`Hello, ${this.firstName}!`);
  },
};

setTimeout(user.sayHi, 1000); // Hello, undefined! (*)` Kết quả hiển thị sau 1000ms làHello, undefined!.
`Hello, undefined!` Đó là bởi vì hàmsetTimeoutsử dụng hàmsayHimột cách độc lập với đối tượnguser. Dòng(*)có thể viết lại tương đương là:
`setTimeout` `sayHi` `user` `(*)` 
```js
let func = user.sayHi;
setTimeout(func, 1000); // mất context của `this`
```
`let func = user.sayHi;
setTimeout(func, 1000); // mất context của `this`` Đối với trình duyệt, hàmsetTimeoutgán giá trịthis=windowkhi gọi hàm callback. Vì vậy,this.firstNametrở thànhwindow.firstName. Mà đối tượngwindowkhông chứa thuộc tínhfirstName, dẫn đến kết quả làundefined.
`setTimeout` `this=window` `this.firstName` `window.firstName` `window` `firstName` `undefined` Vậy câu hỏi đặt ra là: làm sao truyền phương thức của object vào phương thức khác mà vẫn giữ nguyên contextthis?
`this`"
179,Function binding trong Javascript,Giải pháp sử dụng hàm wrapper,"Cách đơn giản nhất để tránh mất this làsử dụng hàm wrapper:

```js
let user = {
  firstName: ""Alex"",
  sayHi() {
    console.log(`Hello, ${this.firstName}!`);
  },
};

setTimeout(function () {
  user.sayHi(); // Hello, Alex!
}, 1000);
```
`let user = {
  firstName: ""Alex"",
  sayHi() {
    console.log(`Hello, ${this.firstName}!`);
  },
};

setTimeout(function () {
  user.sayHi(); // Hello, Alex!
}, 1000);` Kết quả hiển thị đã chính xác như mong muốn. Bởi vì khisetTimeoutgọi hàm callback, giá trị củauserđược lấy từ phạm vi bên ngoài, rồi gọi phương thứcsayHicủausernhư bình thường.
`setTimeout` `user` `sayHi` `user` Ngoài ra, bạn có thể sử dụngarrow functioncho ngắn gọn:

```js
setTimeout(() => user.sayHi(), 1000); // Hello, Alex!
```
`setTimeout(() => user.sayHi(), 1000); // Hello, Alex!` Nhìn chung, cách sử dụng hàm wrapper này khá đơn giản và dễ hiểu. Tuy nhiên, cách này lại tiểm ẩn khả năng xảy ra lỗi.
Giả sử, trước khi hàmsetTimeoutgọi hàm callback mà giá trị củauserlại bị thay đổi thì kết quả hiển thị sẽ không đúng như mong đợi:
`setTimeout` `user` 
```js
let user = {
  firstName: ""Alex"",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  },
};

// delay 1 giây
setTimeout(() => user.sayHi(), 1000);

// trong lúc đó, giá trị của `user` thay đổi
user = {
  sayHi() {
    console.log(""User khác được dùng trong setTimeout!"");
  },
};

// User khác được dùng trong setTimeout!
```
`let user = {
  firstName: ""Alex"",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  },
};

// delay 1 giây
setTimeout(() => user.sayHi(), 1000);

// trong lúc đó, giá trị của `user` thay đổi
user = {
  sayHi() {
    console.log(""User khác được dùng trong setTimeout!"");
  },
};

// User khác được dùng trong setTimeout!` Cách thứ hai sau đây sẽ đảm bảo tình trạng này không xảy ra."
180,Function binding trong Javascript,Sử dụng function binding trong JavaScript,"Function trong JavaScript có sẵn một phương thức làbindcho phép không làm thay đổi giá trị củathis, với cú pháp cơ bản như sau:
`bind` `this` 
```js
let boundFunc = func.bind(context);
```
`let boundFunc = func.bind(context);` Kết quả củafunc.bind(context)là mộtđối tượng đặc biệt. Đối tượng này có thể được gọi như hàm và luôn cố định giá trịthis=context, ví dụ:
`func.bind(context)` `this=context` 
```js
let user = {
  firstName: ""Alex"",
};

function func() {
  console.log(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // Alex
```
`let user = {
  firstName: ""Alex"",
};

function func() {
  console.log(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // Alex` Trong ví dụ trên,func.bind(user)cố định giá trị củathis=user.
`func.bind(user)` `this=user` Ngoài ra,func.bindcó thể sử dụng với hàm có tham số như sau:
`func.bind` 
```js
let user = {
  firstName: ""Alex"",
};

function func(message) {
  console.log(message + "", "" + this.firstName);
}

// bind `this` với user
let funcUser = func.bind(user);

funcUser(""Hello""); // Hello, Alex (message=""Hello"" và this=user)
```
`let user = {
  firstName: ""Alex"",
};

function func(message) {
  console.log(message + "", "" + this.firstName);
}

// bind `this` với user
let funcUser = func.bind(user);

funcUser(""Hello""); // Hello, Alex (message=""Hello"" và this=user)` Bây giờ, hãy thử binding function với phương thức của object:

```js
let user = {
  firstName: ""Alex"",
  sayHi() {
    console.log(`Hello, ${this.firstName}!`);
  },
};

let sayHi = user.sayHi.bind(user); // (*)
// có thể gọi hàm mà không cần object
sayHi(); // Hello, Alex!

setTimeout(sayHi, 1000); // Hello, Alex!

// thậm chí là khi giá trị của user thay đổi
// sayHi vẫn tham chiếu tới giá trị user lúc được bind
user = {
  sayHi() {
    console.log(""User đã thay đổi!"");
  },
};
```
`let user = {
  firstName: ""Alex"",
  sayHi() {
    console.log(`Hello, ${this.firstName}!`);
  },
};

let sayHi = user.sayHi.bind(user); // (*)
// có thể gọi hàm mà không cần object
sayHi(); // Hello, Alex!

setTimeout(sayHi, 1000); // Hello, Alex!

// thậm chí là khi giá trị của user thay đổi
// sayHi vẫn tham chiếu tới giá trị user lúc được bind
user = {
  sayHi() {
    console.log(""User đã thay đổi!"");
  },
};` Tại(*), phương thứcuser.sayHiđã bind giá trịthis=user. Kết quả trả về là hàmsayHi- có thể gọi độc lập và giá trịthisluôn bằngusertại thời điểm bind.
`(*)` `user.sayHi` `this=user` `sayHi` `this` `user`"
181,Function binding trong Javascript,Partial function,"Mình mới đề cập tới vấn đề binding function vớithis. Thực tế, bạn có thể thực hiện binding cả tham số. Cú pháp đầy đủ của binding function là:
`this` 
```js
let bound = func.bind(context, [arg1], [arg2],...);
```
`let bound = func.bind(context, [arg1], [arg2],...);` Phương thứcbindcho phép bind giá trịthis=contextvà sau đó là các tham số của hàm.
`bind` `this=context` Ví dụ mình có hàm tính tích hai số như sau:

```js
function mul(a, b) {
  return a * b;
}
```
`function mul(a, b) {
  return a * b;
}` Bây giờ, mình có thể sử dụngbindđể tạo ra hàmnhân đôi:
`bind` 
```js
function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);
console.log(double(3)); // = mul(2, 3) = 6
console.log(double(4)); // = mul(2, 4) = 8
console.log(double(5)); // = mul(2, 5) = 10
```
`function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);
console.log(double(3)); // = mul(2, 3) = 6
console.log(double(4)); // = mul(2, 4) = 8
console.log(double(5)); // = mul(2, 5) = 10` Trong ví dụ trênmul.bind(null, 2)tạo ra hàm mớidoublevới giá trịthis=nullvàa=2. Khi gọi hàm vớidouble, bạn chỉ cần truyền vào giá trị của tham sốb.
`mul.bind(null, 2)` `double` `this=null` `a=2` `double` `b` Cách này gọipartial function.
Lưu ý
hàmdoublekhông sử dụngthis. Tuy nhiên, hàmbindlại yêu cầuthis. Vì vậy, tham số đầu tiên mình đểnull.
`double` `this` `bind` `this` `null` Tương tự, mình có thể tạo ra hàm nhân batriplenhư sau:
`triple` 
```js
function mul(a, b) {
  return a * b;
}

let triple = mul.bind(null, 3);
console.log(triple(3)); // = mul(3, 3) = 9
console.log(triple(4)); // = mul(3, 4) = 12
console.log(triple(5)); // = mul(3, 5) = 15
```
`function mul(a, b) {
  return a * b;
}

let triple = mul.bind(null, 3);
console.log(triple(3)); // = mul(3, 3) = 9
console.log(triple(4)); // = mul(3, 4) = 12
console.log(triple(5)); // = mul(3, 5) = 15` Tại sao lại sử dụng partial function?
Lợi ích của việc sử dụng partial function là mình có các hàm với tên dễ hiểudouble,triple.
`double` `triple` Đồng thời, mình có thể gọi các hàm này một cách độc lập và không cần phải gọi hàmmulvới giá trị tham số đầu tiên luôn luôn cố định bằng2vớidoublehoặc bằng3vớitriple.
`mul` `2` `double` `3` `triple`"
182,Function binding trong Javascript,Partial function không cố định context,"Giả sử mình cần cố định một vài tham số của hàm, ngoại trừ context, ví dụ khi hàm là phương thức của object.
Phương thứcfunc.bindkhông cho phép bạn làm điều đó. Vì bạnkhông thể bỏ qua contextrồi nhảy ngay đến các tham số. Bởi lẽ,func.bindluôn hiểu tham số đầu tiên là context chothis.
`func.bind` `func.bind` `this` Để giải quyết vấn đề này bạn có thể triển khai hàmpartialnhư sau:
`partial` 
```js
function partial(func, ...argsBound) {
  return function (...args) {
    return func.call(this, ...argsBound, ...args);
  };
}
// Sử dụng:
let user = {
  firstName: ""Alex"",
  say(time, message) {
    console.log(`[${time}] ${this.firstName}: ${message}!`);
  },
};

// tạo phương thức partial với giá trị của `time` cố định
user.sayNow = partial(
  user.say,
  new Date().getHours() + "":"" + new Date().getMinutes()
);

user.sayNow(""Hello"");
// Kết quả có dạng như sau: [10:00] Alex: Hello!
```
`function partial(func, ...argsBound) {
  return function (...args) {
    return func.call(this, ...argsBound, ...args);
  };
}
// Sử dụng:
let user = {
  firstName: ""Alex"",
  say(time, message) {
    console.log(`[${time}] ${this.firstName}: ${message}!`);
  },
};

// tạo phương thức partial với giá trị của `time` cố định
user.sayNow = partial(
  user.say,
  new Date().getHours() + "":"" + new Date().getMinutes()
);

user.sayNow(""Hello"");
// Kết quả có dạng như sau: [10:00] Alex: Hello!` Trong ví dụ trên, kết quả của việc gọi hàmpartiallà một hàm wrapper với:
`partial` `this` `user.sayNow` `this=user` `...argsBound` `partial` `""10:00""` `...args` `""Hello""`"
183,Function binding trong Javascript,Tổng kết,"Phương thứcfunc.bind(context, ...args)trả về một hàm đặc biệt với việc cố định giá trịthis=contextvà các tham số đầu tiên (nếu có).
`func.bind(context, ...args)` `this=context` Khi một vài tham số đầu tiên được cố định, thì kết quả trả về được gọi làpartial function.
Partial functions hữu ích khi bạnkhông muốn lặp lại việc truyền các tham số giống nhauở các lần gọi hàm."
184,Function binding trong Javascript,Thực hành,"Cho đoạn code sau, hỏi kết quả trả về là gì?

```js
""use strict"";

function f() {
  console.log(this); // ?
}

let user = {
  g: f.bind(null),
};

user.g();
```
`""use strict"";

function f() {
  console.log(this); // ?
}

let user = {
  g: f.bind(null),
};

user.g();` Kết quả
null
Phương thứcuser.gđược gán bằngf.bind(null). Nghĩa là giá trị củathistrong hàmfluôn lànull.
`user.g` `f.bind(null)` `this` `f` `null` Khi gọibindnhiều lần, giá trị củathiscó thay đổi không?
`bind` `this` 
```js
function f() {
  console.log(this.name);
}

f = f.bind({ name: ""Alex"" }).bind({ name: ""Anna"" });

f(); // (*)
```
`function f() {
  console.log(this.name);
}

f = f.bind({ name: ""Alex"" }).bind({ name: ""Anna"" });

f(); // (*)` Kết quả(*)là gì?
`(*)` Kết quả
Alex
Khi gọif.bind(context), kết quả trả về là một đối tượng đặc biệt. Đối tượng này ghi nhớ giá trị củathis=contexttại thời điểm bind và không thể bị thay đổi.
`f.bind(context)` `this=context` Do đó, lần gọibindthứ hai là không có tác dụng.
`bind` Giả sử hàm có chứa một thuộc tính. Hỏi sau khibind, giá trị của thuộc tính như thế nào?
`bind` 
```js
function sayHi() {
  console.log(this.name);
}

// thuộc tính của hàm
sayHi.test = 5;

// gọi bind
let bound = sayHi.bind({
  name: ""Alex"",
});

console.log(bound.test); // (*)
```
`function sayHi() {
  console.log(this.name);
}

// thuộc tính của hàm
sayHi.test = 5;

// gọi bind
let bound = sayHi.bind({
  name: ""Alex"",
});

console.log(bound.test); // (*)` Kết quả(*)là gì?
`(*)` Kết quả
undefined
Bởi vì kết quả củabindlà một đối tượng khác. Và đối tượng này không chứa thuộc tínhtest.
`bind` `test` Tham khảo:"
185,Function expression trong JavaScript,Giới thiệu,"Trong bài viết trước, mình đã tìm hiểu vềhàm trong JavaScript. Cách khai báo hàm đó gọi là ""function declaration"". Bài viết này mình sẽ tìm hiểu về một khái niệm khác gọi là ""function expression"" hay dịch ra là ""biểu thức hàm""."
186,Function expression trong JavaScript,Function expression trong Javascript là gì?,"Function expression hiểu đơn giản là hàm được định nghĩa trong một biểu thức, ví dụ:

```js
let sayHello = function () {
  console.log(""Hello from kungfutech.edu.vn"");
};
```
`let sayHello = function () {
  console.log(""Hello from kungfutech.edu.vn"");
};` Có thể hiểu là mình khởi tạo một hàm, rồi gán hàm đó cho biếnsayHellogiống như bất kỳ loại giá trị nào khác (number, string, boolean,...). Bạn có thể in ra giá trị biếnsayHello:
`sayHello` `sayHello` 
```js
let sayHello = function () {
  console.log(""Hello from kungfutech.edu.vn"");
};

console.log(sayHello); // ƒ () {
//  console.log(""Hello from kungfutech.edu.vn"");
// }
```
`let sayHello = function () {
  console.log(""Hello from kungfutech.edu.vn"");
};

console.log(sayHello); // ƒ () {
//  console.log(""Hello from kungfutech.edu.vn"");
// }` Kết quả hiển thị ra là một string biểu diễn hàm.
Chú ý: trong câu lệnhconsole.logtrên mình viết làsayHellomà không có cặp dấu ngoặc đơn(). Vì nếu có cặp dấu()thì đó nghĩa làgọi hàm.
`console.log` `sayHello` `()` `()` 
```js
let sayHello = function () {
  console.log(""Hello from kungfutech.edu.vn"");
};

console.log(sayHello()); // Hello from kungfutech.edu.vn
// undefined
```
`let sayHello = function () {
  console.log(""Hello from kungfutech.edu.vn"");
};

console.log(sayHello()); // Hello from kungfutech.edu.vn
// undefined` Kết quả là function expression vớisayHellođược gọi, nên dòng chữHello fromkungfutech.edu.vnđược in ra.
`sayHello` Sau đó là dòngundefined- vì biểu thức hàmsayHellokhông córeturngiá trị nào cả.
`undefined` `sayHello` `return`"
187,Function expression trong JavaScript,Đặc điểm của function expression,"Vì biểu thức hàm cũng là một giá trị, nên bạn hoàn toàn có thể gán nó cho một biến khác, ví dụ:

```js
let sayHello = function () {
  console.log(""Hello from kungfutech.edu.vn"");
};

let sayHi = sayHello;
sayHi(); // Hello from kungfutech.edu.vn
```
`let sayHello = function () {
  console.log(""Hello from kungfutech.edu.vn"");
};

let sayHi = sayHello;
sayHi(); // Hello from kungfutech.edu.vn` Khi đó, bạn gọisayHi()cũng giống như gọisayHello().
`sayHi()` `sayHello()` 📝 Không chỉfunction expressionmàfunction declarationcũng là một giá trị.
Ví dụ:

```js
function sayHello() {
  console.log(""Hello from kungfutech.edu.vn"");
}

let sayHi = sayHello;
sayHi(); // Hello from kungfutech.edu.vn
```
`function sayHello() {
  console.log(""Hello from kungfutech.edu.vn"");
}

let sayHi = sayHello;
sayHi(); // Hello from kungfutech.edu.vn`"
188,Function expression trong JavaScript,Hàm callback,"Vì bản chất hàm là một giá trị, nên bạn có thể truyền hàm vào một hàm khác.
Ví dụ mình cần viết một hàmask(question, handleYes, handleNo)với ba tham số:
`ask(question, handleYes, handleNo)` `question` `handleYes` `yes` `handleNo` `no` Code triển khai hàmasknhư sau:
`ask` 
```js
function ask(question, handleYes, handleNo) {
  const answer = confirm(question);
  if (answer) {
    handleYes();
  } else {
    handleNo();
  }
}

function handleYes() {
  console.log(""Bạn đã chọn Yes!"");
}

function handleNo() {
  console.log(""Bạn đã chọn No!"");
}

ask(""Bạn muốn tiếp tục thực hiện chương trình không?"", handleYes, handleNo);
```
`function ask(question, handleYes, handleNo) {
  const answer = confirm(question);
  if (answer) {
    handleYes();
  } else {
    handleNo();
  }
}

function handleYes() {
  console.log(""Bạn đã chọn Yes!"");
}

function handleNo() {
  console.log(""Bạn đã chọn No!"");
}

ask(""Bạn muốn tiếp tục thực hiện chương trình không?"", handleYes, handleNo);` Trong ví dụ trên,hàm confirmbật ra một hộp thoại hỏi người dùng ""Bạn muốn tiếp tục thực hiện chương trình không?"".
Nếu người dùng chọnOKthì giá trị củaanswerlàtrue. Khi đó, hàmhandleYesđược gọi. Ngược lại, khianswerlàfalsethì hàmhandleNođược gọi.
`answer` `true` `handleYes` `answer` `false` `handleNo` Ở đây, hai tham sốhandleYesvàhandleNogọi làhàm callbackhay gọi tắt làcallback.
`handleYes` `handleNo` 💡 Ý tưởng củahàm callbacklà hàm này được truyền vào hàm khác, để gọi lúc cần thiết.
Liên hệ thực tế như khi bạn gọi điện đến nhà một người bạn. Nhưng người bạn cần tìm không có nhà, mà bạn không thể giữ điện thoại đợi cho đến khi người đó về.
Vì vậy, bạn để lại lời nhắn, kèm số điện thoại để khi nào người đó về sẽ gọi lại cho bạn.
Trong ví dụ trên, mình viết định nghĩa hai hàmhandleYesvàhandleNosử dụng ""function declaration"". Nhưng bạn có thể thay thế bằng biểu thức hàm như sau:
`handleYes` `handleNo` 
```js
function ask(question, handleYes, handleNo) {
  const answer = confirm(question);
  if (answer) {
    handleYes();
  } else {
    handleNo();
  }
}

ask(
  ""Bạn muốn tiếp tục thực hiện chương trình không?"",
  function () {
    console.log(""Bạn đã chọn Yes!"");
  },
  function () {
    console.log(""Bạn đã chọn No!"");
  }
);
```
`function ask(question, handleYes, handleNo) {
  const answer = confirm(question);
  if (answer) {
    handleYes();
  } else {
    handleNo();
  }
}

ask(
  ""Bạn muốn tiếp tục thực hiện chương trình không?"",
  function () {
    console.log(""Bạn đã chọn Yes!"");
  },
  function () {
    console.log(""Bạn đã chọn No!"");
  }
);` Vì thực tế là hai hàmhandleYesvàhandleNochỉ sử dụng bên trong hàmask, nên mình có thể dùng function expression như trên mà không cần khai báo tên hàm.
`handleYes` `handleNo` `ask` 📝 Những hàm như trên còn có tên gọi khác là ""anonymous function"" hay ""hàm ẩn danh""."
189,Function expression trong JavaScript,So sánh function expression với function declaration,"Đọc đến đấy chắc bạn cũng đã khá hiểu về biểu thức hàm rồi phải không?
Sau đây, mình cùng xem những điểm khác nhau giữa biểu thức hàm (function expression) và định nghĩa hàm (function declaration).
► Cú pháp khai báo:
Function declaration: là hàm được định nghĩa độc lập, không nằm trong biểu thức hay câu lệnh nào cả.

```js
function sayHello() {
  console.log(""Hello!"");
}
```
`function sayHello() {
  console.log(""Hello!"");
}` Function expression: là hàm được định nghĩa với một biểu thức, sử dụngtoán tử gán=.
`=` 
```js
let sayHello = function () {
  console.log(""Hello!"");
};
```
`let sayHello = function () {
  console.log(""Hello!"");
};` ► Thời gian khởi tạo:
Function declaration: hàm được xử lý sớm hơn vị trí mà hàm được định nghĩa. Nghĩa là bạn có thể gọi hàm trước khi định nghĩa hàm.

```js
sayHello(); // Hello!

function sayHello() {
  console.log(""Hello!"");
}
```
`sayHello(); // Hello!

function sayHello() {
  console.log(""Hello!"");
}` Function expression: hàm được tạo ra tại thời điểm chương trình thực thi xử lý tới đó. Nghĩa là bạn không thể gọi biểu thức hàm trước khi định nghĩa nó.
Ví dụ sau bị lỗi cú pháp:

```js
sayHello(); // Uncaught ReferenceError: sayHello is not defined

let sayHello = function () {
  console.log(""Hello!"");
};
```
`sayHello(); // Uncaught ReferenceError: sayHello is not defined

let sayHello = function () {
  console.log(""Hello!"");
};` ► Phạm vi của function declaration và function expression:
Khi sử dụngstrict mode, function declaration có phạm vi trongblock. Bạn có thể gọi hàm ở bất kỳ đâu trong block đó, nhưng không sử dụng được ở bên ngoài.
Ví dụ sau bị lỗi cú pháp:

```js
""use strict"";
let isVietnamese = confirm(""Bạn có phải người Việt Nam không?"");

if (isVietnamese) {
  function welcome() {
    console.log(""Chào bạn!"");
  }
} else {
  function welcome() {
    console.log(""Hello!"");
  }
}

welcome(); // Uncaught ReferenceError: welcome is not defined
```
`""use strict"";
let isVietnamese = confirm(""Bạn có phải người Việt Nam không?"");

if (isVietnamese) {
  function welcome() {
    console.log(""Chào bạn!"");
  }
} else {
  function welcome() {
    console.log(""Hello!"");
  }
}

welcome(); // Uncaught ReferenceError: welcome is not defined` Bởi vì hàmwelcomeđược định nghĩa bên trong block củaifnên chỉ dùng được bên trong block đó.
`welcome` `if` Để sử dụng hàmwelcomebên ngoài block, bạn có thể dùng function expression như sau:
`welcome` 
```js
""use strict"";

let isVietnamese = confirm(""Bạn có phải người Việt Nam không?"");
let welcome;
if (isVietnamese) {
  welcome = function () {
    console.log(""Chào bạn!"");
  };
} else {
  welcome = function () {
    console.log(""Hello!"");
  };
}

welcome(); // Không có lỗi
```
`""use strict"";

let isVietnamese = confirm(""Bạn có phải người Việt Nam không?"");
let welcome;
if (isVietnamese) {
  welcome = function () {
    console.log(""Chào bạn!"");
  };
} else {
  welcome = function () {
    console.log(""Hello!"");
  };
}

welcome(); // Không có lỗi` 📝 Dĩ nhiên, đoạn code trên chỉ là ví dụ minh họa. Thực tế, bạn có nhiều cách để giải quyết bài toán này.
Nên viết hàm theo function declaration hay function expression?
Câu trả lời là:tùy bạn.
Tùy thuộc vào phong cách và mục đích của bạn mà lựa chọn cho phù hợp.
Tuy nhiên, theo quan điểm cá nhân thì mình thấy dùngfunction declarationsẽ dễ nhìn hơn. Ngoài ra,function declarationcòn giúp bạn thoải mái hơn trong việc cấu trúc code (không phụ thuộc nhiều vào thứ tự code)."
190,Function expression trong JavaScript,Tổng kết,"Bản chất của hàm làgiá trị. Vì vậy, bạn có thể thoải máigán, sao chép và truyền một hàm vào hàm khácdạng tham số.
Khi một hàm được định nghĩa độc lập thì đó gọi là ""function declaration"". Ngược lại, khi một hàm được định nghĩa bên trong một biểu thức, đó gọi là ""function expression"".
Khi một hàm được truyền vào bên trong hàm khác để gọi lại khi cần thiết, hàm đó được gọi là ""hàm callback"".
Function declarationđược xử lý trước khi chương trình chạy đến đó. Function declaration có phạm vi trong block, nên bạn có thể gọi hàm ở bất kỳ đâu trong block.
Function expressionđược tạo ra tại thời điểm chương trình chạy đến vị trí khởi tạo hàm. Nên bạn chỉ gọi được hàm sau khi đã khởi tạo."
191,Function trong Javascript,Giới thiệu,"Function trong JavaScript cũng là một loại object. Vì vậy, bạn có thểthêm/xóa thuộc tínhvào function hoặctruyền qua hàm khác bởi tham chiếu,...
Sau đây là những kiến thức cơ bản về function object trong JavaScript."
192,Function trong Javascript,Thuộc tínhname,"`name` Function object trong JavaScript có nhiềuthuộc tính hữu ích. Trong đó, thuộc tínhnametrả về tên của hàm:
`name` 
```js
function sayHi() {
  console.log(""Hi"");
}

console.log(sayHi.name); // sayHi
```
`function sayHi() {
  console.log(""Hi"");
}

console.log(sayHi.name); // sayHi` Kể cả khi bạnkhai báo và không đặt tên cho hàmmà gán vào biến khác:

```js
let sayHi = function () {
  console.log(""Hi"");
};

console.log(sayHi.name); // sayHi
```
`let sayHi = function () {
  console.log(""Hi"");
};

console.log(sayHi.name); // sayHi` Hoặc khi phép gán được sử dụng thông qua việcđặt giá trị mặc địnhcho tham số hàm:

```js
function f(sayHi = function () {}) {
  console.log(sayHi.name); // sayHi
}

f();
```
`function f(sayHi = function () {}) {
  console.log(sayHi.name); // sayHi
}

f();` Nhìn chung, khi một hàm không được đặt tên, sau đó phép gán được thực hiện thì giá trị của thuộc tínhnameđược xác định dựa trên ngữ cảnh cụ thể:
`name` 
```js
let user = {
  sayHi() {
    // ...
  },

  sayBye: function () {
    // ...
  },
};

console.log(user.sayHi.name); // sayHi
console.log(user.sayBye.name); // sayBye
```
`let user = {
  sayHi() {
    // ...
  },

  sayBye: function () {
    // ...
  },
};

console.log(user.sayHi.name); // sayHi
console.log(user.sayBye.name); // sayBye` Tuy nhiên, vẫn có những trường hợp không thể xác định được giá trị của thuộc tínhname, ví dụ:
`name` 
```js
// function được tạo ra bên trong mảng
let arr = [function () {}];

console.log(arr[0].name); // string rỗng
// JavaScript Engine không có cách nào để xác định giá trị cho `name`
```
`// function được tạo ra bên trong mảng
let arr = [function () {}];

console.log(arr[0].name); // string rỗng
// JavaScript Engine không có cách nào để xác định giá trị cho `name``"
193,Function trong Javascript,Thuộc tínhlength,"`length` Thuộc tính hữu ích khác của function object trong JavaScript làlength.
`length` Thuộc tínhlengthtrả về số lượng tham số được định nghĩa trong hàm, ví dụ:
`length` 
```js
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

console.log(f1.length); // 1
console.log(f2.length); // 2
console.log(many.length); // 2
```
`function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

console.log(f1.length); // 1
console.log(f2.length); // 2
console.log(many.length); // 2` Trong ví dụ trên, bạn có thể thấy làdấu ba chấm...(dùng để xác định số lượng tham số còn lại của hàm) không được tính vào giá trị củalength.
`...` `length` Giá trị của thuộc tínhlengththường được sử dụng để xử lý trường hợp mà số lượng tham số ảnh hưởng tới cách xử lý của hàm.
`length` Ví dụ hàmasksau đây nhận vào tham số kiểu stringquestion, sau đó là số lượng tùy ý các hàmhandlersđể gọi lại.
`ask` `question` `handlers` Khi người dùng đưa ra câu trả lời, hàmasksẽ gọi lại các hàmhandlersvới hai trường hợp xảy ra là:
`ask` `handlers` Để phân biệt hai trường hợp trên, bạn có thể dùng giá trị của thuộc tínhlengthnhư sau:
`length` 
```js
function ask(question, ...handlers) {
  // dùng hàm confirm để hỏi người dùng
  let isYes = confirm(question);

  // duyệt tất cả các handler sử dụng for...of
  for (let handler of handlers) {
    if (handler.length === 0) {
      // trường hợp hàm handler không có tham số
      if (isYes) handler();
    } else {
      // trường hợp hàm handler có tham số
      handler(isYes);
    }
  }
}

// hàm không tham số được gọi chỉ khi câu trả lời là đồng ý.
// hàm có tham số luôn luôn được gọi.
ask(
  ""Câu hỏi?"",
  () => alert(""Đáp án là yes""), // hàm không tham số
  (result) => alert(`Đáp án là ${result}`) // hàm có tham số
);
```
`function ask(question, ...handlers) {
  // dùng hàm confirm để hỏi người dùng
  let isYes = confirm(question);

  // duyệt tất cả các handler sử dụng for...of
  for (let handler of handlers) {
    if (handler.length === 0) {
      // trường hợp hàm handler không có tham số
      if (isYes) handler();
    } else {
      // trường hợp hàm handler có tham số
      handler(isYes);
    }
  }
}

// hàm không tham số được gọi chỉ khi câu trả lời là đồng ý.
// hàm có tham số luôn luôn được gọi.
ask(
  ""Câu hỏi?"",
  () => alert(""Đáp án là yes""), // hàm không tham số
  (result) => alert(`Đáp án là ${result}`) // hàm có tham số
);`"
194,Function trong Javascript,Thêm thuộc tính vào function object,"Bạn có thể tùy ý thêm thuộc tính vào function object trong JavaScript.
Ví dụ thêm thuộc tínhcountervào hàm để đếm số lần gọi hàm:
`counter` 
```js
function sayHi() {
      console.log(""Hi"");

      // đếm số lần gọi hàm  sayHi.counter++;}

    sayHi.counter = 0; // giá trị mặc định

    sayHi(); // Hi
    sayHi(); // Hi

    console.log(`Hàm sayHi được gọi với số lần là: ${sayHi.counter}`);
    // Hàm sayHi được gọi với số lần là: 2
```
`function sayHi() {
      console.log(""Hi"");

      // đếm số lần gọi hàm  sayHi.counter++;}

    sayHi.counter = 0; // giá trị mặc định

    sayHi(); // Hi
    sayHi(); // Hi

    console.log(`Hàm sayHi được gọi với số lần là: ${sayHi.counter}`);
    // Hàm sayHi được gọi với số lần là: 2` Lưu ý
việc thêm thuộc tính vào hàmkhông định nghĩa thêm biến localtrong phạm vi hàm. Nói cách khác,sayHi.counterkhác vớilet counter.
`sayHi.counter` `let counter` Việc thêm thuộc tính vào hàm đôi khi có thể thay thế đượcclosure.
Ví dụ sử dụng closure như sau:

```js
function makeCounter() {
  // ban đầu counter bằng 0
  let count = 0;

  // trả về một hàm khác
  // hàm này return về counter rồi tăng biến counter lên 1 đơn vị
  return function () {
    return count++;
  };
}

// sử dụng -> counter chính là nested function
let counter = makeCounter();

// sau mỗi lần gọi hàm counter() thì giá trị count tăng lên 1
console.log(counter()); // 0
console.log(counter()); // 1
```
`function makeCounter() {
  // ban đầu counter bằng 0
  let count = 0;

  // trả về một hàm khác
  // hàm này return về counter rồi tăng biến counter lên 1 đơn vị
  return function () {
    return count++;
  };
}

// sử dụng -> counter chính là nested function
let counter = makeCounter();

// sau mỗi lần gọi hàm counter() thì giá trị count tăng lên 1
console.log(counter()); // 0
console.log(counter()); // 1` Thay vào đó, bạn có thể sử dụng thuộc tính của hàm như sau:

```js
function makeCounter() {
  // ban đầu counter bằng 0
  // let count = 0;
  function counter() {
    return counter.count++;
  }
  counter.count = 0;
  return counter;
}

// sử dụng
let counter = makeCounter();

// sau mỗi lần gọi hàm counter() thì giá trị count tăng lên 1
console.log(counter()); // 0
console.log(counter()); // 1
```
`function makeCounter() {
  // ban đầu counter bằng 0
  // let count = 0;
  function counter() {
    return counter.count++;
  }
  counter.count = 0;
  return counter;
}

// sử dụng
let counter = makeCounter();

// sau mỗi lần gọi hàm counter() thì giá trị count tăng lên 1
console.log(counter()); // 0
console.log(counter()); // 1` Về cơ bản thì hai cách trênkhá giống nhau, chỉ khác một chỗ. Với cách sử dụng thuộc tính hàm thì biếncountcó thể được truy cập trực tiếp từ bên ngoài.
`count` 
```js
function makeCounter() {
  function counter() {
    return counter.count++;
  }

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

counter.count = 10;
console.log(counter()); // 10
```
`function makeCounter() {
  function counter() {
    return counter.count++;
  }

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

counter.count = 10;
console.log(counter()); // 10` Nói chung, mỗi cách có một đặc điểm riêng. Tùy thuộc vào mục đích mà bạn quyết định xem nên lựa chọn cách nào."
195,Function trong Javascript,Biểu thức hàm được đặt tên,"Biểu thức hàm được đặt tên, hay tiếng anh làNamed Function Expression- NFE, được hiểu là bạn định nghĩabiểu thức hàmvà đặt tên cho nó.
Ví dụ biểu thức hàm ban đầu như sau:

```js
let sayHi = function (who) {
  console.log(`Hello, ${who}`);
};
```
`let sayHi = function (who) {
  console.log(`Hello, ${who}`);
};` Sau đó, bạn thêm tên cho hàm:

```js
let sayHi = function func(who) {
  console.log(`Hello, ${who}`);
};
```
`let sayHi = function func(who) {
  console.log(`Hello, ${who}`);
};` ►Việc thêm tên hàmfunccó ý nghĩa gì?
`func` Vệc bạn thêm tên hàmfunckhông làm thay đổi cấu trúc hàm. HàmsayHivẫn là biểu thức hàm và vẫn có thể gọi bình thường:
`func` `sayHi` 
```js
let sayHi = function func(who) {
  console.log(`Hello, ${who}`);
};

sayHi(""Alex""); // Hello, Alex
```
`let sayHi = function func(who) {
  console.log(`Hello, ${who}`);
};

sayHi(""Alex""); // Hello, Alex` Thực tế, việc thêm tên cho biểu thức hàm có hai lợi ích là:
Ví dụ, hàmsayHigọi lại chính nó với tham số""Guest""nếu như không truyền tham số vào hàm:
`sayHi` `""Guest""` 
```js
let sayHi = function func(who) {
  if (who) {
    console.log(`Hello, ${who}`);
  } else {
    func(""Guest""); // gọi lại chính nó với tham số ""Guest""  }
  }

  sayHi(); // Hello, Guest

  func(); // Uncaught ReferenceError: func is not defined
};
```
`let sayHi = function func(who) {
  if (who) {
    console.log(`Hello, ${who}`);
  } else {
    func(""Guest""); // gọi lại chính nó với tham số ""Guest""  }
  }

  sayHi(); // Hello, Guest

  func(); // Uncaught ReferenceError: func is not defined
};` ►Tại sao lại sử dụngfunc, trong khi bạn có thể gọi lại hàm thông qua tênsayHi?
`func` `sayHi` 
```js
let sayHi = function func(who) {
  if (who) {
    console.log(`Hello, ${who}`);
  } else {
    sayHi(""Guest""); // gọi lại chính nó với tham số ""Guest""  }
  }

  sayHi(); // Hello, Guest
};
```
`let sayHi = function func(who) {
  if (who) {
    console.log(`Hello, ${who}`);
  } else {
    sayHi(""Guest""); // gọi lại chính nó với tham số ""Guest""  }
  }

  sayHi(); // Hello, Guest
};` Đoạn code trên vẫn hoạt động bình thường. Nhưng vấn đề xảy ra là nếu biếnsayHiđược gán bằng giá trị khác thì việc gọi hàm như trên sẽ bị lỗi:
`sayHi` 
```js
let sayHi = function func(who) {
  if (who) {
    console.log(`Hello, ${who}`);
  } else {
    sayHi(""Guest""); // gọi lại chính nó với tham số ""Guest""  }
  }

  let sayHello = sayHi;
  sayHi = null;
  sayHello(); // Uncaught TypeError: sayHi is not a function
};
```
`let sayHi = function func(who) {
  if (who) {
    console.log(`Hello, ${who}`);
  } else {
    sayHi(""Guest""); // gọi lại chính nó với tham số ""Guest""  }
  }

  let sayHello = sayHi;
  sayHi = null;
  sayHello(); // Uncaught TypeError: sayHi is not a function
};` Lỗi trên xảy ra là vì giá trị củasayHiđược lấy ở phạm vi ngoài hàm. Mà tại thời điểm gọi hàm, giá trị củasayHilànull.
`sayHi` `sayHi` `null` Để giải quyết vấn đề trên, bạn chỉ cần sử dụng tên của biểu thức hàmfuncnhư sau:
`func` 
```js
let sayHi = function func(who) {
  if (who) {
    console.log(`Hello, ${who}`);
  } else {
    func(""Guest""); // gọi lại chính nó với tham số ""Guest""  }
  }

  let sayHello = sayHi;
  sayHi = null;

  sayHello(); // Hello, Guest
};
```
`let sayHi = function func(who) {
  if (who) {
    console.log(`Hello, ${who}`);
  } else {
    func(""Guest""); // gọi lại chính nó với tham số ""Guest""  }
  }

  let sayHello = sayHi;
  sayHi = null;

  sayHello(); // Hello, Guest
};` Đoạn code này không lỗi vìfunclà tên cục bộ trong hàm. Tênfunckhông được nhìn thấy bên ngoài hàm, nhưng bạn có thể gọifuncthoải mái từ trong biểu thức hàm.
`func` `func` `func`"
196,Function trong Javascript,Tổng kết,"Function là một loại object.
Function object trong JavaScript có hai thuộc tính hữu ích là:
`name` `name` `name` `length` `...` Nếu một hàm được định nghĩa bởi biểu thức hàm đi kèm với một tên thì hàm đó gọi làNamed Function ExpressionhayNFE.
Tên của biểu thức hàm có thể được sử dụng để gọi lại tới chính nó, bên trong thân hàm.
Function object trong JavaScript có thể thêm nhiều thuộc tính khác tùy ý."
197,Function trong Javascript,Thực hành,"Viết hàmmakeCounter()thực hiện những yêu cầu sau:
`makeCounter()` `counter()` `count` `count` `counter.set(value)` `value` `counter` `counter.decrease()` `counter` Xem đáp án
Kết hợp closure và thuộc tính của function object trong JavaScript như sau:
`count` `makeCounter` `set` `decrease` 
```js
function makeCounter() {
  // ban đầu counter bằng 0
  let count = 0;

  // trả về một hàm khác
  // hàm này return về counter rồi tăng biến counter lên 1 đơn vị
  return function counter() {
    // 1. hàm set(value) - gán giá trị value cho count
    counter.set = function (value) {
      count = value;
    };

    // 2. hàm decrease() - giảm giá trị của count đi 1 đơn vị
    counter.decrease = function () {
      count--;
    };

    return count++;
  };
}

let counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2

// set giá trị mới cho count
counter.set(5);
console.log(counter()); // 5

// sau lần gọi này, giá trị của count đang là 6

// giảm giá trị của count đi 1
counter.decrease();
console.log(counter()); // 5
```
`function makeCounter() {
  // ban đầu counter bằng 0
  let count = 0;

  // trả về một hàm khác
  // hàm này return về counter rồi tăng biến counter lên 1 đơn vị
  return function counter() {
    // 1. hàm set(value) - gán giá trị value cho count
    counter.set = function (value) {
      count = value;
    };

    // 2. hàm decrease() - giảm giá trị của count đi 1 đơn vị
    counter.decrease = function () {
      count--;
    };

    return count++;
  };
}

let counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2

// set giá trị mới cho count
counter.set(5);
console.log(counter()); // 5

// sau lần gọi này, giá trị của count đang là 6

// giảm giá trị của count đi 1
counter.decrease();
console.log(counter()); // 5` Tham khảo:Function object, NFE"
198,Garbage collection trong Javascript,Giới thiệu,"Quản lý bộ nhớ trong JavaScript được thực hiện tự động và trong suốt với người dùng. Khi bạn khởi tạodữ liệu nguyên thủy,objecthayhàm... thì chúng đều chiếm bộ nhớ (RAM).
Điều gì sẽ xảy ra nếu một vùng nhớ không còn sử dụng? JavaScript engine sẽ làm gì để phát hiện và giải phóng vùng nhớ đó?"
199,Garbage collection trong Javascript,Khả năng truy cập,"Ý tưởng chính của việc quản lý bộ nhớ trong JavaScript làkhả năng truy cập.
Những giá trị""có thể tiếp tận""là những giá trị được lưu trong bộ nhớ theo một cách nào đó, để có thể truy cập và sử dụng.
► JavaScript có một số giá trị là luôn luôn ""có thể truy cập"", nên chắc chắn không bao giờ bị xóa, ví dụ:
Các giá trị này được gọi làroot(gốc).
► Các giá trị khác được gọi là ""có thể truy cập"" nếu chúng được truy cập từrootqua tham chiếu (địa chỉ) hoặc chuỗi các tham chiếu.
Luôn có một tiến trình chạy ngầm trong JavaScript engine gọi làgarbage collectorhaytrình thu gom rác. Garbage collector theo dõi toàn bộ object và xóa đi các object không thể truy cập."
200,Garbage collection trong Javascript,Ví dụ đơn giản về Garbage collection,"Sau đây là ví dụ đơn giản về garbage collection trong JavaScript:

```js
// Biến user có tham chiếu đến một object
let user = {
  name: ""John"",
};
```
`// Biến user có tham chiếu đến một object
let user = {
  name: ""John"",
};` Trong hình trên, kí hiệu mũi tên biểu thị tham chiếu. Biến toàn cụcusercó tham chiếu đến object{ name: ""John""}(sau đây mình sẽ gọi là ""John"" cho ngắn gọn). Thuộc tínhnamecủa John có giá trị là kiểu nguyên thủy nên được vẽ bên trong object.
`user` `{ name: ""John""}` `name` Nếu giá trị của biếnuserđược ghi đè thì tham chiếu sẽ bị mất:
`user` 
```js
user = null;
```
`user = null;` Lúc này, John là ""không thể truy cập"". Không có cách nào để truy cập đến John vì không có tham chiếu đến nó. Do đó,Garbage collectorsẽ xóa John khỏi bộ nhớ."
201,Garbage collection trong Javascript,Hai tham chiếu đến object,"Giả sử bạncopy objectdạng tham chiếu từusersangadmin.
`user` `admin` 
```js
let user = {
  name: ""John"",
};

let admin = user;
```
`let user = {
  name: ""John"",
};

let admin = user;` Lúc này, tồn tại hai tham chiếu đến John. Và nếu giá trị của biếnuserđược ghi đè:
`user` 
```js
user = null;
```
`user = null;` Tham chiếu từuserđến John bị mất, nhưng vẫn còn tham chiếu từadminđến John. Nói cách khác, John vẫn ""có thể truy cập"" được. Nên vùng nhớ của John không bị xóa.
`user` `admin` Chi khi nào giá trị củaadmincũng bị ghi đè thì vùng nhớ của John mới bị xóa.
`admin`"
202,Garbage collection trong Javascript,Object có liên kết nội bộ,"Hãy xem một ví dụ phức tạp hơn:

```js
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman,
  };
}

let family = marry(
  {
    name: ""John"",
  },
  {
    name: ""Ann"",
  }
);
```
`function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman,
  };
}

let family = marry(
  {
    name: ""John"",
  },
  {
    name: ""Ann"",
  }
);` Hàmmarryđã móc nối hai objectmanvàwomanbằng cách để hai object tham chiếu đến lẫn nhau. Rồi trả về một object mới chứa cả hai objectmanvàwoman.
`marry` `man` `woman` `man` `woman` Kết quả thu được như sau:
Trong hình trên, tất cả các object đều là ""có thể tiếp cận"".
Bây giờ, mình xóa đi hai tham chiếu:

```js
delete family.father;
delete family.mother.husband;
```
`delete family.father;
delete family.mother.husband;` Bạn thấy rằng, John không có tham chiếu nàođi đến. Nói cách khác là không thể truy cập đến John từroot. Do đó, vùng nhớ của John sẽ bị xóa.
Sau khi xóa vùng nhớ của John, kết quả còn lại là:"
203,Garbage collection trong Javascript,Nhóm các object không thể tiếp cận,"Có trường hợp mà cả một nhóm các object là ""không thể tiếp cận"" và bị xóa khỏi bộ nhớ.
Ví dụ với object ban đầu, mình ghi đè giá trị củafamily:
`family` 
```js
family = null;
```
`family = null;` Khi đó, bản đồ bộ nhớ sẽ như sau:
Mặc dù, John và Ann đều có tham chiếu nội bộ đến nhau. Thậm chí, John và Ann còn cótham chiếu đi đến. Nhưng như vậy là chưa đủ.
Vì quan trọng hơn cả, những object này lại không có tham chiếu từroot. Nên tất cả chúng đều ""không thể tiếp cận"".
Kết quả là nhóm các object này bị xóa khỏi bộ nhớ."
204,Garbage collection trong Javascript,Thuật toán Garbage collection trong JavaScript,"Thuật toán cơ bản của Garbage collection trong JavaScript gọi là ""mark-and-sweep"" (""đánh dấu-và-xóa"").
Các bước thực hiện của thuật toán này như sau:
`<global>` Ví dụ:
Dễ thấy, nhóm object bên phải là ""không thể tiếp cận"". Hãy xem thuật toán ""mark-and-sweep"" hoạt động thế nào.
Bước đầu tiên là đánh dấu root:
Sau đó, đánh dấu các tham chiếu từ root:
Tại mỗi object được đánh dấu từ bước trước, tiếp tục đánh dấu các tham chiếu từ nó:
Cuối cùng, nhóm object bên phải là ""không thể tiếp cận"" nên sẽ bị xóa:
Đó là cơ bản về thuật toán của Garbage collection trong JavaScript thực hiện.
Dĩ nhiên, JavaScript Engine có tối ưu để tiến trình này thực hiện nhanh hơn và không ảnh hưởng tới hoạt động của trang web.
Sau đây là một vài tối ưu:
►Generational collection:
Object được chia ra làm hai loại là ""cũ"" và ""mới"". Nhiều object được tạo ra mới, rồi sau khi thực hiện xong sẽ bị xóa khỏi bộ nhớ luôn.
Nghĩa là những object nào ""sống đủ lâu"" sẽ được coi là object ""cũ"" nên ít bị kiểm tra hơn.
►Incremental collection:
Trường hợp có nhiều object mà xử lý ""mark-and-sweep"" trong một lần luôn thì sẽ mất rất nhiều thời gian. Điều này có thể làm ảnh hưởng tới luồng hoạt động chính của các tiến trình khác.
Để tránh điều này, JavaScript Engine chia các object ra thành nhiều nhóm nhỏ. Mỗi nhóm sẽ được kiểm tra bởi một tiến trình độc lập.
Và các tiến trình xử lý ""mark-and-sweep"" làsong songnên tổng thời gian kiểm tra được rút ngắn.
►Idle-time collection:
Garbage collection sẽ cố gắng xử lý khi CPU đang trong trạng thái rảnh rỗi (idle) để không ảnh hưởng tới các tiến trình khác."
205,Garbage collection trong Javascript,Tổng kết,"Sau đây là những kiến thức cơ bản cần nhớ về Garbage collection trong JavaScript:
Ngày nay, JavaScript Engine thực hiện nhiều thuật toán nâng cao hơn dành cho Garbage collection.
Nếu bạn thành thạo với ngôn ngữ lập trình cấp thấp thì có thể tham khảo thêm bài viếtA tour of V8: Garbage Collectionđể hiểu hơn về Garbage collection trongV8 Engine."
206,Getter và setter trong JavaScript,Giới thiệu,"Ngoài thuộc tính và phương thức thông thường, object còn cógetter và setter. Getter trong JavaScript và setter trong JavaScriptthực chất là các phương thức. Tuy nhiên, cách sử dụng của chúng lạigiống như thuộc tính.
Sau đây mình sẽ cùng tìm hiểu về định nghĩa và cách sử dụng của getter, setter trong JavaScript."
207,Getter và setter trong JavaScript,Định nghĩa getter và setter,"Để định nghĩa getter trong JavaScript, bạn sử dụng từ khóaget. Và để định nghĩa setter trong JavaScript thì bạn dùng từ khóaset, ví dụ:
`get` `set` 
```js
let obj = {
  // getter
  get propName() {
    // code trả về obj.propName
  },

  // setter
  set propName(value) {
    // code gán giá trị value cho obj.propName
  },
};
```
`let obj = {
  // getter
  get propName() {
    // code trả về obj.propName
  },

  // setter
  set propName(value) {
    // code gán giá trị value cho obj.propName
  },
};` Hàm getterobj.propName()được dùng đểđọc giá trịcủa thuộc tính. Và hàm setterobj.propName(value)dùng đểgán giá trịcho thuộc tính.
`obj.propName()` `obj.propName(value)` Ví dụ tiếp theo, giả sử đối tượngusercó hai thuộc tính lànamevàsurname:
`user` `name` `surname` 
```js
let user = {
  name: ""David"",
  surname: ""Walsh"",
};
```
`let user = {
  name: ""David"",
  surname: ""Walsh"",
};` Và bạn cần thêm thuộc tínhfullNamevới giá trị là""David Walsh"".
`fullName` `""David Walsh""` Nếu bạn không muốncopy-pastelại giá trịnamevàsurnametrên thì có thể viết hàm getter như sau:
`name` `surname` 
```js
let user = {
  name: ""David"",
  surname: ""Walsh"",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
};

console.log(user.fullName); // David Walsh
```
`let user = {
  name: ""David"",
  surname: ""Walsh"",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
};

console.log(user.fullName); // David Walsh` Rõ ràng,fullNameđược viết như một phương thức, nhưng cách sử dụnguser.fullNamethì lại giống việctruy cập giá trịcủa thuộc tính trong object.
`fullName` `user.fullName` Trong ví dụ trên,fullNameđang chỉ là hàmgetter. Do đó, nếu bạn gán giá trị chofullNamethì sẽ có lỗi:
`fullName` `fullName` 
```js
""use strict"";
let user = {
  name: ""David"",
  surname: ""Walsh"",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
};

user.fullName = ""Lam Pham""; // Cannot set property fullName of #<Object> which has only a getter
```
`""use strict"";
let user = {
  name: ""David"",
  surname: ""Walsh"",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
};

user.fullName = ""Lam Pham""; // Cannot set property fullName of #<Object> which has only a getter` Lưu ý
lỗi trên chỉ được in ra khi chạy code ởstrict mode.
Để tránh lỗi trên, bạn cần viết thêm hàmsetterchofullNamenhư sau:
`fullName` 
```js
""use strict"";

let user = {
  name: ""David"",
  surname: ""Walsh"",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  set fullName(value) {
    [this.name, this.surname] = value.split("" "");
  },
};

user.fullName = ""Lam Pham"";
console.log(user.fullName);
```
`""use strict"";

let user = {
  name: ""David"",
  surname: ""Walsh"",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  set fullName(value) {
    [this.name, this.surname] = value.split("" "");
  },
};

user.fullName = ""Lam Pham"";
console.log(user.fullName);` Với cách triển khai như trên, đối tượnguserđã có thêm mộtthuộc tính ảolàfullName.
`user` `fullName`"
208,Getter và setter trong JavaScript,Đối tượng mô tả thuộc tính cho getter và setter,"Mỗi thuộc tính của object trong JavaScript đều có mộtđối tượng mô tả thuộc tính, bao gồm giá trịvaluevà các cờ làwritable/enumerable/configurable.
`value` Nhưng với getter trong JavaScript và setter trong JavaScript thì khác.
Đối tượng mô tả thuộc tính cho getter và setter không có giá trịvaluevà cờwritable, thay vào đó là hai phương thứcgetvàset, cụ thể là:
`value` `writable` `get` `set` `get` `set` `enumerable` `configurable` Ví dụ tạo getter và setter chouser.fullNamevới phương thứcdefinePropertynhư sau:
`user.fullName` `defineProperty` 
```js
let user = {
  name: ""David"",
  surname: ""Walsh"",
};

Object.defineProperty(user, ""fullName"", {
  get() {
    return `${this.name} ${this.surname}`;
  },
  set(value) {
    [this.name, this.surname] = value.split("" "");
  },
});
console.log(user.fullName); // David Walsh

for (let key in user) console.log(key); // name, surname
```
`let user = {
  name: ""David"",
  surname: ""Walsh"",
};

Object.defineProperty(user, ""fullName"", {
  get() {
    return `${this.name} ${this.surname}`;
  },
  set(value) {
    [this.name, this.surname] = value.split("" "");
  },
});
console.log(user.fullName); // David Walsh

for (let key in user) console.log(key); // name, surname` Chú ý:một thuộc tính trong object có thể làgetter/setterhoặc làthuộc tính bình thường, nhưng không được phép tồn tại cả hai.
Nói cách khác, nếu bạn định nghĩa cả hàmget/setvà thuộc tínhvaluetrong cùng mộtđối tượng mô tả thuộc tínhthì sẽ có lỗi:
`get/set` `value` 
```js
Object.defineProperty({}, ""prop"", {
  get() {
    return 0;
  },
  value: 5,
});

// Lỗi:
// Invalid property descriptor.
// Cannot both specify accessors and a value or writable attribute, #<Object>
```
`Object.defineProperty({}, ""prop"", {
  get() {
    return 0;
  },
  value: 5,
});

// Lỗi:
// Invalid property descriptor.
// Cannot both specify accessors and a value or writable attribute, #<Object>`"
209,Getter và setter trong JavaScript,Ứng dụng của getter và setter,"Getter trong JavaScript và setter trong JavaScript có thể dùng làm ""wrapper"" cho thuộc tính.
Ví dụ, bạn muốn chặn việcgán giá trị quá ngắncho tên củauser. Bạn có thể viết hàm setteruser.namevà lưu giá trị thật vào thuộc tínhuser._name.
`user` `user.name` `user._name` 
```js
let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      console.log(""Tên quá ngắn, tối thiểu là 4 chữ cái."");
      return;
    }
    this._name = value;
  },
};

user.name = ""Alex"";
console.log(user.name); // Alex
user.name = """"; // Tên quá ngắn, tối thiểu là 4 chữ cái.
```
`let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      console.log(""Tên quá ngắn, tối thiểu là 4 chữ cái."");
      return;
    }
    this._name = value;
  },
};

user.name = ""Alex"";
console.log(user.name); // Alex
user.name = """"; // Tên quá ngắn, tối thiểu là 4 chữ cái.` Trong ví dụ trên, tên củauserđượclưu thật sựtrong thuộc tínhuser._name, còn việc truy cập vào tên thìthông qua getter và setteruser.name.
`user` `user._name` `user.name` Thực tế, bạn có thểtruy cập trực tiếpvào thuộc tínhuser._name. Tuy nhiên, cách viết thuộc tínhbắt đầu bằng dấu gạch dướilà một quy ước ngầm rằng, thuộc tínhuser._namelàprivatevà không nên truy cập trực tiếp từ bên ngoài.
`user._name` `user._name`"
210,Getter và setter trong JavaScript,Sử dụng getter và setter giúp tương thích ngược,"Lợi ích lớn nhất của việc dùng getter và setter trong JavaScript là cách sử dụng giống như thuộc tính thông thường. Nghĩa là bạn có thểbiến thuộc tính thông thường thành getter/setterbất kỳ lúc nào.
Ví dụ bạn có đối tượnguservới hai thuộc tính lànamevàage:
`user` `name` `age` 
```js
function User(name, age) {
  this.name = name;
  this.age = age;
}

let alex = new User(""Alex"", 28);
console.log(alex.age); // 28
```
`function User(name, age) {
  this.name = name;
  this.age = age;
}

let alex = new User(""Alex"", 28);
console.log(alex.age); // 28` Nhưng sau đó, bạn quyết định thay đổi. Và bạn muốn lưu thông tinbirthdaythay vìage:
`birthday` `age` 
```js
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
}

let alex = new User(""Alex"", new Date(1993, 6, 6));
```
`function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
}

let alex = new User(""Alex"", new Date(1993, 6, 6));` Chuyện gì sẽ xảy ra với những code cũ - đang sử dụng thuộc tínhage?
`age` Bạn có thểtìm tất cảnhững chỗ có sử dụnguser.ageđể sửa lại cho đúng. Tuy nhiên, nếu code của bạn được sử dụng bởi nhiều người và ở nhiều nơi khác nhau thì cách làm trên làbất khả thi.
`user.age` Cách đơn giản để giải quyết vấn đề trên là biến thuộc tínhagethànhgetter/setternhư sau:
`age` 
```js
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  // tính toán age dựa trên birthday và năm hiện tại  Object.defineProperty(this, ""age"", {    get() {      let todayYear = new Date().getFullYear();      return todayYear - this.birthday.getFullYear();    },  });}
  let alex = new User(""Alex"", new Date(1993, 6, 6));
  console.log(alex.birthday); // Tue Jul 06 1993 00:00:00 GMT+0700 (Indochina Time)
  console.log(alex.age); // 29
}
```
`function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  // tính toán age dựa trên birthday và năm hiện tại  Object.defineProperty(this, ""age"", {    get() {      let todayYear = new Date().getFullYear();      return todayYear - this.birthday.getFullYear();    },  });}
  let alex = new User(""Alex"", new Date(1993, 6, 6));
  console.log(alex.birthday); // Tue Jul 06 1993 00:00:00 GMT+0700 (Indochina Time)
  console.log(alex.age); // 29
}` Với cách làm trên, code cũ đảm bảo là vẫn chạy như bình thường.
Tham khảo:Property getters and setters."
211,Giới thiệu Javascript,Giới thiệu,"Javascript là ngôn ngữ lập trình bậc cao, cực kỳ linh hoạt được sử dụng chủ yếu để tao ra ứng dụng chạy trên trình duyệt web. Được tạo ra bởi Brendan Eich vào năm 1995. Nó thể viết code ở text editor và chạy nó trực tiếp trên trình duyệt mà không cần phải trải qua quá trình biên dịch như C++ hoặc Java.
Javascript tập trung nâng cao sự tương tác của người dùng với trang web. Bạn có thể làm cho trang web trở nên sống động và tăng tính tương tác hơn. Trong các ứng dụng web, người ta hay dùng JS để làm các hiệu ứng đặc biệt như sliders, pop-ups, hoặc xác thực dữ liệu các form (form validations) trước khi gửi dữ liệu lên server .v.v...
Vì nó cực kỳ linh hoạt, nên gần như rất nhiều lĩnh vực mà Js có thể tạo nên:
Và còn rất rất nhiều các lĩnh vực mà Javascript có thể làm được nữa!"
212,Giới thiệu Javascript,Javascript Engine,"Khi nghe từ Engine, đó hẳn là 1 cái gì đó cao siêu và phức tạp. Nhưng nếu để phải giải thích cho một người mới học JS, thì đó nên là:
Còn nếu muốn hiểu sâu sâu hơn nữa, thì bạn có thể đọc chi tiết vềV8Engine mà Chrome/Opera sử dung, haySpiderMonkeytrong FireFox, hoặcNitrocho Safari."
213,Giới thiệu Javascript,Lịch sử Javascript,"Javascript được tạo bởi lập trình viên kỳ cựu Brendan Eich, giới thiệu lần đầu năm 1995, xuất hiện trên trình duyệt Netscape, một trình duyệt phổ biến thời bấy giờ.
Ban đầu, ngôn ngữ lập trình này được gọi là LiveScript, sau này mới đổi tên thành Javascript. Mới đọc tên thì nhiều người sẽ nhầm tưởng Javascript có ""họ hàng"" với Java. Nhưng thực tế, hai ngôn ngữ này không hề có liên quan gì tới nhau cả, cây gia phả của chúng không hề chung gốc. Java là ngôn ngữ lập trình hướng đối tượng phức tạp, còn Javascript là một ngôn ngữ kịch bản (scripting language). Cú pháp của Javascript chủ yếu có hơi hướng ảnh hưởng từ ngôn ngữ C.
Điển hình nhất trong lịch sử của Javascript cho đến tận bây giờ đó là việc ra mắt ES6 vào 2015, nó dường như đã dịch chuyển cả một nền công nghiệp lập trình lúc bấy giờ. Và từ đó đến nay, Javascript như là 1 vị vua của ngôn ngữ lập trình với hàng loạt sản phẩm, thư viện, framework được sinh ra từ nó!
Để tìm hiểu sâu hơn, bạn có thể xem thêm phần lịch sử ra mắt cácphiên bản của ECMAScript, và sự tương thích của ES6 so với các engine ởở đây"
214,Giới thiệu Javascript,Tại sao nên học Javascript?,"Trước khi bạn quyết định đầu tư học một ngôn ngữ lập trình, đặc biệt với người chưa từng biết một ngôn ngữ lập trình nào, có thể bạn sẽ đắn đo, băn khoăn liệu mình có nên lao đầu vào ngôn ngữ lập trình này không? Liệu tương lai ngôn ngữ này có phát triển hay không?
Dưới đây là một số lý do để bạn bỏ công sức đầu tư học Javascript.
Khi bạn định hướng nghề nghiệp trong tương lai, việc chọn một ngôn ngữ lập trình phổ biến để theo đuổi là lựa chọn không hề tồi chút nào. Cũng giống như bạn đi kinh doanh, bán hàng vậy. Không ai dại gì lại đi bán mặt hàng mà thị trường không có nhu cầu sử dụng cả.
Theo một khảo sát mới nhất củaStackoverflow.com(website hỏi đáp dành cho lập trình viên lớn nhất thế giới) cho thấy, Javascript là ngôn ngữ lập trình phổ biến nhất, được rất nhiều lập trình viên chuyên nghiệp tin tưởng.
Không chỉ front-end, ngay cả các dự án back-end cũng ngày càng lựa chọn Javascript nhiều hơn.
Với tính mềm dẻo, linh hoạt, Javascript rất dễ học, đặc biệt là cho người mới học lập trình. Javascript biến các chi tiết phức tạp thành các bản tóm tắt, giúp mọi thứ trở nên dễ dàng hơn với người mới.
Không giống như các ngôn ngữ lập trình bậc cao khác, Javascript mang nhiều cảm giác về ngôn ngữ tự nhiên hơn. Tức là bạn nói sao thì viết như vậy
Khi tiếp cận bất kỳ kỹ thuật mới nào, việc quan trọng đầu tiên phải nghĩ tới đó là tài liệu hướng dẫn có đầy đủ không! Mình từng tham dự một dự án mà sử dụng một framework cổ xưa, tài liệu chính chủ còn không có (chắc tác giả cũng bỏ rơi nó luôn), lúc đó mới thấu hiểu nỗi đau khổ khi không có tài liệu.
Với ngôn ngữ Javascipt nói chung, các JS frameworks như React, Vue... nói riêng thì đều có tài liệu hướng dẫn rất chi tiết và đầy đủ (cả chính chủ lẫn của cộng đồng). Do đó, bạn sẽ không gặp phải bất kỳ khó khăn nào trong việc tìm kiếm tài liệu hỗ trợ bạn trong việc học.
Ngoài ra, trên internet còn có hàng ngàn tutorial miễn phí để bạn có thể tham khảo. Tuy nhiên, việc dễ dàng tiếp cận hàng ngàn tài liệu cũng khiến bạn dễ bị bối rối, hỗn loạn kiến thức. Đó là lý do bạn tìm tới cuốn sách này.
Nếu trước đây, Javascript được sinh ra chỉ để xây dựng các trang web, thì nay đã khác. Javascript giờ đây có thể xây dựng mọi ứng dụng từ client-side tới back-end, các ứng dụng/game mobile, ứng dụng trên PC, kể cả các ứng dụng trên cloud, AI (Trí tuệ nhân tạo)...
Do đó, thay vì bạn phải đầu tư học rất nhiều ngôn ngữ, giờ bạn chỉ cần tập trung học Javascript cho thật tốt là đủ ""cân cả bản đồ"".
Với việc ngày càng có nhiều doanh nghiệp và tổ chức chuyển sang sử dụng Javascript cho sản phẩm của mình. Do đó, nhu cầu tuyển dụng lập trình viên Javascript cũng tăng lên rất nhiều.
Theo một khảo sát củaDevskiller.com, 70% các công ty công nghệ muốn tuyển một lập trình viên Javascript.
Ở Việt Nam thì sao? Đảo qua một loạt các trang tuyển dụng lớn như Vietnamworks, ITviec... nhu cầu tuyển lập trình viên React, Angular, Vue, NodeJS... rất nhiều, mức lương cũng rất cao (toàn trên 2k$ cho một senior developer).
Tóm lại, theo đánh giá của mình, việc chọn Javascript là ngôn ngữ lập trình chính cho sự nghiệp là một lựa chọn đáng giá, xứng đáng với mồ hôi nước mắt. Ok, giờ là lúc chúng ta cùng nhau chinh phục Javascript thôi!"
215,Giới thiệu Javascript,Ưu điểm của Javascript,"Để nói về ưu điểm của một ngôn ngữ lập trình thì có thể kể hàng chục trang giấy. Bởi vì, mỗi ngôn ngữ được tạo ra, tác giả đều sẽ cố gắng tối ưu, thiết kế sao cho tốt nhất. Không phải ngẫu nhiên mà Javascript được cộng đồng đón nhận rộng rãi đến như vậy
Tuy vậy, để bạn hiểu được thế mạnh của Javascript, mình sẽ liệt kê một số nét đặc trưng khiến Javascript nổi bật hơn các ngôn ngữ lập trình khác
Không giống như nhiều ngôn ngữ phát triển web khác, ví dụ flash, Java... người dùng muốn sử dụng được thì phải cài đặt thêm plugin cho trình duyệt.
Javascript thì khác, hầu hết trình duyệt hiện đại đều đã tích hợp sẵn. Do đó, việc bạn sử dụng JS để phát triển ứng dụng sẽ rất thuận lợi.
Rất nhiều lập trình viên thích trường phái functional programming. Functional Programming một phương pháp lập trình dựa trên các hàm toán học (function), tránh việc thay đổi giá trị của dữ liệu. Nó có nhiều lợi ích như : các khối xử lý độc lập dễ tái sử dụng, thuận lợi cho việc thay đổi logic hoặc tìm lỗi chương trình.
Javascript là ngôn ngữ sinh ra là để dành cho functional programming.
Hai trong số tính năng nối bật nhất của Javascript là cho phép gán một hàm cho bất kỳ biến nào và tạo một hàm chấp nhận tham số là một hàm khác.
Đôi khi, trong một số ứng dụng, bạn gặp vấn đề và cần phải viết mã nguồn tương thích với từng trình duyệt web hoặc hệ điều hành. Javascript được thiết kế để có thể tự nhận biết được chạy trên trình duyệt gì, hệ điều hành nào.
Điều này, cho phép bạn dễ dàng điều chỉnh mã nguồn để ứng dụng đáp ứng và tương thích với mọi hệ điều hành.
Lập trình hướng đối tượng cũng là một trường phái lập trình rất phổ biến, khi tất cả mọi thứ của ứng dụng đều xoay quanh đối tượng (Object - Class). Javascript cung cấp rất nhiều công cụ để bạn làm việc với đối tượng, đồng thời nó cũng dễ học, dễ sử dụng.
Nói một cách chính xác hơn, có thể coi Javascript là ngôn ngữ dựa trên đối tượng, vì lý do:
Phần này mình chỉ nhắc lại thôi. Nếu trước đây, Javascript được tạo ra chỉ để phát triển các ứng dụng front-end chạy trên trình duyệt thì giờ đây mọi chuyện đã khác. Có thể bạn chưa biết, trước đây một full stack developer cần phải học rất nhiều ngôn ngữ lập trình. Có thể kể tên nhẹ nhàng như: front-end thì có javascript, back-end thì có PHP, JAVA, Ruby, Golang..., ứng dụng mobile thì có Java, Kotlin, Swift... rất nhiều ngôn ngữ phải học.
Nhưng ngày nay, bạn chỉ cần học duy nhất Javascript là đủ. Biết Javascript, bạn có thể xây dựng các ứng dụng web (cái này tất nhiên rồi), xây dựng ứng dụng phía back-end (nhờ Node.JS), xây dựng ứng dụng mobile (React Native, Ionic...)"
216,Hàm đệ quy trong Javascript,Giới thiệu,"Hàm đệ quy trong JavaScript chính làmột hàm tự gọi lại chính nó.
Ví dụ sau in raHello world!nlần sử dụng hàm đệ quy:
`n` 
```js
function sayHello(count) {
  if (count <= 0) {
    return;
  }

  console.log(""Hello world!"");
  sayHello(count - 1);
}

// sayHello 5 lần
sayHello(5);
```
`function sayHello(count) {
  if (count <= 0) {
    return;
  }

  console.log(""Hello world!"");
  sayHello(count - 1);
}

// sayHello 5 lần
sayHello(5);` Kết quả
Hello world!Hello world!Hello world!Hello world!Hello world!
Đây chỉ là ví dụ minh họa vềhàm đệ quy trong JavaScript. Thực tế, bạn có thể sử dụngvòng lặpforđể giải quyết bài toán trên:
`for` 
```js
function sayHello(count) {
  for (let i = 0; i < count; i++) {
    console.log(""Hello world!"");
  }
}

sayHello(5);
```
`function sayHello(count) {
  for (let i = 0; i < count; i++) {
    console.log(""Hello world!"");
  }
}

sayHello(5);` Kết quả hoàn toàn tương đương. Tuy nhiên, có rất nhiều trường hợp việc sử dụng hàm đệ quy lại giúp code trở nênngắn gọn, rõ ràng và dễ bảo trìhơn sử dụng vòng lặp.
Vì vậy, mình hãy cùng tìm hiểu về hàm đệ quy trong JavaScript để biết cách áp dụng khi cần thiết."
217,Hàm đệ quy trong Javascript,Các thành phần cơ bản của hàm đệ quy,"Hàm đệ quy nói chung và hàm đệ quy trong JavaScript nói riêng, cóhai thành phần đặc trưng:

```js
function sayHello(count) {
  // phần cơ sở: điều kiện thoát đệ quy là biến count <= 0
  if (count <= 0) {
    return;
  }

  // xử lý logic cơ bản
  console.log(""Hello world!"");

  // phần đệ quy: gọi lại chính hàm sayHello
  sayHello(count - 1);
}
```
`function sayHello(count) {
  // phần cơ sở: điều kiện thoát đệ quy là biến count <= 0
  if (count <= 0) {
    return;
  }

  // xử lý logic cơ bản
  console.log(""Hello world!"");

  // phần đệ quy: gọi lại chính hàm sayHello
  sayHello(count - 1);
}` Cũng tương tự như điều kiện để thoát vòng lặp, nếukhông có điều kiện cơ sởthì hàm đệ quy sẽ không bao giờ dừng lại (đệ quy vô hạn), dẫn đếntràn stack.
Ví dụbỏ qua điều kiện cơ cởcủa hàm đệ quy trên:

```js
function sayHello(count) {
  // // phần cơ sở: điều kiện thoát đệ quy là biến count <= 0
  // if (count <= 0) {
  //   return;
  // }

  console.log(""Hello world!"");

  // phần đệ quy: gọi lại chính hàm sayHello
  sayHello(count - 1);
}

sayHello();
```
`function sayHello(count) {
  // // phần cơ sở: điều kiện thoát đệ quy là biến count <= 0
  // if (count <= 0) {
  //   return;
  // }

  console.log(""Hello world!"");

  // phần đệ quy: gọi lại chính hàm sayHello
  sayHello(count - 1);
}

sayHello();` Kết quả làHello world!được in ra khoảng hơn10000lần thì bị lỗitràn stack, cụ thể:Uncaught RangeError: Maximum call stack size exceeded.
`10000` Kết quả
Hello world!Hello world!...Hello world!
Uncaught RangeError: Maximum call stack size exceeded
Chú ý:con số10000trên chỉ là tương đối, phụ thuộc vào từngJavaScript Engine
`10000`"
218,Hàm đệ quy trong Javascript,Call stack là gì?,"Khi gọi hàm, JavaScript Engine đưa các lời gọi hàm vào trong một ngăn xếp.
Việc lưu lời gọi hàm vào ngăn xếp làtốn bộ nhớ. Vì vậy, JavaScript Engine sẽ giới hạn kích thước của ngăn xếp (khoảng10000hoặc hơn, tùy thuộc vào engine).
`10000` Khi sử dụng hàm đệ quy trong JavaScript, bạn cần chú ý đến điều kiện cơ sở để thoát đệ quy, tránh đệ quy vô hạn dẫn đến tràn stack như ví dụ trên."
219,Hàm đệ quy trong Javascript,Sử dụng hàm đệ quy khi nào?,"Khi một bài toán có thểchia ra thành nhiều bài toán convà bài toán concó dạng tương tựnhư bài toán cha thì bạn có thể sử dụng hàm đệ quy.
Ví dụ bài toán tính giá trị của lũy thừaa^b(a mũ b) với định nghĩa toán học là:
`a^b` 
```js
a^b = 1, nếu b = 0
a^b = a * a^(b-1), nếu b > 0
```
`a^b = 1, nếu b = 0
a^b = a * a^(b-1), nếu b > 0` Theo định nghĩa trên, bài toán cha là tínha^blại dựa trên bài toán cona^(b-1). Vì vậy, bạn có thể áp dụng hàm đệ quy để tính giá trịa^bnhư sau:
`a^b` `a^(b-1)` `a^b` 
```js
function power(a, b) {
  // điều kiện dừng đệ quy
  if (b === 0) {
    return 1;
  }

  // gọi lại chính nó
  return a * power(a, b - 1);
}

console.log(power(2, 0)); // 1
console.log(power(2, 1)); // 2
console.log(power(2, 2)); // 4
console.log(power(2, 3)); // 8
```
`function power(a, b) {
  // điều kiện dừng đệ quy
  if (b === 0) {
    return 1;
  }

  // gọi lại chính nó
  return a * power(a, b - 1);
}

console.log(power(2, 0)); // 1
console.log(power(2, 1)); // 2
console.log(power(2, 2)); // 4
console.log(power(2, 3)); // 8`"
220,Hàm đệ quy trong Javascript,So sánh hàm đệ quy và vòng lặp,"Bài toán tính lũy thừa trên có thể giải quyết bằng cách sử dụng vòng lặp:

```js
function power(a, b) {
  let ret = 1;

  for (let i = 0; i < b; i++) {
    ret *= a;
  }

  return ret;
}

console.log(power(2, 0)); // 1
console.log(power(2, 1)); // 2
console.log(power(2, 2)); // 4
console.log(power(2, 3)); // 8
```
`function power(a, b) {
  let ret = 1;

  for (let i = 0; i < b; i++) {
    ret *= a;
  }

  return ret;
}

console.log(power(2, 0)); // 1
console.log(power(2, 1)); // 2
console.log(power(2, 2)); // 4
console.log(power(2, 3)); // 8` Đa số các bài toáncó thể sử dụng hàm đệ quythì đều có thể giải bằng cáchsử dụng vòng lặp.
Việc sử dụng vòng lặp nhìn chung làchạy nhanh và tiết kiệm bộ nhớhơn cách sử dụng hàm đệ quy. Vì sử dụng vòng lặp chỉ đưa lời gọi hàm vào call stack1 lần- không mấtthời gian và không gian bộ nhớnhư đệ quy.
Ngược lại, cách sử dụng hàm đệ quy lại giúp code trở nênngắn gọn và rõ ràng hơnsử dụng vòng lặp.
Có thể bạn chưa biết
Đối với một số bài toáncó thể giải bằng hai cáchmàkhông quá quan trọng thời gian và không gian bộ nhớthì mình sẽ ưu tiên sử dụnghàm đệ quytrong JavaScript."
221,Hàm đệ quy trong Javascript,Tổng kết,"Hàm đệ quy trong JavaScript là hàm gọi lại chính nó, với hai thành phần cơ bản là:
Đa số các bài toáncó thể sử dụng hàm đệ quythì đều có thể giải bằng cáchsử dụng vòng lặp. Tùy thuộc vào yêu cầu của từng bài toán mà bạn lựa chọn cách làm phù hợp:"
222,Hàm đệ quy trong Javascript,Thực hành,"Viết hàmsumTo(n)để tính tổng các số từ 1 đến n:1 + 2 + ... + n, ví dụ:
`sumTo(n)` `1 + 2 + ... + n` 
```js
sumTo(1) = 1
    sumTo(2) = 2 + 1 = 3
    sumTo(3) = 3 + 2 + 1 = 6
    sumTo(4) = 4 + 3 + 2 + 1 = 10
    ...
    sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
```
`sumTo(1) = 1
    sumTo(2) = 2 + 1 = 3
    sumTo(3) = 3 + 2 + 1 = 6
    sumTo(4) = 4 + 3 + 2 + 1 = 10
    ...
    sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050` Triển khai hàmsumTo(n)theo 3 cách khác nhau:
`sumTo(n)` Xem đáp án
► Cách 1: sử dụng vòng lặp

```js
function sumTo(n) {
  let sum = 0;

  for (i = 0; i <= n; i++) {
    sum += i;
  }

  return sum;
}
```
`function sumTo(n) {
  let sum = 0;

  for (i = 0; i <= n; i++) {
    sum += i;
  }

  return sum;
}` ► Cách 2: sử dụng đệ quy

```js
function sumTo(n) {
  if (n === 1) return 1;

  return n + sumTo(n - 1);
}
```
`function sumTo(n) {
  if (n === 1) return 1;

  return n + sumTo(n - 1);
}` ► Cách 3: sử dụng công thức toán học

```js
function sumTo(n) {
  return (n * (n + 1)) / 2;
}
```
`function sumTo(n) {
  return (n * (n + 1)) / 2;
}` Viết hàmfactorial(n)tính n giai thừa:n! = (n) * (n-1) * (n-2) * ... * 1, ví dụ:
`factorial(n)` `n! = (n) * (n-1) * (n-2) * ... * 1` 
```js
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
```
`1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120` Triển khai hàmfactorial(n)theo hai cách:
`factorial(n)` Xem đáp án
► Cách 1: sử dụng vòng lặp

```js
function factorial(n) {
  let ret = 1;

  for (let i = 1; i <= n; i++) {
    ret *= i;
  }

  return ret;
}
```
`function factorial(n) {
  let ret = 1;

  for (let i = 1; i <= n; i++) {
    ret *= i;
  }

  return ret;
}` ► Cách 2: sử dụng đệ quy

```js
function factorial(n) {
  if (n === 0) return 1;

  return n * factorial(n - 1);
}
```
`function factorial(n) {
  if (n === 0) return 1;

  return n * factorial(n - 1);
}` Viết hàmfibonacci(n)tính số fibonacci theo công thức:
`fibonacci(n)` 
```js
fibonacci(n) = n nếu n = 0 hoặc n = 1
fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2)
```
`fibonacci(n) = n nếu n = 0 hoặc n = 1
fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2)` Ví dụ:

```js
fibonacci(0) = 0
fibonacci(1) = 1
fibonacci(2) = 1 + 0 = 1
fibonacci(3) = 1 + 1 = 2
fibonacci(4) = 2 + 1 = 3
fibonacci(5) = 3 + 2 = 5
```
`fibonacci(0) = 0
fibonacci(1) = 1
fibonacci(2) = 1 + 0 = 1
fibonacci(3) = 1 + 1 = 2
fibonacci(4) = 2 + 1 = 3
fibonacci(5) = 3 + 2 = 5` Xem đáp án

```js
function fibonacci(n) {
  if (n === 0 || n === 1) return n;

  return fibonacci(n - 1) + fibonacci(n - 2);
}
```
`function fibonacci(n) {
  if (n === 0 || n === 1) return n;

  return fibonacci(n - 1) + fibonacci(n - 2);
}` Cho danh sách liên kết đơn như sau:

```js
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null,
      },
    },
  },
};
```
`let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null,
      },
    },
  },
};` Viết hàmprintList(singleLinkedList)để in ra các phần tử của list theo hai cách:
`printList(singleLinkedList)` Kết quả hiển thị trên console là:
Kết quả
1234
Xem đáp án
► Cách 1: sử dụng vòng lặp

```js
function printList(singleLinkedList) {
  let p = singleLinkedList;

  while (p) {
    console.log(p.value);
    p = p.next;
  }
}
```
`function printList(singleLinkedList) {
  let p = singleLinkedList;

  while (p) {
    console.log(p.value);
    p = p.next;
  }
}` ► Cách 2: sử dụng đệ quy

```js
function printList(singleLinkedList) {
  if (singleLinkedList === null) return;

  console.log(singleLinkedList.value);
  printList(singleLinkedList.next);
}
```
`function printList(singleLinkedList) {
  if (singleLinkedList === null) return;

  console.log(singleLinkedList.value);
  printList(singleLinkedList.next);
}` Cho danh sách liên kết đơn như sau:

```js
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null,
      },
    },
  },
};
```
`let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null,
      },
    },
  },
};` Viết hàmprintReverseList(singleLinkedList)để in ra các phần tử của list theo thứ tự ngược lại với bài 4 bằng hai cách:
`printReverseList(singleLinkedList)` Kết quả hiển thị trên console là:
Kết quả
4321
Xem đáp án
► Cách 1: sử dụng vòng lặp

```js
function printReverseList(singleLinkedList) {
  let arr = [];

  let p = singleLinkedList;
  while (p) {
    arr.push(p.value);
    p = p.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    console.log(arr[i]);
  }
}
```
`function printReverseList(singleLinkedList) {
  let arr = [];

  let p = singleLinkedList;
  while (p) {
    arr.push(p.value);
    p = p.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    console.log(arr[i]);
  }
}` ► Cách 2: sử dụng đệ quy

```js
function printReverseList(singleLinkedList) {
  if (singleLinkedList.next) {
    printReverseList(singleLinkedList.next);
  }

  console.log(singleLinkedList.value);
}
```
`function printReverseList(singleLinkedList) {
  if (singleLinkedList.next) {
    printReverseList(singleLinkedList.next);
  }

  console.log(singleLinkedList.value);
}`"
223,Hàm setTimeout trong Javascript,Giới thiệu,"Đôi khi bạn cần phải thực hiện hành độngsau một khoảng thời giannhất định. Để thực hiện điều này, bạn có thể sử dụng phương thứcsetTimeout. Sau đây là cách khai báo và sử dụngsetTimeout trong JavaScript.
`setTimeout`"
224,Hàm setTimeout trong Javascript,Hàm setTimeout trong JavaScript,"Cú pháp hàmsetTimeoutlà:
`setTimeout` 
```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```
`let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)` Trong đó:
`func|code` `delay` `delay` `0` `arg1, arg2,...` Ví dụ đoạn code sau gọi hàmsayHisau 1 giây:
`sayHi` 
```js
function sayHi() {
  console.log(""Hello"");
}

setTimeout(sayHi, 1000); // Hello
```
`function sayHi() {
  console.log(""Hello"");
}

setTimeout(sayHi, 1000); // Hello` Ví dụ với tham số truyền vào hàm:

```js
function sayHi(message, who) {
  console.log(`${message}, ${who}`);
}

setTimeout(sayHi, 1000, ""Hello"", ""Alex""); // Hello, Alex
```
`function sayHi(message, who) {
  console.log(`${message}, ${who}`);
}

setTimeout(sayHi, 1000, ""Hello"", ""Alex""); // Hello, Alex` Nếutham số đầu tiên là string, JavaScript engine sẽtạo hàm từ stringđó để thực thi, ví dụ:

```js
setTimeout(""console.log('Hello')"", 1000);
```
`setTimeout(""console.log('Hello')"", 1000);` Tuy nhiên, cách sử dụngstringlà không được khuyến khích, bạn có thể thay thế bằngarrow functionnhư sau:

```js
setTimeout(() => console.log(""Hello""), 1000);
```
`setTimeout(() => console.log(""Hello""), 1000);` Chú ý:Tham số đầu tiên làhàm, chứkhông phải kết quả của việc gọi hàm, nhiều bạn hay bị nhầm lẫn như sau:

```js
// gọi hàm sayHi() thay vì truyền vào hàm sayHi
setTimeout(sayHi(), 1000);
```
`// gọi hàm sayHi() thay vì truyền vào hàm sayHi
setTimeout(sayHi(), 1000);` Khi gọi hàmsayHi()như trên, kết quả của hàmsayHi()được truyền vào hàmsetTimeout. Mà hàmsetTimeoutchỉ chấp nhận truyền vào là function. Do đó, đoạn code trên sẽ không thực hiện gì sau 1 giây.
`sayHi()` `sayHi()` `setTimeout` `setTimeout`"
225,Hàm setTimeout trong Javascript,Xóa hành động với clearTimeout,"Khi bạn gọi hàmsetTimeout trong JavaScript, kết quả trả về là một số nguyêntimerId- định danh cho hành động với timeout. Để hủy bỏ hành động, bạn chỉ cần gọiclearTimeoutnhư sau:
`timerId` `clearTimeout` 
```js
let timerId = setTimeout(...);
    clearTimeout(timerId);
```
`let timerId = setTimeout(...);
    clearTimeout(timerId);` Ví dụ bạn dự định gọi một hàm sau khoảng thời gian delay là 1 giây. Nhưng sau đó, bạn lại hủy bỏ hành động này:

```js
let timerId = setTimeout(() => console.log(""sẽ không được gọi""), 1000);
console.log(timerId); // định danh cho timer

clearTimeout(timerId);
console.log(timerId); // timerId không đổi sau khi clearTimeout
```
`let timerId = setTimeout(() => console.log(""sẽ không được gọi""), 1000);
console.log(timerId); // định danh cho timer

clearTimeout(timerId);
console.log(timerId); // timerId không đổi sau khi clearTimeout`"
226,Hàm setTimeout trong Javascript,Hàm setInterval trong JavaScript,"HàmsetIntervalcó cú pháp tương tự như hàmsetTimeout:
`setInterval` `setTimeout` 
```js
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```
`let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)` Trong đó, tất cả tham số đều có ý nghĩa giống với hàmsetTimeout.
`setTimeout` Nhưng khác với hàmsetTimeoutlà chỉ thực hiện hành độngmột lần, hàmsetIntervalsẽ gọi hàm thường xuyên saumỗi khoảng thời gian delay.
`setTimeout` `setInterval` Để dừng hành động, bạn chỉ cần gọi hàmclearInterval(timerId).
`clearInterval(timerId)` Ví dụ sau hiển thị""Hello""sau mỗi 2 giây và sau đó 5 giây thì dừng lại:
`""Hello""` 
```js
// lặp lại với thời gian là 2000 ms (2 giây)
let timerId = setInterval(() => console.log(""Hello""), 2000);

// sau 5 giây thì dừng lại
setTimeout(() => {
  clearInterval(timerId);
  console.log(""stop"");
}, 5000);
```
`// lặp lại với thời gian là 2000 ms (2 giây)
let timerId = setInterval(() => console.log(""Hello""), 2000);

// sau 5 giây thì dừng lại
setTimeout(() => {
  clearInterval(timerId);
  console.log(""stop"");
}, 5000);`"
227,Hàm setTimeout trong Javascript,Hàm setTimeout lồng nhau,"Ngoài cách sử dụngsetIntervalđể thực hiện một hành động lặp đi lặp lại, bạn có thể sử dụng hàmsetTimeout trong JavaScripttheo cách lồng nhau như sau:
`setInterval` 
```js
/** thay vì:
    let timerId = setInterval(() => console.log('Hello'), 2000);
    */

let timerId = setTimeout(function sayHi() {
  console.log(""Hello"");
  timerId = setTimeout(sayHi, 2000); // (*)
}, 2000);
```
`/** thay vì:
    let timerId = setInterval(() => console.log('Hello'), 2000);
    */

let timerId = setTimeout(function sayHi() {
  console.log(""Hello"");
  timerId = setTimeout(sayHi, 2000); // (*)
}, 2000);` Trong ví dụ trên, cứ sau mỗi 2 giây thì hàmsayHisẽ được gọi. Mà ở cuối hàmsayHimình lại gọi tiếpsetTimeoutvới hàmsayHi- tương tự cách gọihàm đệ quy.
`sayHi` `sayHi` `setTimeout` `sayHi` Cách gọi hàmsetTimeoutlồng nhau như trên giúp bạn xử lýdelaylinh hoạt hơn so với cách dùngsetInterval. Vì bạn có thể tùy chỉnh thời giandelaycho mỗi lần lặp.
`setTimeout` `delay` `setInterval` `delay` Giả sử bạn cần tạo request lên server sau mỗi 5 giây để cập nhật dữ liệu. Tuy nhiên, server có thể bị quá tải. Dựa vào trạng thái server hiện tại, bạn có thể tăng thời gian delay lên 10, 20, 30, giây... cho phù hợp, ví dụ:

```js
let delay = 5000;

let timerId = setTimeout(function request() {
  /*... gửi request lên server...*/

  if (/* mã lỗi trả về liên quan đến server quá tải */) {
    // tăng delay lên hai lần
    delay *= 2;
  }

    // chạy lại setTimeout với giá trị delay mới
    timerId = setTimeout(request, delay);

}, delay); // -> giá trị delay ban đầu là 5000 ms
```
`let delay = 5000;

let timerId = setTimeout(function request() {
  /*... gửi request lên server...*/

  if (/* mã lỗi trả về liên quan đến server quá tải */) {
    // tăng delay lên hai lần
    delay *= 2;
  }

    // chạy lại setTimeout với giá trị delay mới
    timerId = setTimeout(request, delay);

}, delay); // -> giá trị delay ban đầu là 5000 ms` ►Cách sử dụngsetTimeoutlồng nhau cho phépdelaychính xác hơn giữa mỗi lần thực hiện hành động so với cách dùngsetInterval.
`setTimeout` `delay` `setInterval` Ví dụ dùngsetInterval:
`setInterval` 
```js
let i = 1;
setInterval(function () {
  func(i++);
}, 100);
```
`let i = 1;
setInterval(function () {
  func(i++);
}, 100);` Ví dụ dùngsetTimeoutlồng nhau:
`setTimeout` 
```js
let i = 1;
setTimeout(function run() {
  func(i++);
  setTimeout(run, 100);
}, 100);
```
`let i = 1;
setTimeout(function run() {
  func(i++);
  setTimeout(run, 100);
}, 100);` HàmsetIntervalthực hiện hành độngfunc(i++)sau mỗi 100ms. Tuy nhiên, hành độngfunc(i++)cũng chiếm thời gian. Do đó, thời gian thực tế giữa hai lần chạyfunc(i++)lànhỏ hơn 100ms.
`setInterval` `func(i++)` `func(i++)` `func(i++)` Thậm chí là thời gian chạyfunc(i++)có thể nhiều hơn 100ms thì lần chạyfunc(i++)tiếp theo sẽ được gọi ngay lập tức sau lần gọi trước. Nói cách khác làkhông có thời gian delaygiữa hai lần chạyfunc(i++).
`func(i++)` `func(i++)` `func(i++)` Nhưng với cách sử dụng hàmsetTimeoutlồng nhau thì khác. Với cách này, hàmsetTimeouttiếp theo chỉ được gọi khi hàmfunc(i++)thực hiện xong. Nghĩa là thời gian giữa hai lần chạyfunc(i++)sẽđảm bảo khoảng 100ms.
`setTimeout` `setTimeout` `func(i++)` `func(i++)`"
228,Hàm setTimeout trong Javascript,Vấn đề garbage collection,"Như mình đã nói trong bài viết vềgarbage collection trong JavaScript, khi một giá trị là không thể tiếp cận thì nó sẽ được giải phóng khỏi bộ nhớ.
Đối với hàm truyền vàosetTimeout/setInterval, JavaScript engine sẽ tạo một tham chiếu nội bộ tới hàm thực thi để đảm bảo hàm này không bị giải phóng.
`setTimeout/setInterval` Với hàmsetTimeout, hàm truyền vào sẽ được giữ trong bộ nhớ cho tới khi hàm được gọi:
`setTimeout` 
```js
// hàm được giữ trong bộ nhớ cho tới khi thực thi xong
setTimeout(function() {...}, 100);
```
`// hàm được giữ trong bộ nhớ cho tới khi thực thi xong
setTimeout(function() {...}, 100);` Với hàmsetInterval, hàm truyền vào được giải phóng khỏi bộ nhớ sau khi gọiclearInterval.
`setInterval` `clearInterval` Giả sử hàm truyền vàosetIntervaltham chiếu đến biến bên ngoài. Vì hàm này luôn tồn tại cho đến khi gọiclearInterval, nên biến được tham chiếu đến cũng sẽkhông được giải phóng.
`setInterval` `clearInterval` Khi không thực sự cần thiết, hãy gọi hàmclearIntervalđể giải phóng bộ nhớ.
`clearInterval`"
229,Hàm setTimeout trong Javascript,Hàm setTimeout với thời gian delay bằng 0,"Có một trường hợp đặc biệt với hàmsetTimeoutlà thời giandelaybằng 0.
`setTimeout` `delay` Theo lý thuyết, khidelay = 0thì hành động được thực hiện ngay lập tức. Nhưng thực tế, hành động sẽ được thực hiện ngay khi code luồng chính thực hiện xong, ví dụ:
`delay = 0` 
```js
setTimeout(() => console.log(""World""));

console.log(""Hello"");
// Hello
// World
```
`setTimeout(() => console.log(""World""));

console.log(""Hello"");
// Hello
// World` Trong ví dụ trên, câu lệnhconsole.log(""Hello"")được thực hiện trước. Và ngay sau khi câu lệnh này thực hiện xong thì câu lệnhconsole.log(""World"")được thực hiện.
`console.log(""Hello"")` `console.log(""World"")` Lưu ý
Thời gian delay trên trình duyệt không hoàn toàn bằng0.
`0` Đối với cách gọi hàmsetTimeoutlồng nhau, sau 5 lần gọi hàm, thời gian delay sẽ được set bằng 4ms, ví dụ:
`setTimeout` 
```js
let start = Date.now();
let times = [];

setTimeout(function run() {
  // tính toán thời gian delay so với ban đầu
  times.push(Date.now() - start);

  // sau 100ms tính từ thời điểm bắt đầu thì sẽ in ra log và dừng lại
  if (Date.now() > start + 100) {
    console.log(times);
  } else {
    setTimeout(run); // tiếp tục setTimeout
  }
});

// kết quả cuối cùng:
// (22) [12,14,16,18,25,30,34,38,42,46,51,55,59,63,69,74,79,83,87,92,96,101]
```
`let start = Date.now();
let times = [];

setTimeout(function run() {
  // tính toán thời gian delay so với ban đầu
  times.push(Date.now() - start);

  // sau 100ms tính từ thời điểm bắt đầu thì sẽ in ra log và dừng lại
  if (Date.now() > start + 100) {
    console.log(times);
  } else {
    setTimeout(run); // tiếp tục setTimeout
  }
});

// kết quả cuối cùng:
// (22) [12,14,16,18,25,30,34,38,42,46,51,55,59,63,69,74,79,83,87,92,96,101]` Xem kết quả trên, bạn thấy rằng thời gian delay giữa mỗi lần gọi trong 5 lần đầu tiên là khoảng 2ms. Nhưng sau 5 lần thì thời gian delay tăng lên là khoảng 4ms.
Đây chính là giới hạn của hàmsetTimeouttrên trình duyệt. Và giới hạn này cũng gặp phải khi sử dụng hàmsetInterval.
`setTimeout` `setInterval` Ở môi trường khác như phía server, giới hạn này không gặp phải vì trên Node.js có hàmsetImmediate."
230,Hàm setTimeout trong Javascript,Tổng kết setTimeout trong JavaScript,"HàmsetTimeout(func, delay, ...args)trong JavaScript cho phép thực hiện hàmfuncmột lầnsau một khoảng thời giandelayvới các tham số truyền vào làargs.
`setTimeout(func, delay, ...args)` `func` `delay` `args` HàmsetInterval(func, delay, ...args)cũng tương tự như hàmsetTimeout, nhưng hàmfuncđược thực hiện saumỗi lầndelay.
`setInterval(func, delay, ...args)` `setTimeout` `func` `delay` Để hủy bỏ không gọi hàmfuncnữa, bạn có thể gọi hàmclearTimeout(timerId)hoặcclearInterval(timerId)vớitimerIdlà kết quả trả về sau khi gọi hàmsetTimeouthoặcsetInterval.
`func` `clearTimeout(timerId)` `clearInterval(timerId)` `timerId` `setTimeout` `setInterval` Việc gọi hàmsetTimeoutlồng nhau giúp bạn xử lý linh hoạt giá trịdelayhơn so với cách sử dụngsetInterval.
`setTimeout` `delay` `setInterval` Trường hợp gọi hàmsetTimeout(func, 0)với giá trịdelay = 0, tương đương vớisetTimeout(func)sẽ thực hiện hàmfuncngay sau khi luồng code chính thực hiện xong.
`setTimeout(func, 0)` `delay = 0` `setTimeout(func)` `func` Đối với trình duyệt, sau 5 lần gọi hàmsetTimeout(func)lồng nhau hoặc vớisetInterval(func)thì thời gian delay được set khoảng4ms.
`setTimeout(func)` `setInterval(func)`"
231,Hàm setTimeout trong Javascript,Thực hành,"Viết hàmprintNumbers(start, end)để in ra một số từstartđếnendsau mỗi 1 giây theo hai cách:
`printNumbers(start, end)` `start` `end` `setInterval` `setTimeout` Xem đáp án
►Cách 1: sử dụngsetInterval
`setInterval` 
```js
function printNumbers(start, end) {
  let timerId = setInterval(function run() {
    if (start > end) {
      clearInterval(timerId);
      return;
    }

    console.log(start++);
  }, 1000);
}

printNumbers(1, 5);
// 1, 2, 3, 4, 5
```
`function printNumbers(start, end) {
  let timerId = setInterval(function run() {
    if (start > end) {
      clearInterval(timerId);
      return;
    }

    console.log(start++);
  }, 1000);
}

printNumbers(1, 5);
// 1, 2, 3, 4, 5` ►Cách 2: sử dụngsetTimeout
`setTimeout` 
```js
function printNumbers(start, end) {
  setTimeout(function run() {
    if (start > end) {
      return;
    }

    console.log(start++);
    setTimeout(run, 1000);
  }, 1000);
}

printNumbers(1, 5);
// 1, 2, 3, 4, 5
```
`function printNumbers(start, end) {
  setTimeout(function run() {
    if (start > end) {
      return;
    }

    console.log(start++);
    setTimeout(run, 1000);
  }, 1000);
}

printNumbers(1, 5);
// 1, 2, 3, 4, 5` Trong đoạn code sau, hàmsetTimeoutđược gọi với thời gian delay là 100ms.
`setTimeout` Sau đó là mộtvòng lặpforvới số lần lặp khoảng 100000000 lần. Mà thời gian thực hiện vòng lặp lớn này thường hơn 100ms.
`for` Hỏi hàm vớisetTimeoutđược gọi khi nào?
`setTimeout` 
```js
let i = 0;

setTimeout(() => console.log(i), 100); // ?

// giả sử thời gian thực hiện vòng lặp lớn hơn 100ms
console.log(""trước vòng lặp"");
for (let j = 0; j < 100000000; j++) {
  i++;
}
console.log(""sau vòng lặp"");
```
`let i = 0;

setTimeout(() => console.log(i), 100); // ?

// giả sử thời gian thực hiện vòng lặp lớn hơn 100ms
console.log(""trước vòng lặp"");
for (let j = 0; j < 100000000; j++) {
  i++;
}
console.log(""sau vòng lặp"");` Xem đáp án
Kết quả
trước vòng lặpsau vòng lặp100000000
Nghĩa là hàm vớisetTimeoutđược gọi ngay sau vòng lặp.
`setTimeout` Tham khảo:"
232,Tất tần tật về hàm trong Javascript,Giới thiệu,"Function JavaScript (hàm trong JavaScript) là một thành phần không thể thiếu trong cấu trúc chương trình.
Hàm giúp chương trình trở nên rõ ràng, dễ hiểu bằng cách gộp những đoạn code lặp lại. Nhờ vậy mà việc bảo trì phần mềm cũng dễ dàng hơn.
Ngoài ra, một hàm tốt (độc lập và thực hiện một chức năng nhất định) có thể tái sử dụng trong nhiều dự án khác nhau. Điều này giúp nâng cao hiệu suất công việc của lập trình viên.
💡 Trong bài viết vềtương tác người dùng với: alert, confirm và promptbạn đã biết về các hàm có sẵn như:alert(),confirm()vàprompt().
`alert()` `confirm()` `prompt()` Sau đây, mình sẽ giới thiệu những thành phần cơ bản của hàm trong JavaScript. Qua đó, bạn sẽ hiểu hàm là gì, cách xây dựng hàm và ứng dụng hàm vào các dự án."
233,Tất tần tật về hàm trong Javascript,Hàm trong Javascript là gì?,"Hàm trong JavaScript là một chương trình con giúp thực thi một công việc cụ thể. Để định nghĩa hàm trong JavaScript, bạn sử dụng từ khoáfunctionvới cú pháp là:
`function` 
```js
function functionName([parameter1], [parameter2],...) {
  statement1;
  statement2;
  ...
}
```
`function functionName([parameter1], [parameter2],...) {
  statement1;
  statement2;
  ...
}` Trong đó:
`function` `([parameter1], [parameter2],...)` `{}` Ví dụ hàmsayHello():
`sayHello()` 
```js
function sayHello() {
  console.log('Hello from kungfutech.edu.vn')
}
```
`function sayHello() {
  console.log('Hello from kungfutech.edu.vn')
}` Để gọi hàm, bạn sử dụng tên hàm:

```js
function sayHello() {
  console.log('Hello from kungfutech.edu.vn')
}

sayHello()
// Hello from kungfutech.edu.vn
```
`function sayHello() {
  console.log('Hello from kungfutech.edu.vn')
}

sayHello()
// Hello from kungfutech.edu.vn` Khi gọi hàm, đoạn code bên trong thân hàm sẽ được thực thi. Trong ví dụ trên, đoạn codeconsole.logđược thực hiện hai lần (ứng với hai lần gọi hàm).
`console.log` Bạn có thể thấy rằng, hàm giúp tránh lặp lại code. Giả sử bạn cần thay đổi nội dung vớiconsole.logtrên, bạn chỉ cần thay đổimột chỗ(bên trong thân hàm).
`console.log` Đến đây chắc bạn đã phần nào hiểu được hàm là gì rồi phải không? Sau đây, mình sẽ đi vào chi tiết các đặc điểm của hàm trong JavaScript."
234,Tất tần tật về hàm trong Javascript,Biến cục bộ trong hàm,"Mộtbiếnđược khai báo bên trong hàm, chỉ sử dụng được bên trong thân hàm đó. Biến này gọi làbiến cục bộ(haybiến địa phương).
Ví dụ về biến cục bộ trong JavaScript:

```js
function sayHello() {
  const message = 'Hello from kungfutech.edu.vn'
  console.log(message)
}

sayHello() // Hello from kungfutech.edu.vn

console.log(message) // Uncaught ReferenceError: message is not defined
```
`function sayHello() {
  const message = 'Hello from kungfutech.edu.vn'
  console.log(message)
}

sayHello() // Hello from kungfutech.edu.vn

console.log(message) // Uncaught ReferenceError: message is not defined` Trong ví dụ trên, biếnmessagelà biến cục bộ bên trong hàmsayHello. Tức là biếnmessagechỉ dùng được ở trong thân hàmsayHello.
`message` `sayHello` `message` `sayHello` Khi bạn cố gắng truy cập vào biếnmessageở ngoài hàm, bạn sẽ bị lỗiUncaught ReferenceError: message is not defined.
`message`"
235,Tất tần tật về hàm trong Javascript,Biến ngoài hàm trong JavaScript,"Một hàm trong JavaScript có thể truy cập vào biến được khai báo bên ngoài hàm, ví dụ:

```js
let message = 'Hello from kungfutech.edu.vn'
function sayHello() {
  console.log(message)
}

sayHello() // Hello from kungfutech.edu.vn
```
`let message = 'Hello from kungfutech.edu.vn'
function sayHello() {
  console.log(message)
}

sayHello() // Hello from kungfutech.edu.vn` Hơn nữa, bạn có thể thay đổi giá trị của biến ngoài hàm từ trong thân hàm:

```js
let message = 'Hello from kungfutech.edu.vn'
function sayHello() {
  message = 'Hi!'
  console.log(message)
}

sayHello() // Hi!
console.log(message) // Hi!
```
`let message = 'Hello from kungfutech.edu.vn'
function sayHello() {
  message = 'Hi!'
  console.log(message)
}

sayHello() // Hi!
console.log(message) // Hi!` Tuy nhiên, nếu bên trong thân hàmkhai báo một biến trùng tênvới biến ngoài hàm thì biến ngoài hàm ""bị bỏ qua"":

```js
let message = 'Hello from kungfutech.edu.vn'
function sayHello() {
  let message = 'Hi!'
  console.log(message)
}

sayHello() // Hi!
console.log(message) // Hello from kungfutech.edu.vn
```
`let message = 'Hello from kungfutech.edu.vn'
function sayHello() {
  let message = 'Hi!'
  console.log(message)
}

sayHello() // Hi!
console.log(message) // Hello from kungfutech.edu.vn` 📝Biến toàn cục"
236,Tất tần tật về hàm trong Javascript,Truyền tham số vào hàm,"Trong trường hợp bạn muốn sử dụng giá trị của biến bên ngoài vào trong thân hàm, bạn có thể truyền tham số vào hàm (thay vì sử dụng biến toàn cục).
Ví dụ truyền tham số vào hàm:

```js
function sayHello(message) {
  console.log(message)
}

sayHello('Hello!') // Hello!
sayHello('Hi!') // Hi!
```
`function sayHello(message) {
  console.log(message)
}

sayHello('Hello!') // Hello!
sayHello('Hi!') // Hi!` Khi hàmsayHellođược gọi, giá trịstringđược sao chép (copy) vào biến cục bộmessage. Trong thân hàm sẽ sử dụng biến cục bộ đó.
`sayHello` `message` khi truyền tham số vào hàm (ngoại trừ object là kiểu dữ liệu tham chiếu), hàm trong JavaScript luôn thực hiện sao chép dữ liệu mà không làm thay đổi giá trị biến bên ngoài.
Ví dụ:

```js
let message = 'Hello from kungfutech.edu.vn'
function sayHello(message) {
  message = 'Hi!'
  console.log(message)
}

sayHello() // Hi!
console.log(message) // Hello from kungfutech.edu.vn
```
`let message = 'Hello from kungfutech.edu.vn'
function sayHello(message) {
  message = 'Hi!'
  console.log(message)
}

sayHello() // Hi!
console.log(message) // Hello from kungfutech.edu.vn` Bạn thấy rằng là bên trong hàm đã gán giá trịHi!cho biếnmessage. Nhưng giá trị của biếnmessagebên ngoài không hề thay đổi.
`Hi!` `message` `message` 📝 Số lượng tham số của hàm là không giới hạn.
Ví dụ hàm có nhiều tham số:

```js
function sayHello(message, site) {
  console.log(message + ' from ' + site)
}

sayHello('Hello', 'kungfutech.edu.vn') // Hello from kungfutech.edu.vn
```
`function sayHello(message, site) {
  console.log(message + ' from ' + site)
}

sayHello('Hello', 'kungfutech.edu.vn') // Hello from kungfutech.edu.vn`"
237,Tất tần tật về hàm trong Javascript,Giá trị tham số mặc định,"Đối với hàm có tham số mà khi gọi hàm, bạn không truyền giá trị vào thì giá trị của tham số đó làundefined, ví dụ:
`undefined` 
```js
function sayHello(message, site) {
  console.log(message + ' from ' + site)
}

sayHello('Hello') // Hello from undefined
```
`function sayHello(message, site) {
  console.log(message + ' from ' + site)
}

sayHello('Hello') // Hello from undefined` Trong trường hợp này, bạn có thể định nghĩa ""giá trị mặc định"" cho tham số bằng cách sử dụngtoán tửgán=như sau:
`=` 
```js
function sayHello(message, site = 'kungfutech.edu.vn') {
  console.log(message + ' from ' + site)
}

sayHello('Hello') // Hello from kungfutech.edu.vn
```
`function sayHello(message, site = 'kungfutech.edu.vn') {
  console.log(message + ' from ' + site)
}

sayHello('Hello') // Hello from kungfutech.edu.vn` Lúc này, nếu bạn không truyền giá trị vào tham sốsitethì giá trị của nó mặc định làkungfutech.edu.vn.
`site` `kungfutech.edu.vn` Trong ví dụ trên, giá trị mặc định chỉ là một giá trịstring. Tuy nhiên, giá trị mặc định có thể là mộtbiểu thứchoặc thậm chí là mộthàm khác, ví dụ:
`string` 
```js
function aFunction() {
  // code
}

function sayHello(message, site = aFunction()) {
  console.log(message + ' from ' + site)
}
```
`function aFunction() {
  // code
}

function sayHello(message, site = aFunction()) {
  console.log(message + ' from ' + site)
}` Trong ví trên, hàmaFunction()chỉ được gọi khi bạn không truyền giá trị cho tham sốsite.
`aFunction()` `site`"
238,Tất tần tật về hàm trong Javascript,Return trong JavaScript,"Hàm trong JavaScript có thể trả về giá trị khi gọi hàm.
Ví dụ hàm tính tổng hai số:

```js
function sum(a, b) {
  return a + b
}

const result = sum(1, 2)
console.log(result) // 3
```
`function sum(a, b) {
  return a + b
}

const result = sum(1, 2)
console.log(result) // 3` Từ khóareturntrong JavaScript có thể đặt ở bất kỳ đâu trong thân hàm. Khi gặp từ khóareturn, hàm sẽ dừng lại và trả về giá trị saureturn.
`return` `return` `return` Có thể dùng nhiều từ khóareturntrong hàm:
`return` 
```js
function sum(a, b) {
  if (a === null || a === undefined) {
    console.log('Tham số không hợp lệ!')
    return
  }

  if (b === null || b === undefined) {
    console.log('Tham số không hợp lệ!')
    return
  }

  return a + b
}

const result1 = sum() // Tham số không hợp lệ!
```
`function sum(a, b) {
  if (a === null || a === undefined) {
    console.log('Tham số không hợp lệ!')
    return
  }

  if (b === null || b === undefined) {
    console.log('Tham số không hợp lệ!')
    return
  }

  return a + b
}

const result1 = sum() // Tham số không hợp lệ!` Ví dụ trên, mình kiểm tra điều kiện choavàb. Nếu chúng bằngnullhoặcundefinedthì sẽreturnluôn mà không thực hiện tính tổng.
`a` `b` `null` `undefined` `return` Bạn cũng thấy rằng, hai vị tríreturnđầu tiên không có giá trị nào theo sau. Khi đó, giá trị trả về mặc định làundefined:
`return` `undefined` 
```js
function sum(a, b) {
  return
}

let r = sum(1, 2)
console.log(r) // undefined
```
`function sum(a, b) {
  return
}

let r = sum(1, 2)
console.log(r) // undefined` Ngoài ra, nếu hàm không córeturnthì giá trị trả về cũng làundefined:
`return` `undefined` 
```js
function sum(a, b) {}

let r = sum(1, 2)
console.log(r) // undefined
```
`function sum(a, b) {}

let r = sum(1, 2)
console.log(r) // undefined` không được xuống dòng ngay saureturn. Vì JavaScript sẽ hiểu là bạn khôngreturngiá trị nào cả.
`return` `return` Ví dụ:

```js
function sum(a, b) {
  return
  a + b
}

const result = sum(1, 2)
console.log(result) // undefined
```
`function sum(a, b) {
  return
  a + b
}

const result = sum(1, 2)
console.log(result) // undefined` Trình thông dịch JavaScript sẽ tự động thêm dấu;ngay saureturn. Do đó, giá trị trả về của hàm trên làundefined. Và thành phầna + bphía dưới sẽ không bao giờ được chạy tới.
`;` `return` `undefined` `a + b` Nếu cần xuống dòng thì bạn phải đưa giá trị trả về vào trong cặp dấu ngoặc đơn()như sau:
`()` 
```js
function sum(a, b) {
  return a + b
}

const result = sum(1, 2)
console.log(result) // 3
```
`function sum(a, b) {
  return a + b
}

const result = sum(1, 2)
console.log(result) // 3`"
239,Tất tần tật về hàm trong Javascript,Cách đặt tên hàm trong JavaScript,"Quy tắc đặt tên hàm trong JavaScript cũng giống như quy tắc đặt tên biến hay hằng trong JavaScript:
`_` `$` Chuẩn hóa cách đặt tên hàm
Vì hàm ứng với một hành động, nên tên hàm chuẩn thường bắt đầu bằng mộtđộng từ.
Ví dụ một số động từ hay dùng để đặt tên hàm:
`get...` `set...` `check...` `boolean` `display...` Dĩ nhiên, JavaScript không quy định bạn phải đặt tên như vậy. Bạn chỉ cần đặt tên đúng theo quy tắc phía trên là đủ.
Nhưng rõ ràng là nếu bạn đặt tên đúng chuẩn thì đồng nghiệp hoặc chính bản thân bạn khi đọc code sẽ dễ dàng hiểu được ý nghĩa của từng hàm."
240,Tất tần tật về hàm trong Javascript,Sự phát sinh hàm trong chương trình,"Khi lập trình, thông thường sẽ có hai trường hợp mà bạn nên viết hàm:
Với những dự án lớn, mỗi thành viên thường chỉ được làm những module nhỏ trong toàn bộ một project lớn.
Sau đó khi các module nhỏ hoàn thành, sẽ có người ghép những module nhỏ đó thành một chương trình hoàn chỉnh.
Do đó, việc phân chia chương trình thành những hàm tốt là vô cùng quan trọng.
Như thế nào là một hàm tốt?
Đây là một câu hỏi rất khó để trả lời. Theo mình, hàm tốt là hàm thỏa mãn một số điều kiện sau:
Tuy nhiên, không phải lúc nào bạn cũng có thể thoả mãn những yêu cầu trên. Hoặc không nhất thiết phải thoả mãn tất cả những yêu cầu trên."
241,Tất tần tật về hàm trong Javascript,Pure function và non-pure function,"Nhìn chung, có hai loại hàm trong JavaScript làpurefunction (hàm thuần khiết) vànon-purefunction (hàm không thuần khiết).
Hàm thuần khiếtlà hàm không phụ thuộc vào yếu tố bên ngoài (biến toàn cục, môi trường thực thi,...). Bất cứ khi nào bạn gọi hàm thuần khiết với cùng một đối số thì kết quả trả về luôn giống nhau.
Do đó, pure function rất dễ để sử dụng, tái sử dụng hay bảo trì,... Theo mình, hàm thuần khiết là một hàm tốt.
Ví dụ hàm thuần khiết:

```js
function pureFunc(number, factor) {
  return number * factor
}

let ret = pureFunc(2, 10)
console.log(ret) // 20
```
`function pureFunc(number, factor) {
  return number * factor
}

let ret = pureFunc(2, 10)
console.log(ret) // 20` Bạn thấy rằng, với cùng một giá trị truyền vào là2và10thì kết quả luôn là20. Do đó, hàm trên làhàm thuần khiết.
`2` `10` `20` Ngược lại với hàm thuần khiết,hàm không thuần khiếtlà hàm phụ thuộc vào biến toàn cục hay môi trường thực thi.
Vì vậy, khi bạn gọi cùng một hàm với cùng một đối số, nhưng kết quả lại có thể khác nhau.

```js
let factor = 10

function nonPureFunc(number) {
  return number * factor
}

let ret = nonPureFunc(2)
console.log(ret) // 20

factor = 11
ret = nonPureFunc(2)
console.log(ret) // => 22
```
`let factor = 10

function nonPureFunc(number) {
  return number * factor
}

let ret = nonPureFunc(2)
console.log(ret) // 20

factor = 11
ret = nonPureFunc(2)
console.log(ret) // => 22` Rõ ràng, hàmnonPureFunckhông phải là hàm thuần khiết. Vì hàm này phụ thuộc vào biến ngoài hàm làfactor.
`nonPureFunc` `factor` Nghĩa là khi giá trị của biếnfactorthay đổi, kết quả trả về của hàm cũng thay đổi (dù cho cùng giá trị truyền vào là2).
`factor` `2`"
242,Tất tần tật về hàm trong Javascript,Tổng kết,"Vậy hàm là gì?
Hàm trong JavaScript là một chương trình con giúp thực thi một công việc cụ thể với cú pháp là:

```js
function functionName([parameter1], [parameter2],...) {
      statement1;
      statement2;
      ...
    }
```
`function functionName([parameter1], [parameter2],...) {
      statement1;
      statement2;
      ...
    }` Trong đó:
`undefined` `=` `return` `return` `return` `return` `return` `return` `undefined` Quy tắc đặt tên hàm cũng giống quy tắc đặt tên biến và hằng. Và tên hàm nên bắt đầu bằng một động từ.
Nên ưu tiên viết hàmthuần khiếtđể dễ dàng tái sử dụng, dễ dàng kiểm thử và tránh lỗi."
243,Tất tần tật về hàm trong Javascript,Thực hành,"Viết hàm trả về giá trị nhỏ nhất của hai số (giả sử giá trị truyền nào luôn là số).
Xem đáp án

```js
function min(a, b) {
  return a < b ? a : b
}

min(2, 5) // 2
min(4, -1) // -1
min(3, 3) // 3
```
`function min(a, b) {
  return a < b ? a : b
}

min(2, 5) // 2
min(4, -1) // -1
min(3, 3) // 3` Trường hợp hai số truyền vào bằng nhau thì dĩ nhiên kết quả là giá trị của hai số đó.
Viết hàm kiểm tra xem một số có phải là số nguyên tố hay không. Nếu là số nguyên tố thì trả vềtrue. Ngược lại, trả vềfalse.
`true` `false` Xem đáp án

```js
function isPrime(number) {
  if (isNaN(number)) return false

  if (number < 2) return false
  if (number === 2) return true

  for (i = 2; i * i <= number; i++) {
    if (number % i === 0) return false
  }

  return true
}

// Ví dụ:
isPrime('abc') // false
isPrime(0) // false
isPrime(2) // true
isPrime(5) // true
isPrime(6) // false
```
`function isPrime(number) {
  if (isNaN(number)) return false

  if (number < 2) return false
  if (number === 2) return true

  for (i = 2; i * i <= number; i++) {
    if (number % i === 0) return false
  }

  return true
}

// Ví dụ:
isPrime('abc') // false
isPrime(0) // false
isPrime(2) // true
isPrime(5) // true
isPrime(6) // false` Trong đó, hàmisNaN(number)dùng để kiểm tra giá trị của biếnnumberxem có phải làNaNhay không. Nói cách khác, nếuisNaN(number)trả vềfalsethì giá trị củanumberlà số.
`isNaN(number)` `number` `NaN` `isNaN(number)` `false` `number`"
244,"Hàm tương tác với người dùng alert, confirm, prompt",Giới thiệu,"Trong bài viết vềchương trình JavaScript đầu tiên, mình có đề cập đến việc hiển thị hộp thoại với hàmalert. Đây là một trong ba hàm giúp tương tác người dùng mà mình sẽ tìm hiểu kỹ hơn trong bài viết này.
`alert`"
245,"Hàm tương tác với người dùng alert, confirm, prompt",Tương tác người dùng với hàmalert,"`alert` Hàmalertdùng để hiển thị hộp thoại, bao gồm nội dung tin nhắn và nút bấm (button)OK. Khi người dùng bấm vàoOKthì hộp thoại sẽ đóng lại.
`alert` Cú pháp:

```js
alert(message);
```
`alert(message);` 
```js
alert(""Say hello from kungfutech.edu.vn"");
```
`alert(""Say hello from kungfutech.edu.vn"");` Kết quả:
Hộp thoại này còn được gọi là ""modal window"". Nghĩa là người dùngchỉ tương tác được với hộp thoạimàkhông tương tác được với nội dung còn lạicủa trang web (bên dưới hộp thoại)."
246,"Hàm tương tác với người dùng alert, confirm, prompt",Tương tác người dùng với hàmconfirm,"`confirm` Tương tự như hàmalert, hàmconfirmcũng đưa ra một thông báo trực tiếp tới người dùng.
`alert` `confirm` Tuy nhiên, hàmconfirmyêu cầu người dùng xác nhận bằng cách chọnOKhoặcCancel.
`confirm` `confirm` `true` `false` Cú pháp:

```js
result = confirm(message);
```
`result = confirm(message);` Ví dụ:

```js
const result = confirm(""Bạn muốn tiếp tục sử dụng chương trình?"");
alert(result);

// result = true nếu người dùng bấm OK.
// result = false nếu người dùng bấm Cancel.
```
`const result = confirm(""Bạn muốn tiếp tục sử dụng chương trình?"");
alert(result);

// result = true nếu người dùng bấm OK.
// result = false nếu người dùng bấm Cancel.` Kết quả:
Tương tự như hàmalert, hộp thoại với hàmconfirmcũng là dạng ""modal window"".
`alert` `confirm`"
247,"Hàm tương tác với người dùng alert, confirm, prompt",Tương tác người dùng với hàmprompt,"`prompt` Hàmpromptcũng lại tương tự như hàmconfirmvà hàmalertnhưng cho phép người dùng nhập vàostring.
`prompt` `confirm` `alert` Cú pháp:

```js
result = prompt(title, [defaultValue]);
```
`result = prompt(title, [defaultValue]);` Trong đó:
Ví dụ:

```js
const name = prompt(""Nhập vào tên của bạn:"", ""Anonymous"");
alert(name);
```
`const name = prompt(""Nhập vào tên của bạn:"", ""Anonymous"");
alert(name);` Kết quả:
Trong ví dụ trên:
`Nhập vào tên của bạn:` `Anonymous` Khi người dùng nhấn vàoOKhoặcCancelthì hộp thoại sẽ đóng lại. Với trường hợpOK, giá trị trả về là giá trị trong ô nhậpinputlúc đó. Với trường hợpCancelthì giá trị trả về lànull.
`null`"
248,"Hàm tương tác với người dùng alert, confirm, prompt",Tổng kết,"Trên đây mình đã giới thiệu với bạn về ba hàm tương tác người dùng:
`alert` `confirm` `true` `false` `prompt` `null` Cả ba hàm trên đều hiển thị hộp thoại dạng ""modal window"". Nghĩa là người dùng chỉ tương tác được với hộp thoại mà không tương tác được với nội dung bên dưới hộp thoại.
Bạn có thể thấy rằng, ba hàm trên đều rất đơn giản, dễ sử dụng. Nhưng nhược điểm của chúng là: bạn không thể quyết định được giao diện hiển thị của hộp thoại. Mà giao diện hộp thoại hoàn toàn phụ thuộc vào trình duyệt."
249,"Hàm tương tác với người dùng alert, confirm, prompt",Thực hành,"Tạo một trang web đơn giản với chức năng là hỏi người dùng bao nhiêu tuổi ""How old are you?"", với giá trị mặc định là18.
`18` Sau đó, hiển thị nội dung tương ứng với giá trị người dùng nhập vào ""You are X years old!"" (vớiXlà giá trị người dùng đã nhập).
Xem đáp án

```js
<html>
  <body>
    <script>
      const age = prompt(""How old are you!"", 18);
      alert(""You are "" + age + "" years old!"");
    </script>
  </body>
</html>
```
`<html>
  <body>
    <script>
      const age = prompt(""How old are you!"", 18);
      alert(""You are "" + age + "" years old!"");
    </script>
  </body>
</html>`"
250,Tìm hiểu hằng trong JavaScript,Giới thiệu,"Tương tự nhưbiến, hằng cũng là một thành phần quan trọng trong lập trình JavaScript. Sau đây, mình sẽ tìm hiểu xem hằng là gì, cách khai báo hằng trong JavaScript, cách đặt tên hằng. Đồng thời, mình so sánh sự khác nhau giữa hằng và biến trong JavaScript."
251,Tìm hiểu hằng trong JavaScript,Hằng trong Javascript là gì?,"Hằng là ""tên biểu tượng"" đại diện cho một giá trị không thay đổi trong chương trình.
Ví dụ: gọi PI làsố Pitrong toán học, có giá trị không đổi là3.14159. Khi đó, PI gọi là hằng số."
252,Tìm hiểu hằng trong JavaScript,Cách khai báo hằng trong JavaScript,"Để khai báo hằng trong JavaScript, bạn dùng từ khóaconst, với cú pháp như sau:
`const` 
```js
const <tên hằng> = <giá trị của hằng>;
```
`const <tên hằng> = <giá trị của hằng>;` Ví dụ với số PI trên:

```js
const PI = 3.14159;
```
`const PI = 3.14159;` Để truy cập giá trị của hằng, bạn dùng trực tiếp tên của hằng:

```js
const PI = 3.14159;

console.log(PI); // Kết quả hiển trị trên console: 3.14159
```
`const PI = 3.14159;

console.log(PI); // Kết quả hiển trị trên console: 3.14159` Để khai báo nhiều hằng số, bạn có thể sử dụng dấy phẩy (,) để ngăn cách các hằng trên cùng một dòng:
`,` 
```js
const PI = 3.141519,
  MAX_ITEM = 1000000000,
  MIN_ITEM = 0;
```
`const PI = 3.141519,
  MAX_ITEM = 1000000000,
  MIN_ITEM = 0;` Hoặc bạn cũng có thể viết như sau:

```js
const PI = 3.141519,
  MAX_ITEM = 1000000000,
  MIN_ITEM = 0;
```
`const PI = 3.141519,
  MAX_ITEM = 1000000000,
  MIN_ITEM = 0;` Hoặc viết với dấu phẩy trên đầu:

```js
const PI = 3.141519,
  MAX_ITEM = 1000000000,
  MIN_ITEM = 0;
```
`const PI = 3.141519,
  MAX_ITEM = 1000000000,
  MIN_ITEM = 0;` Tuy nhiên, mình thấy việc khai báo mỗi hằng số trên một dòng là dễ nhìn hơn cả:

```js
const PI = 3.141519;
const MAX_ITEM = 1000000000;
const MIN_ITEM = 0;
```
`const PI = 3.141519;
const MAX_ITEM = 1000000000;
const MIN_ITEM = 0;` Về cơ bản, các cách trên là giống nhau. Tùy thuộc sở thích của bạn mà lựa chọn sao cho phù hợp."
253,Tìm hiểu hằng trong JavaScript,Quy tắc đặt tên hằng trong JavaScript,"Quy tắc đặt tên hằng trong JS cũng giống quy tắc đặt tên biến trong JavaScript. Sau đây, mình nhắc lại các quy tắc đặt tên cho bạn tiện theo dõi:
`_` `$` Từ khoá (keywords) là những từ mang ý nghĩa đặc biệt. Từconstlà một từ khoá, với ý nghĩa là để khai báo hằng.
Từ dự trữ (reserved words) là những từ sẽ được dùng làm từ khoá cho những phiên bản sau của JavaScript. Bạn không thể sử dụng từ khoá hay từ dự trữ để đặt tên cho hằng số.
Danh sách những từ khoá và những từ dự trữ:
breakcasecatchclassconstcontinuedebuggerdefaultdeletedoelseenumexportextendsfalsefinallyforfunctionifimplementsimportininstanceofinterfaceletnewnullpackageprivateprotectedpublicreturnstaticsuperswitchthisthrowtruetrytypeofvarvoidwhilewithyield
`break` `case` `catch` `class` `const` `continue` `debugger` `default` `delete` `do` `else` `enum` `export` `extends` `false` `finally` `for` `function` `if` `implements` `import` `in` `instanceof` `interface` `let` `new` `null` `package` `private` `protected` `public` `return` `static` `super` `switch` `this` `throw` `true` `try` `typeof` `var` `void` `while` `with` `yield` Ví dụ những tên hằng hợp lệ

```js
const temp = 1000;
const _result2 = 99;
const $___$ = ""hehehe"";
const I_AM_STRONG = true;
const dientichhinhvuong = 6996;
```
`const temp = 1000;
const _result2 = 99;
const $___$ = ""hehehe"";
const I_AM_STRONG = true;
const dientichhinhvuong = 6996;` những tên hằng không hợp lệ:

```js
const vertex% = 50;     // sử dụng kí tự đặc biệt %
    const 4me = 'passion';  // bắt đầu bằng số
    const while = 'coding'; // sử dụng từ khoá ""while""
```
`const vertex% = 50;     // sử dụng kí tự đặc biệt %
    const 4me = 'passion';  // bắt đầu bằng số
    const while = 'coding'; // sử dụng từ khoá ""while""` Một sốchú ýkhi đặt tên biến:"
254,Tìm hiểu hằng trong JavaScript,Chuẩn hóa cách đặt tên hằng số,"Cũng lại tương tự như biến, bạn chỉ cần đặt tên hằng đúng theo quy tắc trên là đủ. Tuy nhiên, nếu nói về chuẩn hóa thì mình thấy có hai cách đặt tên hằng phổ biến như sau.
Cách 1: Đối với những hằng số biết trước khi lập trình
Bạn cần lưu mã màu của một số màu thường dùng trong dự án:

```js
const COLOR_BLACK = ""#000000"";
const COLOR_WHITE = ""#FFFFFF"";
const COLOR_RED = ""#FF0000"";
const COLOR_GREEN = ""#00FF00"";
const COLOR_BLUE = ""#0000FF"";
```
`const COLOR_BLACK = ""#000000"";
const COLOR_WHITE = ""#FFFFFF"";
const COLOR_RED = ""#FF0000"";
const COLOR_GREEN = ""#00FF00"";
const COLOR_BLUE = ""#0000FF"";` Đối với những hằng số kiểu này, bạnVIẾT IN HOAtoàn bộ các chữ cái và sử dụng dấu gạch dưới (_) để ngăn cách các từ cho dễ đọc.
`_` Cách 2: Đối với những hằng số được sinh ra trong quá trình chạy
Bạn cần lưu thời gian tải trang:

```js
const timeToLoadPage = /* Xử lý một số thứ để tính ra thời gian tải trang */
```
`const timeToLoadPage = /* Xử lý một số thứ để tính ra thời gian tải trang */` Rõ ràng bạn không thể biếtchính xácthời gian tải trang lúc lập trình nên trang web. Vì thời gian tải trang chính xác phụ thuộc vào các yếu tố bên ngoài như: tốc độ mạng, khả năng xử lý của server,...
Nhưng một khi trang web đã tải xong rồi thì giá trị này lại không thay đổi trong toàn bộ chương trình.
Đối với những hằng số kiểu này, bạn sử dụng cách đặt tên theocamelCase(viết thường từ đầu tiên, và viết hoa chữ cái đầu của các từ tiếp theo)."
255,Tìm hiểu hằng trong JavaScript,Lợi ích của việc sử dụng hằng số,"➤ Có thể nhiều bạn đặt câu hỏi:Tại sao có biến rồi lại còn sinh ra hằng làm gì?
Trong lập trình, luôn có những giá trị không bao giờ thay đổi trong toàn bộ chương trình.
Nếu chỉ sử dụng biến thì rất có thể bạn hoặc đồng nghiệp sẽ vô tình thay đổi giá trị của biến. Điều này dẫn đến những lỗi sai mà không thể lường trước được.
➤ Hoặc có bạn bảo rằng:Tại sao không sử dụng trực tiếp giá trị của hằng số luôn?
Trong ví dụ về màu trên, giả sử bạn không khai báo hằngCOLOR_BLACKmà sử dụng trực tiếp#000000. Kiểu này trong lập trình gọi làhard-coded.
`COLOR_BLACK` `#000000` Cách nàythường không tốt.
Nếu bạn sử dụng#000000ở một chỗ thì không sao. Nhưng nếu bạn dùng ở nhiều nơi và giả sử mình muốn thay đổi mã màu đen thành#111111thì mình phải tìm kiếm tất cả những chỗ sử dụng#000000để đổi thành#111111.
`#000000` `#111111` `#000000` `#111111` Việc làm này rất dễbỏ sótmột vài chỗ, dẫn đến bug chương trình. Ngược lại, nếu mình sử dụng hằngCOLOR_BLACKthì mình chỉ cần sửa đúng một chỗ.
`COLOR_BLACK` Ngoài ra, bạn có thể thấy:
`COLOR_BLACK` `#000000` `COLOR_BLACK` `#000000` `COLOR_BLACK` `#000000`"
256,Tìm hiểu hằng trong JavaScript,Một số lỗi với hằng trong JavaScript,"Khi sử dụng hằng trong JavaScript, bạn có thể mắc phải một số lỗi như sau.
Bạn có thể thấy sự khác biệt giữa hằng và biến trong việc khai báo.
Đối với biến trong JS, bạn có thể khai báo biến trước rồi gán giá trị cho biến sau.
Đối với hằng trong JS, bạn phảigán ngay giá trịcho hằng sau khi khai báo. Ngược lại, bạn sẽ bị lỗi:

```js
const PI;
    // Uncaught SyntaxError: Missing initializer in const declaration
```
`const PI;
    // Uncaught SyntaxError: Missing initializer in const declaration` Hằng số không thể thay đổi giá trị trong toàn bộ chương trình. Việc bạn thay đổi giá trị của hằng sẽ dẫn đến lỗi như sau:

```js
const PI = 3.14159;

PI = 100; // Uncaught TypeError: Assignment to constant variable.
```
`const PI = 3.14159;

PI = 100; // Uncaught TypeError: Assignment to constant variable.`"
257,Tìm hiểu hằng trong JavaScript,Tổng kết,"Vậy hằng là gì?
`const <tên hằng> = <giá trị của hằng>;` `_` `$` `_` `COLOR_BLACK` `timeToLoadPage`"
258,Tìm hiểu hằng trong JavaScript,Thực hành,"```js
const value = 111;
const _ret100@ = ""lalala"";
const $$__abc = ""xyz"";
const 1point = '2d';
const MAX_NUMBER = 1000000000;
const chu_vi_hinh_tron = 400;
const x*b = 404;
const if = true;
```
`const value = 111;
const _ret100@ = ""lalala"";
const $$__abc = ""xyz"";
const 1point = '2d';
const MAX_NUMBER = 1000000000;
const chu_vi_hinh_tron = 400;
const x*b = 404;
const if = true;` Và chỉ ra chính xác lỗi sai là gì?
Đáp án

```js
const value = 111; // Đúng
const _ret100^ = ""lalala""; // Sai vì dùng kí tự đặc biệt ^
const $$__abc = ""xyz""; // Đúng
const 1point = '2d'; // Sai vì bắt đầu bằng số
const MAX_NUMBER = 1000000000; // Đúng
const chu_vi_hinh_tron = 400; // Đúng
const x*b = 404; // Sai vì dùng kí tự đặc biệt *
const if = true; // Sai vì dùng từ khóa
```
`const value = 111; // Đúng
const _ret100^ = ""lalala""; // Sai vì dùng kí tự đặc biệt ^
const $$__abc = ""xyz""; // Đúng
const 1point = '2d'; // Sai vì bắt đầu bằng số
const MAX_NUMBER = 1000000000; // Đúng
const chu_vi_hinh_tron = 400; // Đúng
const x*b = 404; // Sai vì dùng kí tự đặc biệt *
const if = true; // Sai vì dùng từ khóa` Đáp án

```js
// 1. Khai báo hai hằng ""COLOR_ORANGE"" và ""COLOR_YELLOW""
const COLOR_ORANGE = ""#FFA500"";
const COLOR_YELLOW = ""#FFFF00"";

// 2. In ra giá trị của hai hằng số trên ra console.log.
console.log(COLOR_ORANGE); // #FFA500
console.log(COLOR_YELLOW); // #FFFF00

// 3. Khai báo biến ""currentColor"" với giá trị bằng ""COLOR_ORANGE"".
let currentColor = COLOR_ORANGE;

// 4. In ra console giá trị của biến ""currentColor""
console.log(currentColor); // #FFA500
```
`// 1. Khai báo hai hằng ""COLOR_ORANGE"" và ""COLOR_YELLOW""
const COLOR_ORANGE = ""#FFA500"";
const COLOR_YELLOW = ""#FFFF00"";

// 2. In ra giá trị của hai hằng số trên ra console.log.
console.log(COLOR_ORANGE); // #FFA500
console.log(COLOR_YELLOW); // #FFFF00

// 3. Khai báo biến ""currentColor"" với giá trị bằng ""COLOR_ORANGE"".
let currentColor = COLOR_ORANGE;

// 4. In ra console giá trị của biến ""currentColor""
console.log(currentColor); // #FFA500`"
259,HTML String sang DOM Node với DOMParser,Giới thiệu,"Khi lập trình Web nói chung vàlập trình JavaScriptnói riêng, nhiều khi bạn sẽ cần phải render thêm các thành phần trang web từ JavaScript. Và trong trường hợp thành phần HTML đó được lưu dưới dạng string, bạn có thể sử dụngDOMParserđể chuyển HTML String sang DOM Node. Cách làm vô cùng đơn giản như sau."
260,HTML String sang DOM Node với DOMParser,Cách chuyển HTML String sang DOM,"Bước 1: Tạo mới một đối tượng củaDOMParser.

```js
let domParser = new DOMParser();
```
`let domParser = new DOMParser();` Bước 2: Sử dụng phương thứcparseFromStringcủa DOMParser.

```js
let doc = domParser.parseFromString(""<div>Hello</div>"", ""text/html"");
console.log(doc);
```
`let doc = domParser.parseFromString(""<div>Hello</div>"", ""text/html"");
console.log(doc);` Kết quả trả về là một document
Hello
Trong hàm parseFromString, tham số đầu tiên là nội dung HTMLstringmà bạn muốn parse; và tham số tiếp theo là kiểu string.
Có 3 kiểu string được support là:application/xml,image/svg+xmlvàtext/html. Đối với bài toán này, bạn sẽ chọn kiểu text/html.
Kết quả trả về sẽ là mộtdocument, với đầy đủ các thẻ<html>,<head>,<body>và các node được tạo ra từ string đầu vào như trên.
`<html>` `<head>` `<body>` Bước 3: Lấy ra mảng các node mới được tạo ra
Thực tế, thường bạn chỉ cần các node mới để chèn vào một file HTML có sẵn của riêng bạn. Khi đó bạn có thể làm như này:

```js
let nodes = document.body.chidNodes;
console.log(nodes);

// => NodeList [div]
```
`let nodes = document.body.chidNodes;
console.log(nodes);

// => NodeList [div]` Đến đây, bạn sẽ thu được mộtmảngcác node - NodeList. Và bây giờ, bạn hoàn toàn tự do sử dụng NodeList này để chèn vào bất cứ đâu trên trang HTML."
261,HTML String sang DOM Node với DOMParser,Chuyển HTML String thành DOM và vẽ lên HTML,"Sau đây là một ví dụ minh họa cho phần phía trên. Bạn nhấn vào buttonAddđể chuyển HTML String thành DOM Node, sau đó vẽ lên giao diện. Sau đó, bạn có thể nhấn buttonRemoveđể xóa bỏ đi các node mới thêm vào vừa rồi.

Trên giao diện ngoài 2 button Add và Remove, có một phần tử quan trọng là thẻ div vớiid=""container"". Thẻ này được dùng làm container để chứa các node mới được parse từ JavaScript.

```js
<div id=""container""></div>
```
`<div id=""container""></div>` Ở đây, mình gộp cả 3 bước phía trên thành hàm getNodes:

```js
let getNodes = (str) =>
  new DOMParser().parseFromString(str, ""text/html"").body.childNodes;
```
`let getNodes = (str) =>
  new DOMParser().parseFromString(str, ""text/html"").body.childNodes;` Bạn sử dụng hàm số này để lấy về mảng các node với đầu vào là một HTML string.

```js
let nodes = getNodes(""<div><span>1</span></div><div><span>2</span></div>"");
```
`let nodes = getNodes(""<div><span>1</span></div><div><span>2</span></div>"");` Sau đó, bạn thêm các node này vào HTML bằng cách nhấn button Add:

```js
btnAdd.addEventListener(""click"", function () {
  nodes.forEach((node) => container.appendChild(node.cloneNode(true)));
});
```
`btnAdd.addEventListener(""click"", function () {
  nodes.forEach((node) => container.appendChild(node.cloneNode(true)));
});` Vì nodes là kiểu mảng, nên mình sử dụng phương thứcforEachđể duyệt. Mỗi phần tử node trong mảng sẽ được sao chép (clone) ra một node mới, để dùng lại sau này.

```js
node.cloneNode(true);
```
`node.cloneNode(true);` Sau đó, chèn node mới này vào node container sử dụng phương thứcNode.appendChild.

```js
container.appendChild(node.cloneNode(true));
```
`container.appendChild(node.cloneNode(true));` Ngoài ra, để bỏ đi các node mới thêm vào, mình sẽ sử dụng một vòng lặp lấy raNode.firstChildcủa node container vàdeletenó đi, cho đến khi container không còn node con nữa là hoàn thành công việc.

```js
btnRm.addEventListener(""click"", function () {
  while (container.firstChild) {
    delete container.removeChild(container.firstChild);
  }
});
```
`btnRm.addEventListener(""click"", function () {
  while (container.firstChild) {
    delete container.removeChild(container.firstChild);
  }
});` Lưu ý
Thông thường, bạn sẽ chỉ sử dụng hàmNode.removeChild()mà không delete. Việc này sẽ dẫn đến leak memory."
262,HTML String sang DOM Node với DOMParser,Kết luận,"Trên đây là cách làm đơn giản để chuyển HTML String sang DOM node và thêm chúng vào giao diện HTML. Tuy nhiên, cách làm này có một nhược điểm là khi cấu trúc của HTML string phức tạp, sẽ rất khó để bạn theo dõi. Vì vậy, bài viết sau mình sẽ giới thiệu với các bạn phương pháp sử dụng thẻ template trong HTML.
Tham khảo"
263,HTML template sang DOM,Giới thiệu,"Như đã nói trongbài viết trước, bài này mình sẽ hướng dẫn các bạn chuyển HTML Template sang DOM Node. Với phương pháp này, bạn không cần phải sử dụngDOMParsernữa, mà sẽ sử dụng trực tiếp thẻ template của HTML."
264,HTML template sang DOM,HTML Template,"Khi sử dụng thẻtemplatenày, nội dung bên trong thẻ sẽ không được render sau khi load trang web. Thay vào đó, bạn sẽ sử dụng JavaScript để render nội dung này trong quá trình chạy.
Sau đây là một ví dụ sử dụng HTML template:
Ví dụ
Các bạn có thể thấy nội dung của thẻ template như sau:

```js
<template id=""my-temp"">
  <div>
    <span class=""name"">a name</span>
  </div>
  <div>
    <span class=""comment"">a comment</span>
  </div>
</template>
```
`<template id=""my-temp"">
  <div>
    <span class=""name"">a name</span>
  </div>
  <div>
    <span class=""comment"">a comment</span>
  </div>
</template>` Trong đó, thẻ template cóid=""my-temp"", để sử dụng trong JavaScript sau này. Bên trong thẻ, sẽ là một đoạn code HTML - có cấu trúc khá rõ ràng, với một phần text làname, và phần còn lại làcomment(phần này mô phỏng lại việc render mục bình luận trên một bài viết)."
265,HTML template sang DOM,Chuyển HTML Template sang DOM Node với JavaScript,"Trước khi sử dụng template, bạn cần kiểm tra xem trình duyệt của mình có hỗ trợ template hay không.

```js
// Check whether browser supports template
if (""content"" in document.createElement(""template"")) {
  console.log(""Support Template"");
} else {
  console.log(""Not Support Template"");
}
```
`// Check whether browser supports template
if (""content"" in document.createElement(""template"")) {
  console.log(""Support Template"");
} else {
  console.log(""Not Support Template"");
}` Template có một thuộc tính quan trọng làcontent. Khi bạn tạo mới một template sử dụngcreateElement, thì phần tử đó phải tồn tại thuộc tính content. Nghĩa là trình duyệt có hỗ trợ template, ngược lại thì không hỗ trợ.
Khi trình duyệt có hỗ trợ template rồi. Bạn có thể tiếp tục với bước sau.
HTML template đã có sẵn ID. Vì vậy, bạn có thể sử dụng phương thứcquerySelector(hoặcgetElementById) để lấy ra phần tửDOMcủa template đó, đồng thời trích xuất ra content - dạngDocumentFragment.

```js
let templateFrag = document.querySelector(""#my-temp"").content;
```
`let templateFrag = document.querySelector(""#my-temp"").content;` DocumentFragment là một dạng document tối giản - không có parent. Vì vậy, bạn có thể trực tiếp thêm nó vào giao diện HTML của mình.
Trong bước này, mình muốn mô phỏng lại việc render các bình luận trên một bài viết. Nội dung các bình luận là mộtmảngcủa cácobject- bao gồm 2 thuộc tính là name và comment.

```js
let data = [
  { name: ""John"", comment: ""That is great"" },
  { name: ""Alex"", comment: ""It's helpful"" },
  { name: ""David"", comment: ""Thanks a lot"" },
];
```
`let data = [
  { name: ""John"", comment: ""That is great"" },
  { name: ""Alex"", comment: ""It's helpful"" },
  { name: ""David"", comment: ""Thanks a lot"" },
];` Khi người dùng nhấn vào buttonAdd, mình sẽ sử dụng phương thứcforEachđể duyệt mảng trên. Với mỗi phần tử của mảng, taclonelại template DocumentFragment trên để dùng lại sau này.
Tiếp theo, để apply nội dung của bình luận vào template, bạn có thể tiếp tục sử dụng phương thức querySelector để thay đổi nội dung trong span với class là name, content tương ứng với nội dung trong mảng, rồi thêm nó vào bên trong thẻ div vớiid=""container"".

```js
btnAdd.addEventListener(""click"", () => {
  data.forEach((item) => {
    let tmpl = templateFrag.cloneNode(true);
    tmpl.querySelector("".name"").innerText = item.name;
    tmpl.querySelector("".comment"").innerText = item.comment;
    container.appendChild(tmpl);
  });
});
```
`btnAdd.addEventListener(""click"", () => {
  data.forEach((item) => {
    let tmpl = templateFrag.cloneNode(true);
    tmpl.querySelector("".name"").innerText = item.name;
    tmpl.querySelector("".comment"").innerText = item.comment;
    container.appendChild(tmpl);
  });
});` Cuối cùng, để xóa đi các thành phầnDOMmới thêm vào. Bạn có thể sử dụng vòng lặp, liên tục xóa đi phần tử con đầu tiên của container, cho đến khi container không còn node con nào nữa là hoàn thành nhiệm vụ.

```js
btnRm.addEventListener(""click"", () => {
  while (container.firstChild) {
    delete container.removeChild(container.firstChild);
  }
});
```
`btnRm.addEventListener(""click"", () => {
  while (container.firstChild) {
    delete container.removeChild(container.firstChild);
  }
});` Lưu ý
Chú ý:Nhắc lại đối với các bạn chưa đọc bài viết trước của mình, nếu bạn chỉ sử dụng phương thứcremoveChildmà không delete thì sẽ dẫn đến leak memory."
266,HTML template sang DOM,Kết luận,"Trên đây, mình đã giới thiệu với các bạn cách chuyển HTML Template sang DOM Node, đồng thời thay đổi nội dung của template ứng với data - lưu trong JavaScript. Hy vọng với phương pháp này, bạn có thể áp dụng template cho các project của mình. Bài viết sau, mình sẽ giới thiệu với các bạn một thư viện rất hay - chuyên dùng để render HTML template."
267,IDE là gì?,Giới thiệu,"IDE là phần mềm máy tính không thể thiếu khi lập trình. Sau đây, mình sẽ cùng tìm hiểu xem IDE là gì. IDE có tác dụng gì khi lập trình JavaScript. Và một số IDE JavaScript tốt nhất."
268,IDE là gì?,IDE là gì?,"IDE là viết tắt của ""Integrated Development Environment"" hay ""môi trường phát triển tích hợp"". Về bản chất, IDE là một loại phần mềm máy tính cung cấp các công cụ cần thiết cho lập trình viên trong việc phát triển phần mềm.
IDE là viết tắt của ""Integrated Development Environment"" hay ""môi trường phát triển tích hợp"". Về bản chất, IDE là một loại phần mềm máy tính cung cấp các công cụ cần thiết cho lập trình viên trong việc phát triển phần mềm.
IDE thường bao gồm những thành phần sau:
Nhờ có IDE mà công việc lập trình trở nên đơn giản hơn, năng suất của lập trình viên cũng sẽ cao hơn.
Vậy IDE lập trình JavaScript nào là tốt nhất?"
269,IDE là gì?,IDE lập trình JavaScript,"Thật khó để trả lời cho câu hỏi trên. Vì mỗi IDE đều có những ưu nhược điểm riêng. Hơn nữa, mục đích sử dụng của mỗi lập trình viên là khác nhau. Sở thích mỗi người cũng khác nhau.
Tuy nhiên, mình thấy có hai IDE JavaScript khá phổ biến là:
Cả hai IDE trên đều hỗ trợ đa nền tảng (cross-platform), có thể dùng trên hệ điều hành Windows, macOS hay Linux. Nhưng Visual Studio Code thì hoàn toàn miễn phí, còn WebStorm thì mất phí (cho phép dùng thử 30 ngày).
Bạn có thể trải nghiệm cả hai IDE trên xem cái nào tốt hơn và phù hợp hơn với mình để quyết định sử dụng lâu dài.
Ngoài IDE thì còn có khái niệm khác là ""code editor""."
270,IDE là gì?,Code editor là gì?,"Code editor cũng là một loại phần mềm máy tính hỗ trợ lập trình viên trong phát triển phần mềm. Nhưng so với IDE thì code editor đơn giản, nhẹ và nhanh hơn.
Nguyên nhân chính là do code editor thường chỉ làm việc với một tệp tin (file). Trong khi đó, IDE lại làm việc trên toàn bộ thư mục project - bao gồm nhiều file khác nhau.
Tuy nhiên, đó chỉ là lý thuyết. Trên thực tế, các code editor hiện đại có rất nhiều plugin hỗ trợ không khác gì IDE. Đặc biệt, JavaScript là ngôn ngữ thông dịch, nên cũng không đòi hỏi yêu cầu quá cao về IDE.
Sau đây là một số code editor nổi tiếng hỗ trợ lập trình JavaScript:"
271,IDE là gì?,Tổng kết,Vậy IDE là gì?
272,Tìm hiểu Javascript IndexedDB là gì,Giới thiệu,"Có thể bạn đã nghe thấy nhiều loại cơ sở dữ liệu (database) trên trình duyệt nhưPouchDB,LocalForage,Dexie,Lovefield,LokiJS,AlaSQL,ForerunnerDB,YDN-DB... Thực tế thì các database đó chỉ là những thư viện đóng gói (wrapping) lại 3 loại database trên trình duyệt. Đó là:LocalStorage,Web SQL,IndexedDB. Việc tìm hiểu các database gốc sẽ giúp bạn hiểu rõ được bản chất của các cơ sở dữ liệu đó. Qua đó, bạn có thể tự xây dựng những thư viện của riêng mình. Tuy nhiên, bài viết này sẽ chỉ tập chung vàoJavaScript IndexedDB. Tại sao vậy? Chúng ta sẽ cùng nhau tìm hiểu sau đây."
273,Tìm hiểu Javascript IndexedDB là gì,Cách sử dụng JavaScript IndexedDB,"Dưới đây là đoạn code để kiểm tra trình duyệt bạn đang dùng có hỗ trợ IndexedDB hay không.

```js
//prefixes of implementation that we want to test
window.indexedDB =
  window.indexedDB ||
  window.mozIndexedDB ||
  window.webkitIndexedDB ||
  window.msIndexedDB;

/**
 * prefixes of window.IDB objects
 * IDBTransaction interface of the IndexedDB API provides a static,
 * asynchronous transaction on a database using event handler attributes.
 */
window.IDBTransaction =
  window.IDBTransaction ||
  window.webkitIDBTransaction ||
  window.msIDBTransaction;

window.IDBKeyRange =
  window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;

if (!window.indexedDB) {
  window.alert(""Your browser doesn't support a stable version of IndexedDB."");
}
```
`//prefixes of implementation that we want to test
window.indexedDB =
  window.indexedDB ||
  window.mozIndexedDB ||
  window.webkitIndexedDB ||
  window.msIndexedDB;

/**
 * prefixes of window.IDB objects
 * IDBTransaction interface of the IndexedDB API provides a static,
 * asynchronous transaction on a database using event handler attributes.
 */
window.IDBTransaction =
  window.IDBTransaction ||
  window.webkitIDBTransaction ||
  window.msIDBTransaction;

window.IDBKeyRange =
  window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;

if (!window.indexedDB) {
  window.alert(""Your browser doesn't support a stable version of IndexedDB."");
}` IndexedDB cung cấp 2 APIs để open database như sau:

```js
var IDBOpenDBRequest = indexedDB.open(name);
var IDBOpenDBRequest = indexedDB.open(name, version);
```
`var IDBOpenDBRequest = indexedDB.open(name);
var IDBOpenDBRequest = indexedDB.open(name, version);` Sau đó, implement 3 hàmonsuccess,onerrorvàonupgradeneededcủa IDBOpenDBRequest để lắng nghe các sự kiện tương ứng làsuccess(mở database thành công),error(mở database bị lỗi),upgradeneeded(mở database thành công nhưng cần phải cập nhật lại với version mới nhất hiện tại).
Ví dụ:

```js
// Implement in SimpleSindexedDB.js
this.open = function (
  onsuccess,
  onerror,
  onupgradeneeded,
  objName,
  keyPath,
  objData
) {
  this.objName = objName;
  this.request = window.indexedDB.open(this.dbName, this.dbVersionNumber);
  var self = this;

  this.request.onerror = function (event) {
    onerror();
  };

  this.request.onsuccess = function (event) {
    // here: this = request
    self.db = this.result;
    onsuccess();
  };

  this.request.onupgradeneeded = function (event) {
    var db = event.target.result;
    var objectStore = db.createObjectStore(objName, { keyPath: keyPath });
    if (objData != undefined) {
      for (var i in objData) {
        objectStore.add(objData[i]);
      }
    }
    onupgradeneeded();
  };
};

// Implement in main.js
const INDEXED_DB_NAME = ""employee_db"";
var firstname, email, id;
var simpleIndexedDb;

var objData = [
  { id: ""1"", name: ""lam"", email: ""lam@whatever.com"" },
  { id: ""2"", name: ""phong"", email: ""phong@whatever.com"" },
];

var objName = ""employee"";
var keyPath = ""id"";

function init() {
  firstname = document.querySelector('[name=""firstname""]');
  email = document.querySelector('[name=""email""]');
  id = document.querySelector('[name=""id""]');

  simpleIndexedDb = new SimpleIndexedDB(INDEXED_DB_NAME);
  simpleIndexedDb.open(
    openDBSuccess,
    openDBError,
    openDBUpgradeNeeded,
    objName,
    keyPath,
    objData
  );
}

function openDBSuccess() {
  console.log(""open db success"");
}

function openDBError() {
  console.log(""open db error"");
}

function openDBUpgradeNeeded() {
  console.log(""open db upgradedneeded"");
}
```
`// Implement in SimpleSindexedDB.js
this.open = function (
  onsuccess,
  onerror,
  onupgradeneeded,
  objName,
  keyPath,
  objData
) {
  this.objName = objName;
  this.request = window.indexedDB.open(this.dbName, this.dbVersionNumber);
  var self = this;

  this.request.onerror = function (event) {
    onerror();
  };

  this.request.onsuccess = function (event) {
    // here: this = request
    self.db = this.result;
    onsuccess();
  };

  this.request.onupgradeneeded = function (event) {
    var db = event.target.result;
    var objectStore = db.createObjectStore(objName, { keyPath: keyPath });
    if (objData != undefined) {
      for (var i in objData) {
        objectStore.add(objData[i]);
      }
    }
    onupgradeneeded();
  };
};

// Implement in main.js
const INDEXED_DB_NAME = ""employee_db"";
var firstname, email, id;
var simpleIndexedDb;

var objData = [
  { id: ""1"", name: ""lam"", email: ""lam@whatever.com"" },
  { id: ""2"", name: ""phong"", email: ""phong@whatever.com"" },
];

var objName = ""employee"";
var keyPath = ""id"";

function init() {
  firstname = document.querySelector('[name=""firstname""]');
  email = document.querySelector('[name=""email""]');
  id = document.querySelector('[name=""id""]');

  simpleIndexedDb = new SimpleIndexedDB(INDEXED_DB_NAME);
  simpleIndexedDb.open(
    openDBSuccess,
    openDBError,
    openDBUpgradeNeeded,
    objName,
    keyPath,
    objData
  );
}

function openDBSuccess() {
  console.log(""open db success"");
}

function openDBError() {
  console.log(""open db error"");
}

function openDBUpgradeNeeded() {
  console.log(""open db upgradedneeded"");
}` Để quét toàn bộ dữ liệu trong một object store, sử dụngcursor.
Ví dụ:

```js
// Implement in SimpleSindexedDB.js
this.readAll = function (callback) {
  var objectStore = this.db.transaction(this.objName).objectStore(this.objName);

  objectStore.openCursor().onsuccess = function (event) {
    var cursor = event.target.result;
    if (cursor) {
      callback(cursor);
      cursor.continue();
    } else {
      console.log(""No more entries!"");
    }
  };
};

// Implement in main.js
function showAll() {
  simpleIndexedDb.readAll(function (cursor) {
    console.log(cursor.key, cursor.value.name, cursor.value.email);
  });
}
```
`// Implement in SimpleSindexedDB.js
this.readAll = function (callback) {
  var objectStore = this.db.transaction(this.objName).objectStore(this.objName);

  objectStore.openCursor().onsuccess = function (event) {
    var cursor = event.target.result;
    if (cursor) {
      callback(cursor);
      cursor.continue();
    } else {
      console.log(""No more entries!"");
    }
  };
};

// Implement in main.js
function showAll() {
  simpleIndexedDb.readAll(function (cursor) {
    console.log(cursor.key, cursor.value.name, cursor.value.email);
  });
}` Để lấy ra một bản ghi trong object store của database, sử dụng phương thứcget.
Ví dụ:

```js
// Implement in SimpleSindexedDB.js
this.read = function (id) {
  var transaction = this.db.transaction([this.objName]);
  var objectStore = transaction.objectStore(this.objName);
  var keySearch = """" + id;

  return new Promise(function (resolve, reject) {
    var request = objectStore.get(id);
    request.onerror = function (event) {
      reject(event);
    };
    request.onsuccess = function (event) {
      resolve(request.result);
    };
  });
};

// Implement in main.js
function read() {
  simpleIndexedDb.read(getId()).then(
    (result) => console.log(""read success"", result),
    (event) => console.log(""read error"", event)
  );
}
```
`// Implement in SimpleSindexedDB.js
this.read = function (id) {
  var transaction = this.db.transaction([this.objName]);
  var objectStore = transaction.objectStore(this.objName);
  var keySearch = """" + id;

  return new Promise(function (resolve, reject) {
    var request = objectStore.get(id);
    request.onerror = function (event) {
      reject(event);
    };
    request.onsuccess = function (event) {
      resolve(request.result);
    };
  });
};

// Implement in main.js
function read() {
  simpleIndexedDb.read(getId()).then(
    (result) => console.log(""read success"", result),
    (event) => console.log(""read error"", event)
  );
}` Để thêm vào một bản ghi cho object store của database, sử dụng phương thứcadd.
Ví dụ:

```js
// Implement in SimpleSindexedDB.js
this.add = function (objData) {
  var transaction = this.db.transaction([this.objName], ""readwrite"");
  var objectStore = transaction.objectStore(this.objName);

  return new Promise(function (resolve, reject) {
    var request = objectStore.add(objData);
    request.onsuccess = function (event) {
      resolve(event);
    };

    request.onerror = function (event) {
      reject(event);
    };
  });
};

// Implement in main.js
function save() {
  var data = {
    id: getId(),
    name: getName(),
    email: getEmail(),
  };
  console.log(""save"", data);

  simpleIndexedDb.add(data).then(
    (event) => console.log(""add success"", event),
    (error) => console.log(""add error"", error)
  );
}
```
`// Implement in SimpleSindexedDB.js
this.add = function (objData) {
  var transaction = this.db.transaction([this.objName], ""readwrite"");
  var objectStore = transaction.objectStore(this.objName);

  return new Promise(function (resolve, reject) {
    var request = objectStore.add(objData);
    request.onsuccess = function (event) {
      resolve(event);
    };

    request.onerror = function (event) {
      reject(event);
    };
  });
};

// Implement in main.js
function save() {
  var data = {
    id: getId(),
    name: getName(),
    email: getEmail(),
  };
  console.log(""save"", data);

  simpleIndexedDb.add(data).then(
    (event) => console.log(""add success"", event),
    (error) => console.log(""add error"", error)
  );
}` Để xoá đi một bản ghi tỏng object store database, sử dụng phương thứcdelete.
Ví dụ:

```js
// Implement in SimpleSindexedDB.js
this.remove = function (id) {
  var transaction = this.db.transaction([this.objName], ""readwrite"");
  var objectStore = transaction.objectStore(this.objName);
  var keySearch = """" + id;

  return new Promise(function (resolve, reject) {
    var request = objectStore.delete(id);
    request.onerror = function (event) {
      reject(event);
    };
    request.onsuccess = function (event) {
      resolve(event);
    };
  });
};

// Implement in main.js
function remove() {
  simpleIndexedDb.remove(getId()).then(
    (event) => console.log(""remove success"", event),
    (event) => console.log(""remove error"", event)
  );
}
```
`// Implement in SimpleSindexedDB.js
this.remove = function (id) {
  var transaction = this.db.transaction([this.objName], ""readwrite"");
  var objectStore = transaction.objectStore(this.objName);
  var keySearch = """" + id;

  return new Promise(function (resolve, reject) {
    var request = objectStore.delete(id);
    request.onerror = function (event) {
      reject(event);
    };
    request.onsuccess = function (event) {
      resolve(event);
    };
  });
};

// Implement in main.js
function remove() {
  simpleIndexedDb.remove(getId()).then(
    (event) => console.log(""remove success"", event),
    (event) => console.log(""remove error"", event)
  );
}`"
274,Tìm hiểu Javascript IndexedDB là gì,Kết luận,"Trên đây, mình đã giới thiệu với bạn những kiến thức cơ bản cần nhớ về JavaScript IndexedDB. Tuy nhiên, để giải thích chi tiết về index db thì thật sự không biết phải giải thích như thế nào.
Vì vậy, nếu có phần nào bạn cảm thấy không hiểu thì có thể đặt câu hỏi trong phần bình luận."
275,Tìm hiểu về iterable trong Javascript,Giới thiệu,"Iterable trong JavaScriptlà một khái niệm liên quan đến array. Một object gọi làiterablenếu object đó sử dụng được vớivòng lặpfor...of.
`for...of` Dĩ nhiên, array là iterable. Ngoài ra, JavaScript còn có nhiều kiểu object khác cũngiterable, ví dụ:Set,Map, String,...

```js
// array là iterable
let arr = [1, 2, 3];
for (let it of arr) {
  console.log(it); // Kết quả lần lượt là: 1, 2, 3
}

// string là iterable
let str = ""hello"";
for (let ch of str) {
  console.log(ch); // Kết quả lần lượt là: h, e, l, l, o
}
```
`// array là iterable
let arr = [1, 2, 3];
for (let it of arr) {
  console.log(it); // Kết quả lần lượt là: 1, 2, 3
}

// string là iterable
let str = ""hello"";
for (let ch of str) {
  console.log(ch); // Kết quả lần lượt là: h, e, l, l, o
}` Sau đây, mình hãy cùng tìm hiểu xemiterable trong JavaScripthoạt động thế nào nhé!"
276,Tìm hiểu về iterable trong Javascript,Symbol.iterator,"Để hiểu rõ về iterable trong JavaScript, mình sẽ thửtự triển khai iterable.
Ví dụ objectrangesau đây (mặc định không dùng được vớifor...of):
`range` `for...of` 
```js
let range = {
  from: 1,
  to: 5,
};

for (let num of range) {
  console.log(num);
}

// Uncaught TypeError: range is not iterable
```
`let range = {
  from: 1,
  to: 5,
};

for (let num of range) {
  console.log(num);
}

// Uncaught TypeError: range is not iterable` Để objectrangetrên trở nêniterable, mình cần triển khai mộtphương thứcvới key làSymbol.iterator. Đây là mộtSymbolđặc biệt và sẵn có trong JavaScript.
`range` `Symbol.iterator` Khi đó, quá trình xử lý củafor...ofnhư sau:
`for...of` `for...of` `Symbol.iterator` `iterator` `next` `for...of` `iterator` `for...of` `next` `next` `{done: Boolean, value: any}` `done=true` `value` Sau đây là cách triển khai phương thứcSymbol.iteratorcho đối tượngrangetrên:
`Symbol.iterator` `range` 
```js
let range = {
  from: 1,
  to: 5,

  // phương thức `Symbol.iterator`
  [Symbol.iterator]() {
    // phương thức này trả về một iterator object - object có phương thức next
    return {
      current: this.from,
      last: this.to,

      // khi for...of cần giá trị tiếp theo thì nó sẽ gọi phương thức next
      next() {
        // phương thức next trả về object dạng: {done:..., value:...}
        if (this.current <= this.last) {
          // done=false là chưa kết thúc
          return { done: false, value: this.current++ };
        } else {
          // done=true là kết thúc
          return { done: true };
        }
      },
    };
  },
};

// Bây giờ thì range có thể hoạt động được với for...of
for (let num of range) {
  console.log(num); // 1, 2, 3, 4, 5
}
```
`let range = {
  from: 1,
  to: 5,

  // phương thức `Symbol.iterator`
  [Symbol.iterator]() {
    // phương thức này trả về một iterator object - object có phương thức next
    return {
      current: this.from,
      last: this.to,

      // khi for...of cần giá trị tiếp theo thì nó sẽ gọi phương thức next
      next() {
        // phương thức next trả về object dạng: {done:..., value:...}
        if (this.current <= this.last) {
          // done=false là chưa kết thúc
          return { done: false, value: this.current++ };
        } else {
          // done=true là kết thúc
          return { done: true };
        }
      },
    };
  },
};

// Bây giờ thì range có thể hoạt động được với for...of
for (let num of range) {
  console.log(num); // 1, 2, 3, 4, 5
}` Đó chính là cách triển khai một object iterable trong JavaScript."
277,Tìm hiểu về iterable trong Javascript,Gọi iterator trực tiếp,"Để hiểu rõ hơn về iterable trong JavaScript, mình sẽ thửgọi iterator trực tiếpmà không sử dụngfor...of.
`for...of` Ví dụ sau đây duyệt hết các kí tự ở string:

```js
let str = ""Hello"";

// gọi phương thức [Symbol.iterator]()
// phương thức này trả về đối tượng iterator chứa phương thức next()
let iterator = str[Symbol.iterator]();

// sử dụng vòng lặp while(true) để duyệt
while (true) {
  // gọi phương thức next() để lấy giá trị kế tiếp
  // phương thức next() trả về đối tượng có dạng {done:..., value:...}
  let result = iterator.next();

  // kiểm tra nếu done=true thì break để kết thúc
  if (result.done) break;

  // ngược lại thì in ra giá trị value
  console.log(result.value);
}
```
`let str = ""Hello"";

// gọi phương thức [Symbol.iterator]()
// phương thức này trả về đối tượng iterator chứa phương thức next()
let iterator = str[Symbol.iterator]();

// sử dụng vòng lặp while(true) để duyệt
while (true) {
  // gọi phương thức next() để lấy giá trị kế tiếp
  // phương thức next() trả về đối tượng có dạng {done:..., value:...}
  let result = iterator.next();

  // kiểm tra nếu done=true thì break để kết thúc
  if (result.done) break;

  // ngược lại thì in ra giá trị value
  console.log(result.value);
}` Kết quả
Hello
Trên đây là cách hoạt động của iterable trong JavaScript.
Mặc dù, việc gọi trực tiếp như này hầu như không bao giờ áp dụng trong thực tế. Nhưng qua đó, bạn hiểu đượccách hoạt động của iterable objectkhi duyệt vớifor...of.
`for...of`"
278,Tìm hiểu về iterable trong Javascript,So sánh iterable trong JavaScript và array-like,"Đây là hai khái niệmkhá giống nhaunhưng thật sự rất khác biệt.
`Symbol.iterator` `length` Trong JavaScript có nhiều object - có thể là iterable hoặc array-like hoặc cả hai.
Ví dụ, string vừa làiterable(hoạt động được vớifor...of) và vừa làarray-like(có chỉ số và thuộc tínhlength).
`for...of` `length` Nhìn chung,iterable và array-like không phải arraynên chúng không có cácphương thức của mảngnhưpush,pop,forEach,...
`push` `pop` `forEach` Để giải quyết vấn đề này, bạn cần phảichuyển đổi kiểu dữ liệutừ iterable hoặc array-like sang array."
279,Tìm hiểu về iterable trong Javascript,Phương thứcArray.from,"`Array.from` Phương thứcArray.fromnhận đầu vào là iterable object hoặc array-like và trả về một array.
`Array.from` Ví dụ tạo array từ array-like:

```js
let arrayLike = {
  0: ""a"",
  1: ""b"",
  length: 2,
};

let arr = Array.from(arrayLike);
console.log(arr.pop()); // b
```
`let arrayLike = {
  0: ""a"",
  1: ""b"",
  length: 2,
};

let arr = Array.from(arrayLike);
console.log(arr.pop()); // b` Ví dụ tạo array từ iterablerangebên trên:
`range` 
```js
let range = {
  from: 1,
  to: 5,

  // phương thức `Symbol.iterator`
  [Symbol.iterator]() {
    // phương thức này trả về một iterator object - object có phương thức next
    return {
      current: this.from,
      last: this.to,

      // khi for...of cần giá trị tiếp theo thì nó sẽ gọi phương thức next
      next() {
        // phương thức next trả về object dạng: {done:..., value :...}
        if (this.current <= this.last) {
          // done=false là chưa kết thúc
          return { done: false, value: this.current++ };
        } else {
          // done=true là kết thúc
          return { done: true };
        }
      },
    };
  },
};

let arr = Array.from(range);
console.log(arr); // (5) [1, 2, 3, 4, 5]
```
`let range = {
  from: 1,
  to: 5,

  // phương thức `Symbol.iterator`
  [Symbol.iterator]() {
    // phương thức này trả về một iterator object - object có phương thức next
    return {
      current: this.from,
      last: this.to,

      // khi for...of cần giá trị tiếp theo thì nó sẽ gọi phương thức next
      next() {
        // phương thức next trả về object dạng: {done:..., value :...}
        if (this.current <= this.last) {
          // done=false là chưa kết thúc
          return { done: false, value: this.current++ };
        } else {
          // done=true là kết thúc
          return { done: true };
        }
      },
    };
  },
};

let arr = Array.from(range);
console.log(arr); // (5) [1, 2, 3, 4, 5]` Cú pháp đầy đủ củaArray.fromcho phép bạn truyền vào một hàm ""mapping"":
`Array.from` 
```js
Array.from(obj[, mapFn, thisArg]);
```
`Array.from(obj[, mapFn, thisArg]);` Tham số thứ haimapFnlà một hàm được sử dụng đểgọi với mỗi phần tửtrước khi đưa vào mảng. VàthisArgtương ứng vớithistrong hàmmapFn. ví dụ:
`mapFn` `thisArg` `this` `mapFn` 
```js
// đối tượng range được định nghĩa như ví dụ trên

// hàm mapping trả về bình phương của số num
let arr = Array.from(range, (num) => num * num);

// kết quả
console.log(arr); // (5) [1, 4, 9, 16, 25]
```
`// đối tượng range được định nghĩa như ví dụ trên

// hàm mapping trả về bình phương của số num
let arr = Array.from(range, (num) => num * num);

// kết quả
console.log(arr); // (5) [1, 4, 9, 16, 25]`"
280,Tìm hiểu về iterable trong Javascript,Tổng kết,"Iterable trong JavaScriptlà object có thể sử dụng được với vòng lặpfor...of.
`for...of` `Symbol.iterator` `obj[Symbol.iterator]()` duyệt iterable object.
`next` `next()` `{done: Boolean, value: Any}` `done=true` `value` `Symbol.iterator` `for...of` `for...of` `array` `Array.from` Tham khảo:"
281,JSON trong Javascript,Giới thiệu,"Giả sử, bạn có một object phức tạp. Và bạn muốnchuyển object thành dạng stringđể gửi lên server hoặc ghi log ra file.
Cách đơn giản là bạn viết phương thứctoString()chứa tất cả các thuộc tính của object, ví dụ:
`toString()` 
```js
let user = {
  name: ""Alex"",
  age: 28,
  toString() {
    return `{name: ${this.name}, age: ${this.age}}`;
  },
};

console.log(user.toString()); // {name: Alex, age: 28}
```
`let user = {
  name: ""Alex"",
  age: 28,
  toString() {
    return `{name: ${this.name}, age: ${this.age}}`;
  },
};

console.log(user.toString()); // {name: Alex, age: 28}` Tuy nhiên, cách này gặpkhó khăn khi phát triển. Vì các thuộc tính của objectcó thể thay đổi, thêm hoặc bớt bất kỳ lúc nào.
Khi đó, bạn phải thường xuyên cập nhật lại phương thứctoString(). Việc này chắc chắn sẽ mất thời gian.
`toString()` May mắn thay, bạn có một công cụ vô cùng mạnh mẽ là:JSON trong JavaScript."
282,JSON trong Javascript,JSON trong JavaScript,"JSONlà viết tắt củaJavaScript Object Notation. Đây là một định dạng chung để biểu diễn các giá trị và object.
Ban đầu, JSON được tạo ra để dùng trong JavaScript. Sau đó,nhiều thư viện ở các ngôn ngữ khác nhauđược sinh ra để xử lý JSON.
Qua đó, JSON được sử dụng nhiều để trao đổi dữ liệu giữa client (JavaScript) và server (Ruby, PHP, Java,...).
JSON trong JS có hai phương thức là:
`JSON.stringify()` `JSON.parse()`"
283,JSON trong Javascript,Phương thứcJSON.stringify,"`JSON.stringify` Ví dụ sử dụngJSON.stringify()để chuyển đối tượnguserthành string như sau:
`JSON.stringify()` `user` 
```js
let user = {
  name: ""Alex"",
  age: 28,
};

let json = JSON.stringify(user);
console.log(json); // {""name"":""Alex"",""age"":28}
console.log(typeof json); // string
```
`let user = {
  name: ""Alex"",
  age: 28,
};

let json = JSON.stringify(user);
console.log(json); // {""name"":""Alex"",""age"":28}
console.log(typeof json); // string` Trong ví dụ trên, phương thứcJSON.stringify(user)nhận vào một object và trả về string biểu diễn object đã truyền vào.
`JSON.stringify(user)` Chú ý:JSON trong JavaScript khác với kí hiệu object (object literal).
`""""` `''` ```` `""""` `name` `age` `""name""` `""age""` JSON.stringifycũng có thể áp dụng cho kiểu dữ liệu nguyên thủy. Và sau đây là những kiểu dữ liệu mà JSON trong JavaScript hỗ trợ:
`JSON.stringify` `{...}` `[...]` `null` Ví dụ JSON với các kiểu dữ liệu:

```js
// số chuyển sang JSON vẫn là số
console.log(JSON.stringify(1)); // 1

// string chuyển sang JSON vẫn là string, nhưng sử dụng dấu """"
console.log(JSON.stringify(""test"")); // ""test""

// boolean chuyển sang JSON vẫn là boolean
console.log(JSON.stringify(true)); // true

// mảng chuyển sang JSON
console.log(JSON.stringify([1, 2, 3])); // [1,2,3]
```
`// số chuyển sang JSON vẫn là số
console.log(JSON.stringify(1)); // 1

// string chuyển sang JSON vẫn là string, nhưng sử dụng dấu """"
console.log(JSON.stringify(""test"")); // ""test""

// boolean chuyển sang JSON vẫn là boolean
console.log(JSON.stringify(true)); // true

// mảng chuyển sang JSON
console.log(JSON.stringify([1, 2, 3])); // [1,2,3]` JSON chỉđơn giản là dữ liệuvà độc lập với ngôn ngữ lập trình. Do đó, một vài thuộc tính của object bị bỏ qua khi dùngJSON.stringifynhư:
`JSON.stringify` `undefined` 
```js
let user = {
  // phương thức bị bỏ qua
  sayHi() {
    console.log(""Hello"");
  },
  [Symbol(""id"")]: 12356, // symbole bị bỏ qua
  something: undefined, // thuộc tính với giá trị undefined cũng bị bỏ qua
};

console.log(JSON.stringify(user)); // {} (string không có thuộc tính nào)
```
`let user = {
  // phương thức bị bỏ qua
  sayHi() {
    console.log(""Hello"");
  },
  [Symbol(""id"")]: 12356, // symbole bị bỏ qua
  something: undefined, // thuộc tính với giá trị undefined cũng bị bỏ qua
};

console.log(JSON.stringify(user)); // {} (string không có thuộc tính nào)` Điều này là hoàn toàn bình thường. Nhưng nếu đó không phải thứ bạn muốn, bạn vẫn có thểtùy biến được quá trìnhchuyển từ object sang string.
Phương thứcJSON.stringifyáp dụng được với object, array có nhiều tầng lồng nhau, ví dụ:
`JSON.stringify` 
```js
let meetup = {
  title: ""Conference"",
  room: { number: 23, participants: [""alex"", ""ann""] },
};

console.log(JSON.stringify(meetup));
```
`let meetup = {
  title: ""Conference"",
  room: { number: 23, participants: [""alex"", ""ann""] },
};

console.log(JSON.stringify(meetup));` Kết quả
{   ""title"":""Conference"",   ""room"":{""number"":23,""participants"":[""alex"",""ann""]}, }
`{   ""title"":""Conference"",   ""room"":{""number"":23,""participants"":[""alex"",""ann""]}, }` Tuy nhiên,JSON.stringifykhông hỗ trợ nếu object cótham chiếu vòng tròn, ví dụ:
`JSON.stringify` 
```js
let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  participants: [""alex"", ""ann""],
};

meetup.place = room; // meetup tham chiếu đến room
room.occupiedBy = meetup; // room tham chiếu lại đến meetup.

JSON.stringify(meetup); // Lỗi: Converting circular structure to JSON
```
`let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  participants: [""alex"", ""ann""],
};

meetup.place = room; // meetup tham chiếu đến room
room.occupiedBy = meetup; // room tham chiếu lại đến meetup.

JSON.stringify(meetup); // Lỗi: Converting circular structure to JSON`"
284,JSON trong Javascript,Tùy biến phương thứcJSON.stringify,"`JSON.stringify` Cú pháp đầy đủ củaJSON.stringifytrong JavaScript là:
`JSON.stringify` 
```js
let json = JSON.stringify(value[, replacer, space])
```
`let json = JSON.stringify(value[, replacer, space])` Trong đó:
`value` `replacer` `function(key, value)` `space` Thông thường, phương thứcJSON.stringifychỉ cần truyền vào tham số đầu tiên.
`JSON.stringify` Tuy nhiên, nếu bạn muốn tùy chỉnh quá trình chuyển từ object sang JSON, bạn có thể sử dụng tham số thứ 2 và thứ 3.
Ví dụ truyền vào một mảng các thuộc tính dành choJSON.stringify:
`JSON.stringify` 
```js
let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  participants: [{ name: ""Alex"" }, { name: ""Anna"" }],
  place: room, // meetup tham chiếu đến room
};

room.occupiedBy = meetup; // room tham chiếu đến meetup

console.log(JSON.stringify(meetup, [""title"", ""participants""])); // {""title"":""Conference"",""participants"":[{},{}]}
```
`let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  participants: [{ name: ""Alex"" }, { name: ""Anna"" }],
  place: room, // meetup tham chiếu đến room
};

room.occupiedBy = meetup; // room tham chiếu đến meetup

console.log(JSON.stringify(meetup, [""title"", ""participants""])); // {""title"":""Conference"",""participants"":[{},{}]}` Bây giờ,JSON.stringifyđã không bị lỗitham chiếu vòngnhư trên.
`JSON.stringify` Tuy nhiên, thuộc tínhplacebị biến mất và các phần tử bên trong mảngparticipantslại là object rỗng{}. Đó là bởi vì thuộc tínhnamevàplacekhông nằm trong danh sách cho phép.
`place` `participants` `{}` `name` `place` Bạn có thể tùy chỉnh danh sách thuộc tính cho phép để chấp nhận tất cả các thuộc tính, ngoại trừ thuộc tính có tham chiếu vòngoccupiedBynhư sau:
`occupiedBy` 
```js
let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  participants: [{ name: ""Alex"" }, { name: ""Anna"" }],
  place: room, // meetup tham chiếu đến room
};

room.occupiedBy = meetup; // room tham chiếu đến meetup

let json = JSON.stringify(meetup, [
  ""title"",
  ""participants"",
  ""place"",
  ""number"",
  ""name"",
]);
console.log(json);
// {""title"":""Conference"",""participants"":[{""name"":""Alex""},{""name"":""Anna""}],""place"":{""number"":23}}
```
`let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  participants: [{ name: ""Alex"" }, { name: ""Anna"" }],
  place: room, // meetup tham chiếu đến room
};

room.occupiedBy = meetup; // room tham chiếu đến meetup

let json = JSON.stringify(meetup, [
  ""title"",
  ""participants"",
  ""place"",
  ""number"",
  ""name"",
]);
console.log(json);
// {""title"":""Conference"",""participants"":[{""name"":""Alex""},{""name"":""Anna""}],""place"":{""number"":23}}` Tất cả các thuộc tính (trừoccupiedBy) đã được đưa vào JSON. Tuy nhiên, cách sử dụng vẫn khá dài dòng. Để giải quyết vấn đề này, bạn có thể dùng hàmreplacerthay thế cho mảng.
`occupiedBy` `replacer` Hàmreplacerđược gọi với mỗi cặp(key, value)trong object và trả về giá trị được thay thế hoặc trả vềundefinednếu bạn muốn bỏ qua thuộc tính.
`replacer` `undefined` 
```js
let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  participants: [{ name: ""Alex"" }, { name: ""Anna"" }],
  place: room, // meetup tham chiếu đến room
};

room.occupiedBy = meetup; // room tham chiếu đến meetup

let json = JSON.stringify(meetup, function (key, value) {
  console.log(`${key}: ${value}`);
  return key == ""occupiedBy"" ? undefined : value;
});

console.log(json);
/*
    : [object Object]
    title: Conference
    participants: [object Object],[object Object]
    0: [object Object]
    name: Alex
    1: [object Object]
    name: Anna
    place: [object Object]
    number: 23
    occupiedBy: [object Object]

    {""title"":""Conference"",""participants"":[{""name"":""Alex""},{""name"":""Anna""}],""place"":{""number"":23}}
    */
```
`let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  participants: [{ name: ""Alex"" }, { name: ""Anna"" }],
  place: room, // meetup tham chiếu đến room
};

room.occupiedBy = meetup; // room tham chiếu đến meetup

let json = JSON.stringify(meetup, function (key, value) {
  console.log(`${key}: ${value}`);
  return key == ""occupiedBy"" ? undefined : value;
});

console.log(json);
/*
    : [object Object]
    title: Conference
    participants: [object Object],[object Object]
    0: [object Object]
    name: Alex
    1: [object Object]
    name: Anna
    place: [object Object]
    number: 23
    occupiedBy: [object Object]

    {""title"":""Conference"",""participants"":[{""name"":""Alex""},{""name"":""Anna""}],""place"":{""number"":23}}
    */` Chú ý:hàmreplacerđược gọi với mỗi cặp(key, value)bao gồm cả object và mảng lồng nhaumột cách đệ quy. Giá trịthistrong hàmreplacerlà object chứa thuộc tính đang xét.
`replacer` `(key, value)` `this` `replacer` Lần gọi hàm đầu tiên, hàmreplacertạo ra một ""wrapper object"":{"""": meetup}. Nói cách khác, cặp(key, value)đầu tiên không cókey, cònvaluelà toàn bộ objectmeetup.
`replacer` `{"""": meetup}` `(key, value)` `key` `value` `meetup` Đó là lý do tại sao dòng đầu tiên in ra:: [object Object].
`: [object Object]`"
285,JSON trong Javascript,Sử dụng tham sốspacetrongJSON.stringify,"`space` `JSON.stringify` Tham số thứ ba trongJSON.stringify(value, replacer, space)là số lượng kí tự dấu cách ""space"" dùng để định dạng json.
`JSON.stringify(value, replacer, space)` Trong các ví dụ trên, mình không sử dụngspacenên kết quả json luôn là ""string nằm trên một dòng"".
`space` ""JSON nằm trên một dòng"" là tốt cho việc gửi dữ liệu lên server. Tuy nhiên, nếu bạn muốn ghi log ra để theo dõi thì cách này lại rất khó nhìn.
Ví dụ sử dụngJSON.stringifyvớispace = 2để in log tốt hơn:
`JSON.stringify` `space = 2` 
```js
let user = {
  name: ""Alex"",
  age: 28,
  roles: {
    isAdmin: false,
    isEditor: true,
  },
};

// replacer = null - nếu không muốn tùy chỉnh tham số này.
// space = 2 - các thuộc tính sẽ xuống dòng và thụt 2 dấu cách so với cha.
let json = JSON.stringify(user, null, 2);
console.log(json);
/*
    {
      ""name"": ""Alex"",
      ""age"": 28,
      ""roles"": {
        ""isAdmin"": false,
        ""isEditor"": true
      }
    }
    */
```
`let user = {
  name: ""Alex"",
  age: 28,
  roles: {
    isAdmin: false,
    isEditor: true,
  },
};

// replacer = null - nếu không muốn tùy chỉnh tham số này.
// space = 2 - các thuộc tính sẽ xuống dòng và thụt 2 dấu cách so với cha.
let json = JSON.stringify(user, null, 2);
console.log(json);
/*
    {
      ""name"": ""Alex"",
      ""age"": 28,
      ""roles"": {
        ""isAdmin"": false,
        ""isEditor"": true
      }
    }
    */` Bạn có thể tùy chỉnh giá trị củaspacelớn hơn2nếu muốn khoảng cách rộng hơn.
`space` `2` Ngoài ra, giá trị củaspacecó thể là một string. Khi đó, string được sử dụng thay thế cho dấu cách - giống trường hợpspace=2như sau:
`space` `space=2` 
```js
let user = {
  name: ""Alex"",
  age: 28,
  roles: {
    isAdmin: false,
    isEditor: true,
  },
};

// space = ""a"" - các thuộc tính sẽ xuống dòng và thụt 2 string ""a"" so với cha.
let json = JSON.stringify(user, null, ""aa"");
console.log(json);
/*
    {
    aa""name"": ""Alex"",
    aa""age"": 28,
    aa""roles"": {
    aaaa""isAdmin"": false,
    aaaa""isEditor"": true
    aa}
    }
     */
```
`let user = {
  name: ""Alex"",
  age: 28,
  roles: {
    isAdmin: false,
    isEditor: true,
  },
};

// space = ""a"" - các thuộc tính sẽ xuống dòng và thụt 2 string ""a"" so với cha.
let json = JSON.stringify(user, null, ""aa"");
console.log(json);
/*
    {
    aa""name"": ""Alex"",
    aa""age"": 28,
    aa""roles"": {
    aaaa""isAdmin"": false,
    aaaa""isEditor"": true
    aa}
    }
     */`"
286,JSON trong Javascript,Tùy biếntoJSON,"`toJSON` Tương tự như phương thứctoStringkhi chuyển đổi kiểu dữ liệu sang string, object có thể cung cấp phương thứctoJSONđể chuyển đổi sang JSON vớiJSON.stringify, ví dụ:
`toString` `toJSON` `JSON.stringify` 
```js
let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  date: new Date(Date.UTC(2021, 11, 19)),
  room,
};

console.log(JSON.stringify(meetup, null, 2));
/*
    {
      ""title"": ""Conference"",
      ""date"": ""2021-12-19T00:00:00.000Z"",
      ""room"": {
        ""number"": 23
      }
    }
    */
```
`let room = {
  number: 23,
};

let meetup = {
  title: ""Conference"",
  date: new Date(Date.UTC(2021, 11, 19)),
  room,
};

console.log(JSON.stringify(meetup, null, 2));
/*
    {
      ""title"": ""Conference"",
      ""date"": ""2021-12-19T00:00:00.000Z"",
      ""room"": {
        ""number"": 23
      }
    }
    */` Bạn thấy rằngđối tượngDateđã chuyển sang string. Vì bản thân đối tượngDateđã có phương thứctoJSONtrả về string như trên.
`Date` `Date` `toJSON` Mình cũng có thể thêm phương thứctoJSONvào đối tượngroom:
`toJSON` `room` 
```js
let room = {
  number: 23,
  toJSON() {
    return this.number;
  },
};

console.log(JSON.stringify(room)); // 23
```
`let room = {
  number: 23,
  toJSON() {
    return this.number;
  },
};

console.log(JSON.stringify(room)); // 23`"
287,JSON trong Javascript,Phương thứcJSON.parse,"`JSON.parse` Phương thứcJSON.parse(json)dùng để chuyển JSON-string trở thành giá trị (object, array hoặc các kiểu dữ liệu nguyên thủy tương ứng) với cú pháp:
`JSON.parse(json)` 
```js
let value = JSON.parse(str, [reviver]);
```
`let value = JSON.parse(str, [reviver]);` Trong đó:
`str` `reviver` `function(key, value)` `(key, value)` Ví dụ:

```js
// JSON-string dạng mảng
let numbers = ""[0, 1, 2, 3]"";

// parse JSON-string về mảng
numbers = JSON.parse(numbers);

// sau khi numbers được parse thành array,
// bạn có thể truy cập phần tử mảng qua chỉ số
console.log(numbers[1]); // 1
```
`// JSON-string dạng mảng
let numbers = ""[0, 1, 2, 3]"";

// parse JSON-string về mảng
numbers = JSON.parse(numbers);

// sau khi numbers được parse thành array,
// bạn có thể truy cập phần tử mảng qua chỉ số
console.log(numbers[1]); // 1` Hoặc object lồng nhau:

```js
let data =
  '{ ""name"": ""John"", ""age"": 35, ""isAdmin"": false, ""friends"": [0,1,2,3] }';

let user = JSON.parse(data);

console.log(user.friends[1]); // 1
```
`let data =
  '{ ""name"": ""John"", ""age"": 35, ""isAdmin"": false, ""friends"": [0,1,2,3] }';

let user = JSON.parse(data);

console.log(user.friends[1]); // 1` JSON có thể có cấu trúc phức tạp, bao gồm nhiều kiểu dữ liệu, mảng, object lồng nhau. Nhưng chúng bắt buộc phải tuân theo định dạng chuẩn của JSON.
Một số lỗi JSON không hợp lệ như sau:

```js
let json = `{
      name: ""John"",           // không hợp lệ: thuộc tính không có nháy kép """"
      ""surname"": 'Smith',     // không hợp lệ: giá trị sử dụng nháy đơn ''
      'isAdmin': false        // không hợp lệ: thuộc tính sử dụng nháy đơn
      ""birthday"": new Date(), // không hợp lệ: toán tử new không được phép
      ""friends"": [0,1,2,3]    // hợp lệ
    }`;
```
`let json = `{
      name: ""John"",           // không hợp lệ: thuộc tính không có nháy kép """"
      ""surname"": 'Smith',     // không hợp lệ: giá trị sử dụng nháy đơn ''
      'isAdmin': false        // không hợp lệ: thuộc tính sử dụng nháy đơn
      ""birthday"": new Date(), // không hợp lệ: toán tử new không được phép
      ""friends"": [0,1,2,3]    // hợp lệ
    }`;` Ngoài ra, JSON khác với Object là không chấp nhậncomment codevàkhông chấp nhận dấu phẩy đuôi:

```js
// comment trong JSON
let json1 = `{
      ""x"": 1, // comment 1
      ""y"": 2
    }`;
JSON.parse(json1); // Lỗi: Unexpected token / in JSON at position 12

// dấu phẩy đuôi trong JSON
let json2 = `{
      ""x"": 1,
      ""y"": 2,
    }`;
JSON.parse(json2); // Lỗi: Unexpected token } in JSON at position 22
```
`// comment trong JSON
let json1 = `{
      ""x"": 1, // comment 1
      ""y"": 2
    }`;
JSON.parse(json1); // Lỗi: Unexpected token / in JSON at position 12

// dấu phẩy đuôi trong JSON
let json2 = `{
      ""x"": 1,
      ""y"": 2,
    }`;
JSON.parse(json2); // Lỗi: Unexpected token } in JSON at position 22`"
288,JSON trong Javascript,Sử dụngrevivertrongJSON.parse,"`reviver` `JSON.parse` Giả sử, bạn có JSON-string lấy từ server như sau:

```js
// title: (meetup title), date: (meetup date)
let str = '{""title"":""Conference"",""date"":""2021-12-19T10:00:00.000Z""}';
```
`// title: (meetup title), date: (meetup date)
let str = '{""title"":""Conference"",""date"":""2021-12-19T10:00:00.000Z""}';` Bạn muốn parse JSON-string về object để lấy thông tin:

```js
let str = '{""title"":""Conference"",""date"":""2021-12-19T10:00:00.000Z""}';

let meetup = JSON.parse(str);

console.log(meetup.date.getDate());
// Lỗi: meetup.date.getDate is not a function
```
`let str = '{""title"":""Conference"",""date"":""2021-12-19T10:00:00.000Z""}';

let meetup = JSON.parse(str);

console.log(meetup.date.getDate());
// Lỗi: meetup.date.getDate is not a function` Đúng vậy, giá trịmeetup.datelà một string""2021-12-19T10:00:00.000Z""chứ không phải đối tượngDate.
`meetup.date` `""2021-12-19T10:00:00.000Z""` `Date` Để giải quyết vấn đề này, bạn có thể sử dụng hàmreviverđể chuyển đổi giá trị củadatethành objectDatenhư sau:
`reviver` `date` `Date` 
```js
let str = '{""title"":""Conference"",""date"":""2021-12-19T10:00:00.000Z""}';

let meetup = JSON.parse(str, function (key, value) {
  // nếu key là ""date"" thì trả về new Date(value)
  if (key === ""date"") {
    return new Date(value);
  }

  // ngược lại thì giữ nguyên giá trị value gốc.
  return value;
});

console.log(meetup.date.getDate()); // 19
```
`let str = '{""title"":""Conference"",""date"":""2021-12-19T10:00:00.000Z""}';

let meetup = JSON.parse(str, function (key, value) {
  // nếu key là ""date"" thì trả về new Date(value)
  if (key === ""date"") {
    return new Date(value);
  }

  // ngược lại thì giữ nguyên giá trị value gốc.
  return value;
});

console.log(meetup.date.getDate()); // 19` Cách này cũng áp dụng được với các đối tượng lồng nhau:

```js
let schedule = `{
      ""meetups"": [
        {""title"":""Conference"",""date"":""2021-12-19T10:00:00.000Z""},
        {""title"":""Birthday"",""date"":""2021-12-20T10:00:00.000Z""}
      ]
    }`;

schedule = JSON.parse(schedule, function (key, value) {
  if (key === ""date"") return new Date(value);
  return value;
});

console.log(schedule.meetups[1].date.getDate()); // 20
```
`let schedule = `{
      ""meetups"": [
        {""title"":""Conference"",""date"":""2021-12-19T10:00:00.000Z""},
        {""title"":""Birthday"",""date"":""2021-12-20T10:00:00.000Z""}
      ]
    }`;

schedule = JSON.parse(schedule, function (key, value) {
  if (key === ""date"") return new Date(value);
  return value;
});

console.log(schedule.meetups[1].date.getDate()); // 20`"
289,JSON trong Javascript,Tổng kết,"JSON trong JavaScript thực chất là một định dạng dữ liệu độc lập và có nhiều thư viện hỗ trợ xử lý JSON.
JSON trong JS hỗ trợ các kiểu dữ liệu như: object nguyên thủy, mảng, string, number, boolean vànull.
`null` JSON cung cấp hai phương thức:
`JSON.stringify` `JSON.parse` Cả hai phương thức trên đều hỗ trợ truyền vào hàm để tùy biến quá trình chuyển đổi.
Nếu một object có phương thứctoJSON, thì phương thức này sẽ được gọi bởiJSON.stringify.
`toJSON` `JSON.stringify`"
290,JSON trong Javascript,Thực hành,"Chuyển đối tượnguserthành JSON rồi đọc lại vào biến khác:
`user` 
```js
let user = {
  name: ""Alex"",
  age: 28,
};
```
`let user = {
  name: ""Alex"",
  age: 28,
};` Xem đáp án

```js
let user = {
  name: ""Alex"",
  age: 28,
};

// chuyển user về JSON
let json = JSON.stringify(user);

// chuyển json về biến khác
let other = JSON.parse(json);
console.log(other); // {name: 'Alex', age: 28}
```
`let user = {
  name: ""Alex"",
  age: 28,
};

// chuyển user về JSON
let json = JSON.stringify(user);

// chuyển json về biến khác
let other = JSON.parse(json);
console.log(other); // {name: 'Alex', age: 28}` Tham khảo"
291,Kế thừa built-in class trong Javascript,Giới thiệu,"Bạn có thể kế thừa built-in class trong JavaScript nhưArray, Map,...
Built-in class là các class được định nghĩa bởi JavaScript."
292,Kế thừa built-in class trong Javascript,Ví dụ kế thừa class Array,"Sau đây, mình sẽ tạo classMyArraykế thừa từ classArrayvà bổ sung thêm phương thứcisEmpty()như sau:
`MyArray` `Array` `isEmpty()` 
```js
class MyArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new MyArray(1, 2, 5, 3, 4);
console.log(arr.isEmpty()); // false

let filteredArr = arr.filter((item) => item >= 3);
console.log(filteredArr); // 5, 3, 4
console.log(filteredArr.isEmpty()); // false
```
`class MyArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new MyArray(1, 2, 5, 3, 4);
console.log(arr.isEmpty()); // false

let filteredArr = arr.filter((item) => item >= 3);
console.log(filteredArr); // 5, 3, 4
console.log(filteredArr.isEmpty()); // false` Một điều cầnchú ýtrong ví dụ trên là phương thứcfiltertrả về đối tượng kiểuMyArraychứ không phảiArray.
`filter` `MyArray` `Array` Bởi phương thứcfiltersử dụngarr.constructorđể khởi tạo đối tượng trả về.
`filter` `arr.constructor` 
```js
class MyArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new MyArray(1, 2, 5, 3, 4);
console.log(arr.constructor); // MyArray
```
`class MyArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new MyArray(1, 2, 5, 3, 4);
console.log(arr.constructor); // MyArray` Như bạn thấy rằng, giá trị củaarr.constructorlàMyArray. Do đó, kết quả trả về đúng kiểuMyArray.
`arr.constructor` `MyArray` `MyArray` Ngoài ra, bạn có thể tùy biến kiểu giá trị trả về bằng cách sử dụng mộtSymbolđặc biệt làSymbol.speciesnhư sau:
`Symbol.species` 
```js
class MyArray extends Array {
  isEmpty() {
    return this.length === 0;
  }

  static get [Symbol.species]() {
    return Array;
  }
}

let arr = new MyArray(1, 2, 5, 3, 4);
let filteredArr = arr.filter((item) => item >= 3);
console.log(filteredArr); // 5, 3, 4
console.log(filteredArr.isEmpty()); // Lỗi: filteredArr.isEmpty is not a function
```
`class MyArray extends Array {
  isEmpty() {
    return this.length === 0;
  }

  static get [Symbol.species]() {
    return Array;
  }
}

let arr = new MyArray(1, 2, 5, 3, 4);
let filteredArr = arr.filter((item) => item >= 3);
console.log(filteredArr); // 5, 3, 4
console.log(filteredArr.isEmpty()); // Lỗi: filteredArr.isEmpty is not a function` Trong ví dụ trên, bạn gặp lỗifilteredArr.isEmpty is not a functionbởi vì kết quả trả về lúc này thuộc kiểuArraychứ không phảiMyArray. Mà trong classArraythì không tồn tại hàmisEmpty.
`filteredArr.isEmpty is not a function` `Array` `MyArray` `Array` `isEmpty`"
293,Kế thừa built-in class trong Javascript,Static không được kế thừa với built-in classes,"Như bạn đã biết trong bàithuộc tính và phương thức static của class trong JavaScript, các thuộc tính và phương thức static của class được kế thừa khi sử dụng từ khóaextends.
`extends` Tuy nhiên, với các built-in classes thìkhông.
Ví dụ như classObjectcó phương thức static làObject.keys()dùng để trả vềcác thuộc tính enumerabletrong object.
`Object` `Object.keys()` Trong khi đó, classArraykế thừa từ classObjectnhưng lại không có phương thức này:
`Array` `Object` 
```js
console.log(Object.keys); // ƒ keys() { [native code] }
console.log(Array.keys); // undefined
```
`console.log(Object.keys); // ƒ keys() { [native code] }
console.log(Array.keys); // undefined` Nguyên nhân là vì, chỉ cóArray.prototypekế thừaObject.prototypechứArraykhông kế thừaObject:
`Array.prototype` `Object.prototype` `Array` `Object` 
```js
console.log(Date.__proto__.__proto__ === Object.prototype); // true
```
`console.log(Date.__proto__.__proto__ === Object.prototype); // true` Đó là điểm khác biệt của kế thừa giữa các built-in classes so với kế thừa các class thông thường dùng từ khóaextends.
`extends` Tham khảo:Extending built-in classes"
294,Kế thừa trong Javascript,Giới thiệu,"Kế thừa class trong JavaScript là cách đểtạo ra một classthông qua việcsử dụng mà mở rộng class khác. Nhờ đó, bạn có thể tạo thêm các tính năng mới mà vẫn giữ nguyên những tính năng hiện tại."
295,Kế thừa trong Javascript,Từ khóaextendkhi kế thừa class,"`extend` Giả sử mình có classAnimalnhư sau:
`Animal` 
```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    console.log(`${this.name} runs with speed ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    console.log(`${this.name} stands still.`);
  }
}

let animal = new Animal(""My animal"");
```
`class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    console.log(`${this.name} runs with speed ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    console.log(`${this.name} stands still.`);
  }
}

let animal = new Animal(""My animal"");` Tiếp theo, mình muốn tạo thêm class khác làRabbit. MàRabbitthực chất cũng làAnimal, nên classRabbitnên được kế thừa từ classAnimalđể có thể sử dụng các phương thức trong đó.
`Rabbit` `Rabbit` `Animal` `Rabbit` `Animal` Nói cách khác, mỗi object tạo bởiRabbitcó thể làm được những thứ màAnimalcó thể làm. Đó chính làbản chất của kế thừa.
`Rabbit` `Animal` Cú pháp để kế thừa class trong JavaScript là:class Child extends Parent. Do đó, classRabbitcó thể được viết như sau:
`class Child extends Parent` `Rabbit` 
```js
class Rabbit extends Animal {
  hide() {
    console.log(`${this.name} hides!`);
  }
}

let rabbit = new Rabbit(""White Rabbit"");

rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.hide(); // White Rabbit hides!
```
`class Rabbit extends Animal {
  hide() {
    console.log(`${this.name} hides!`);
  }
}

let rabbit = new Rabbit(""White Rabbit"");

rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.hide(); // White Rabbit hides!` Bạn thấy rằng, object tạo bởiRabbitcó thể đồng thời sử dụng phương thức trongRabbitlàrabbit.hide()và phương thức trongAnimallàrabbit.run().
`Rabbit` `Rabbit` `rabbit.hide()` `Animal` `rabbit.run()` Về bản chất, từ khóaextendssử dụng cơ chếkế thừa prototypethông qua việc gánRabbit.prototype.[[Prototype]]bằngAnimal.prototype. Nghĩa là nếu một phương thức không được tìm thấy trongRabbit.animalthì JavaScript sẽ tự động tìm kiếm trongAnimal.prototype.
`extends` `Rabbit.prototype.[[Prototype]]` `Animal.prototype` `Rabbit.animal` `Animal.prototype` Ví dụ để tìm phương thứcrabbit.run, JavaScript engine sẽ thực hiện tìm kiếm như sau:
`rabbit.run` `rabbit` `run` `rabbit` `Rabbit.prototype` `run` `Rabbit.prototype` `Animal.prototype` `run` Chú ý:Đằng sau từ khóaextendskhông chỉ là class mà còn có thể làmột biểu thức.
`extends` Ví dụmột hàm trả về một classnhư sau:

```js
function f(message) {
  return class {
    sayHi() {
      console.log(message);
    }
  };
}

class User extends f(""Hello"") {}
new User().sayHi(); // Hello
```
`function f(message) {
  return class {
    sayHi() {
      console.log(message);
    }
  };
}

class User extends f(""Hello"") {}
new User().sayHi(); // Hello` Trong ví dụ trên, classUserkế thừa từ một class là kết quả của việc gọi hàmf(""Hello"").
`User` `f(""Hello"")`"
296,Kế thừa trong Javascript,Ghi đè phương thức,"Khi kế thừa class trong JavaScript, tất cả các phương thức không được định nghĩa trong class conRabbitsẽ được tìm và lấy ở class chaAnimalđể sử dụng.
`Rabbit` `Animal` Nhưng ở khía cạnh ngược lại, nếu mìnhđịnh nghĩa lại một phương thứccủa classAnimaltrong classRabbit, giả sử là phương thứcstop. Khi đó, phương thứcstoptrongRabbitsẽ được sử dụng:
`Animal` `Rabbit` `stop` `stop` `Rabbit` 
```js
class Rabbit extends Animal {
  stop() {
    // phương thức này được sử dụng khi gọi `rabbit.stop()`
    // thay vì phương thức `stop` trong class Animal.
  }
}
```
`class Rabbit extends Animal {
  stop() {
    // phương thức này được sử dụng khi gọi `rabbit.stop()`
    // thay vì phương thức `stop` trong class Animal.
  }
}` Đó chính làghi đè thuộc tínhkhi kế thừa class trong JavaScript.
Tuy nhiên, chúng ta thườngkhông muốn thay thế hoàn toàn phương thức chamà sẽ dựa trên đó và rồi thực hiện thêm một số tác vụ. Nghĩa là mình sẽ làm một thứ gì đó, nhưng vẫn gọi đến phương thức chatrước hoặc sau công việc kia.
Để giải quyết vấn đề này, class cung cấp từ khóasupervới cách sử dụng như sau:
`super` `super.method()` `super(...)` Ví dụ, classRabbitkế thừa classAnimalvà ghi đè phương thứcstop:
`Rabbit` `Animal` `stop` 
```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    console.log(`${this.name} runs with speed ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    console.log(`${this.name} stands still.`);
  }
}

class Rabbit extends Animal {
  hide() {
    console.log(`${this.name} hides!`);
  }

  stop() {
    super.stop(); // gọi đến phương thức stop của Animal    this.hide(); // và rồi gọi phương thức hide của chính nó.  }}

    let rabbit = new Rabbit(""White Rabbit"");

    rabbit.run(5);
    // White Rabbit runs with speed 5.

    rabbit.stop();
    // White Rabbit stands still.
    // White Rabbit hides!
  }
}
```
`class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    console.log(`${this.name} runs with speed ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    console.log(`${this.name} stands still.`);
  }
}

class Rabbit extends Animal {
  hide() {
    console.log(`${this.name} hides!`);
  }

  stop() {
    super.stop(); // gọi đến phương thức stop của Animal    this.hide(); // và rồi gọi phương thức hide của chính nó.  }}

    let rabbit = new Rabbit(""White Rabbit"");

    rabbit.run(5);
    // White Rabbit runs with speed 5.

    rabbit.stop();
    // White Rabbit stands still.
    // White Rabbit hides!
  }
}` Trong ví dụ trên,Rabbitđã có phương thứcstopriêng. Và phương thức này gọi đến phương thứcstopcủa class chaAnimallàsuper.stop().
`Rabbit` `stop` `stop` `Animal` `super.stop()` Chú ý:arrow functionkhông cósuper. Dó đó,supersẽ được tham chiếu đến hàm bên ngoài, ví dụ:
`super` `super` 
```js
class Rabbit extends Animal {
  stop() {
    setTimeout(() => {
      super.stop(); // gọi đến hàm stop của class Animal sau 1000ms
    }, 1000);
  }
}
```
`class Rabbit extends Animal {
  stop() {
    setTimeout(() => {
      super.stop(); // gọi đến hàm stop của class Animal sau 1000ms
    }, 1000);
  }
}` Ở ví dụ trên,supertrong arrow function làhoàn toàn tương đươngvớisupertrong hàmstop. Vì vậy, kết quả thực hiện hoàn toàn chính xác như mong muốn.
`super` `super` `stop` Tuy nhiên, nếu thay arrow function bằng hàm thông thường thì kết quả sẽ khác:

```js
setTimeout(function () {
  super.stop(); // kết quả không như mong muốn
}, 1000);
```
`setTimeout(function () {
  super.stop(); // kết quả không như mong muốn
}, 1000);`"
297,Kế thừa trong Javascript,Ghi đè hàm khởi tạo,"Khi kế thừa class trong JavaScript, việcghi đè hàm khởi tạo phức tạp hơnso với việc ghi đè phương thức thông thường.
Trong các ví dụ trên, classRabbitchưa có hàm khởi tạo. Do đó, JavaScript engine sẽ tự động tạo mộthàm khởi tạo trốngnhư sau:
`Rabbit` 
```js
class Rabbit extends Animal {
  constructor(...args) {    super(...args);  }}
```
`class Rabbit extends Animal {
  constructor(...args) {    super(...args);  }}` Hàm khởi tạo củaRabbitkhông thực hiện thêm gì ngoài việc gọi hàm khởi tạo của class chaAnimalthông qua câu lệnhsuper(...args).
`Rabbit` `Animal` `super(...args)` Bây giờ, mình sẽ thay đổi hàm khởi tạo củaRabbit, bằng cách truyền thêm tham sốearLengthbên cạnhnamenhư sau:
`Rabbit` `earLength` `name` 
```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  } // ...
}

// Sử dụng
let rabbit = new Rabbit(""White Rabbit"", 10);
// Lỗi:
// Uncaught ReferenceError: Must call super constructor in derived class
// before accessing 'this' or returning from derived
```
`class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  } // ...
}

// Sử dụng
let rabbit = new Rabbit(""White Rabbit"", 10);
// Lỗi:
// Uncaught ReferenceError: Must call super constructor in derived class
// before accessing 'this' or returning from derived` Với cách làm trên thì đã có lỗi xảy ra. Và lỗi này được hiểu là: Phải gọi hàm khởi tạo của class cha trước khi truy cập vàothishoặc kết thúc hàm khởi tạo.
`this` Vì vậy, mình sẽ sửa lại đoạn code trên như sau:

```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }
  // ...
}

// Sử dụng:let rabbit = new Rabbit(""White Rabbit"", 10);console.log(rabbit.name); // White Rabbitconsole.log(rabbit.earLength); // 10
```
`class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }
  // ...
}

// Sử dụng:let rabbit = new Rabbit(""White Rabbit"", 10);console.log(rabbit.name); // White Rabbitconsole.log(rabbit.earLength); // 10`"
298,Kế thừa trong Javascript,Tổng kết,"Những kiến thức cơ bản cần nhớ về kế thừa class trong JavaScript là:
`class Child extends Parent` `Child.prototype.__proto__` `Parent.prototype` `Child` `Parent` `super()` `this` `super.method()` `Child` `method` `Parent` Chú ý:arrow function không cóthiscũng nhưsuper. Vì vậy, chúng sẽ được tham chiếu đến hàm bên ngoài.
`this` `super` Tham khảo:Class inheritance"
299,Kết thúc Promise chaining trong JavaScript,Giới thiệu,"Có thể bạn đã quen với việc sử dụngPromiseđể xử lý bất đồng bộ trong JavaScript. Tuy nhiên, trong trường hợp thực hiện nhiều Promise liên tiếp nhau (Promise chaining) mà bạn muốn dừng giữa chừng thì sao? Hay nói cách khác là làm sao để kết thúc sớm Promise chaining trong JavaScript?"
300,Kết thúc Promise chaining trong JavaScript,Bài toán thực tế,"Thử xét một bài toán thực tế khi mà việc kết thúc sớm Promise chaining là cần thiết. Đó là khi triển khai API để đăng ký User qua Email. Mình có thể tóm tắt lại các bước thực hiện như sau:

```js
Tìm kiếm User qua email
  .then(
    Nếu email đã tồn tại thì sẽ kết thúc sớm Promise chaining.
    Ngược lại sẽ thực hiện bước tiếp theo.
  )
  .then(
    Hash mật khẩu.
  )
  .then(
    Tạo User và lưu vào cơ sở dữ liệu.
  )
  .catch(
    Xử lý khi có bất kỳ lỗi gì xảy ra.
  )
```
`Tìm kiếm User qua email
  .then(
    Nếu email đã tồn tại thì sẽ kết thúc sớm Promise chaining.
    Ngược lại sẽ thực hiện bước tiếp theo.
  )
  .then(
    Hash mật khẩu.
  )
  .then(
    Tạo User và lưu vào cơ sở dữ liệu.
  )
  .catch(
    Xử lý khi có bất kỳ lỗi gì xảy ra.
  )` Bạn thấy đó, ngay tại bướcthenđầu tiên, nếu email đã tồn tại thì mình sẽ kết thúc sớm Promise chaining. Có thể bạn sẽ triển khai API để đăng ký User qua Email theo cách khác của mình. Tuy nhiên, đây chỉ là một ví dụ dùng để minh hoạ mà thôi.
Vậy làm sao để kết thúc sớm Promise chaining trong JavaScript?
Dưới đây, mình sẽ xem xét một bài phi thực tế để biết cách triển khai code như thế nào nhé!"
301,Kết thúc Promise chaining trong JavaScript,Bài toán ví dụ,"Giả sử mình có đoạn code dưới đây:

```js
const increase = (x) => {
  console.log(x);
  return x + 1;
};

const run = (x) => {
  new Promise((resolve, reject) => {
    resolve(x);
  })
    .then((res) => increase(res))
    .then((res) => increase(res))
    .then((res) => increase(res))
    .catch((err) => console.log(""Catched: "" + err));
};
```
`const increase = (x) => {
  console.log(x);
  return x + 1;
};

const run = (x) => {
  new Promise((resolve, reject) => {
    resolve(x);
  })
    .then((res) => increase(res))
    .then((res) => increase(res))
    .then((res) => increase(res))
    .catch((err) => console.log(""Catched: "" + err));
};` Trong đó:
Với hàmrunnhư trên thì với mọi giá trị của x, 3 cáithentrên luôn được thực hiện. Ví dụ với x = 4 thì kết quả thu được là:

```js
run(4);
/*
 * 4
 * 5
 * 6
 */
```
`run(4);
/*
 * 4
 * 5
 * 6
 */` Nếu mình muốn kết thúc sớm Promise chaining ngay tạithenđầu tiên khi giá trị củareslớn hơn 3 thì sao?
Có 2 cách để giải quyết bài toán này, đó là:không thực hiện returnhoặcsử dụngPromise.reject()
Bình thường, khi thực hiệnreturn, giá trịreturnsẽ được đưa đến mắt xích tiếp theo của chuỗi Promise để xử lý. Và nếu bạn khôngreturnthì giá trị đó sẽ được hiểu làundefined. Dựa vào đặc điểm này, mình sẽ thay đổi đoạn code trên như sau:

```js
const increase = (x) => {
  console.log(x);
  return x + 1;
};

const run = (x) => {
  new Promise((resolve, reject) => {
    resolve(x);
  })
    .then((res) => {
      if (res <= 3) return increase(res);
    })
    .then((res) => {
      if (res !== undefined) return increase(res);
    })
    .then((res) => {
      if (res !== undefined) return increase(res);
    })
    .catch((err) => console.log(""Catched: "" + err));
};

run(3);
/*
 * 3
 * 4
 * 5
 */

run(4);
// Nothing
```
`const increase = (x) => {
  console.log(x);
  return x + 1;
};

const run = (x) => {
  new Promise((resolve, reject) => {
    resolve(x);
  })
    .then((res) => {
      if (res <= 3) return increase(res);
    })
    .then((res) => {
      if (res !== undefined) return increase(res);
    })
    .then((res) => {
      if (res !== undefined) return increase(res);
    })
    .catch((err) => console.log(""Catched: "" + err));
};

run(3);
/*
 * 3
 * 4
 * 5
 */

run(4);
// Nothing` Vớix = 3: giá trị củarestạithenđầu tiên là 3, thoả mãnres <= 3nên đoạn code đó trả vềincrease(res). Dẫn đến, giá trị củarestại cácthentiếp theo lần lượt là 4, 5.
`res <= 3` `increase(res)` Vớix = 4: ngay tạithenđầu tiênressẽ bằng 4, không thoả mãnres <= 3nên đoạn codereturn increase(res)sẽ không được thực hiện. Dẫn đến, đoạnthennày sẽ trả vềundefined. Do đó cácthentiếp theo, giá trị củaressẽ làundefined. Mà mình đã kiểm tra nếures !== undefinedthì mới thực hiện. Tóm lại, mình đã kết thúc sớm Promise chaining ngay tạithenđầu tiên rồi.
`res <= 3` `return increase(res)` `res !== undefined` Tuy nhiên, nếu để ý kĩ thì bạn sẽ thấy cách này chỉ giải quyết được về mặt kết quả. Còn về hình thức thì các mắt xích của chuỗi Promise vẫn được nhảy đến. Điều này có thể tiềm ẩn nhiềuBugsau này. Vì vậy, cái mà mình mong muốn thực sự là việc kết thúc sớm Promise chaining sẽ giúp thoát khỏi chuỗi Promise một cách hoàn toàn.
Đúng vậy, việc sử dụngPromise.reject()sẽ giúp bạn kết thúc sớm Promise chaining bằng cách nhảy thẳng đến phầncatch. Khi đó, đoạn code trên sẽ trở thành:

```js
const increase = (x) => {
  console.log(x);
  return x + 1;
};

const run = (x) => {
  new Promise((resolve, reject) => {
    resolve(x);
  })
    .then((res) => {
      if (res <= 3) return increase(res);
      return Promise.reject(res);
    })
    .then((res) => increase(res))
    .then((res) => increase(res))
    .catch((err) => console.log(""Catched: "" + err));
};

run(3);
/*
 * 3
 * 4
 * 5
 */
run(4);
// Catched: 4
```
`const increase = (x) => {
  console.log(x);
  return x + 1;
};

const run = (x) => {
  new Promise((resolve, reject) => {
    resolve(x);
  })
    .then((res) => {
      if (res <= 3) return increase(res);
      return Promise.reject(res);
    })
    .then((res) => increase(res))
    .then((res) => increase(res))
    .catch((err) => console.log(""Catched: "" + err));
};

run(3);
/*
 * 3
 * 4
 * 5
 */
run(4);
// Catched: 4` Trong trường hợp này, mình chỉ cần thêm phần xử lý tạithenđầu tiên.
Vớix = 3: Kết quả vẫn như phần trên.
Vớix = 4: Tạithenđầu tiên,resbằng 4, không thoả mãnres <= 3nên đoạn đó sẽ thực hiệnreturn Promise.reject(res). Điều này dẫn đến các đoạnthentiếp theo sẽ bị bỏ qua mà nhảy thẳng đến đoạncatch. Tại đây, giá trị củaerrbằng giá trị củaresđã bịrejectbên trên, nên bằng 4.
`res <= 3` `return Promise.reject(res)` Rõ ràng, việc sử dụngPromise.reject()đã giúp kết thúc sớm Promise chaining một cách hoàn toàn rồi."
302,Kết thúc Promise chaining trong JavaScript,Lời kết,"Như vậy là mình đã giới thiệu với bạn 2 cách để kết thúc sớm Promise chaining trong JavaScript. Nếu bạn biết thêm cách nào khác để thực hiện việc này thì hãy chia sẻ với mình trong phần bình luận phía dưới nhé!
Xin chào và hẹn gặp lại!"
303,Khởi tạo đối tượng với từ khóa new trong javascript có tác dụng gì,Giới thiệu,"Trong các bài viết trước, mình chủ yếu dùng cú pháp{...}đểkhởi tạo object. Tuy nhiên, cách này chỉ dùng đểkhởi tạo một object riêng lẻ.
`{...}` Nếu mình muốn khởi tạonhiều object tương tự nhauthì sao?
Để giải quyết vấn đề này, bạn có thể sử dụng toán tửnewtrong JavaScript kết hợp với mộthàmkhởi tạo.
`new`"
304,Khởi tạo đối tượng với từ khóa new trong javascript có tác dụng gì,Hàm khởi tạo và new trong JavaScript là gì?,"Hàm khởi tạo về bản chất làmột hàm bình thường, nhưng dùng đểkhởi tạo object.
Một số đặc điểm của hàm khởi tạo là:
`new` Ví dụ:

```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}

let root = new Point(0, 0);
console.log(root.x, root.y); // 0 0
```
`function Point(x, y) {
  this.x = x;
  this.y = y;
}

let root = new Point(0, 0);
console.log(root.x, root.y); // 0 0` Khi một hàm được gọi với toán tửnew, JavaScript Engine sẽ xử lý các bước như sau:
`new` `this` `this` `this` `this` Nói cách khác, cú phápnew Point(...)thực hiện:
`new Point(...)` 
```js
function Point(x, y) {
  // this = {}; // ngầm định khởi tạo object rỗng
  this.x = x;
  this.y = y;

  // return this; // ngầm định trả về this}
}
```
`function Point(x, y) {
  // this = {}; // ngầm định khởi tạo object rỗng
  this.x = x;
  this.y = y;

  // return this; // ngầm định trả về this}
}` Như vậy,new Point(0,0)tương đương với cách khởi tạo object là:
`new Point(0,0)` 
```js
let root = {
  x: 0,
  y: 0,
};
```
`let root = {
  x: 0,
  y: 0,
};` Bây giờ, nếu bạn muốn tạo ra cácpointkhác, bạn chỉ cần gọinew p1(1, 2),new p2(2, 3),... thay vì phải sử dụng cú pháp{...}nhiều lần (và dài dòng hơn).
`new p1(1, 2)` `new p2(2, 3)` `{...}` Lưu ý
Mục đích chính của hàm khởi tạo là để dễ dàngtái sử dụng code.Arrow functionkhông cóthisnên không được dùng làm hàm khởi tạo.
`this` Nếu hàm khởi tạo không có tham số thì bạn có thể bỏ qua cặp dấu ngoặc đơn(), ví dụ:
`()` 
```js
function Point() {
  this.x = 0;
  this.y = 0;
}

let root = new Point();
console.log(root.x, root.y); // 0
```
`function Point() {
  this.x = 0;
  this.y = 0;
}

let root = new Point();
console.log(root.x, root.y); // 0` Tuy nhiên, mình khuyên bạn nên sử dụng cách gọi hàm khởi tạo với cặp dấu ngoặc đơn(), vì nó chuẩn hơn vàđúng với cú pháp gọi hàm.
`()` Bạn có thể khai báo, đồng thời khởi tạo object ngay với cú phápnew function(){...}như sau:
`new function(){...}` 
```js
let root = new (function () {
  this.x = 1;
  this.y = 2;

  /*
   * Code xử lý khác tại đây
   */
})();

console.log(root.x, root.y); // 1 2
```
`let root = new (function () {
  this.x = 1;
  this.y = 2;

  /*
   * Code xử lý khác tại đây
   */
})();

console.log(root.x, root.y); // 1 2` Cú pháp này gọi làIFFE.
Khi tạo object theo cách này, hàm khởi tạo sẽ chỉ được gọi một lần (vì bản chất hàm khởi tạokhông được lưu vào biến nào).
Vì vậy, mục đích của cách khai báo nàykhông phải để tái sử dụng, mà để đóng gói code liên quan trong một hàm khởi tạo."
305,Khởi tạo đối tượng với từ khóa new trong javascript có tác dụng gì,Kiểm tra hàm khởi tạo được gọi với new trong JavaScript,"Để kiểm tra hàm khởi tạo có được gọi với new trong JavaScript hay không, bạn sử dụng thuộc tính đặc biệt lànew.target.
`new.target` Nếu hàm được gọi theo cách thông thường thìnew.targetsẽ bằngundefined, ngược lạinew.targetbằng chính function:
`new.target` `undefined` `new.target` 
```js
function Point() {
  console.log(new.target);
}

Point(); // undefined
new Point(); // ƒ Point() { console.log(new.target); }
```
`function Point() {
  console.log(new.target);
}

Point(); // undefined
new Point(); // ƒ Point() { console.log(new.target); }` Thuộc tính đặc biệt này có thể được áp dụng để kiểm tra xem hàm khởi tạo có được gọi vớinewhay không.
`new` Trường hợp hàm khởi tạo không được gọi vớinew, mình có thể xử lý thêm để trả về giống cách gọi hàm vớinew:
`new` `new` 
```js
function Point(x, y) {
  if (!new.target) {
    return new Point(x, y);
  }
  this.x = x;
  this.y = y;
}

let root = Point(0, 0);
console.log(root.x, root.y); // 0 0
```
`function Point(x, y) {
  if (!new.target) {
    return new Point(x, y);
  }
  this.x = x;
  this.y = y;
}

let root = Point(0, 0);
console.log(root.x, root.y); // 0 0` Với cách viết như này, bạn có thể khởi tạo object vớinewhoặc không cónewthì đều cho kết quả giống nhau.
`new` `new` Lưu ý
new.targetít được sử dụng trong thực tế.Việc khởi tạo objectnên luôn luôn sử dụng từ khóanewđể đảm bảo code rõ ràng và dễ hiểu nhất.
`new.target` `new`"
306,Khởi tạo đối tượng với từ khóa new trong javascript có tác dụng gì,Trả về giá trị từ hàm khởi tạo,"Thông thường, hàm khởi tạo không có từ khóareturnvì JavaScript Engine ngầm định sẽ trả vềthis. Tuy nhiên, bạn có thể sử dụngreturntrong hàm khởi tạo với quy tắc như sau:
`return` `this` `return` `return` `this` `return` `return` Nói cách khác,returnvới một object sẽ trả về object đó, ngược lại thì trả vềthis.
`return` `this` Ví dụ hàm khởi tạo trả về một object khácthis:
`this` 
```js
function Point(x, y) {
  this.x = x;
  this.y = y;

  return { x: 100, y: 100 }; // trả về object này thay vì this}
}

let p = new Point(0, 0);
console.log(p.x, p.y); // 100 100
```
`function Point(x, y) {
  this.x = x;
  this.y = y;

  return { x: 100, y: 100 }; // trả về object này thay vì this}
}

let p = new Point(0, 0);
console.log(p.x, p.y); // 100 100` Ví dụ hàm khởi tạo trả về giá trị nguyên thủy:

```js
function Point(x, y) {
  this.x = x;
  this.y = y;

  return 1; // return trả về giá trị nguyên thủy bị bỏ qua}
}
let p = new Point(0, 0);
console.log(p.x, p.y); // 0 0
```
`function Point(x, y) {
  this.x = x;
  this.y = y;

  return 1; // return trả về giá trị nguyên thủy bị bỏ qua}
}
let p = new Point(0, 0);
console.log(p.x, p.y); // 0 0`"
307,Khởi tạo đối tượng với từ khóa new trong javascript có tác dụng gì,Định nghĩa phương thức trong hàm khởi tạo,"Object không chỉ có thuộc tính mà còn có cảphương thức.
Và dĩ nhiên, bạn có thểđịnh nghĩa phương thức trong hàm khởi tạocủa object, ví dụ:

```js
function Point(x, y) {
  this.x = x;
  this.y = y;

  this.printLog = function () {
    console.log(this.x, this.y);
  };
}

let root = new Point(0, 0);
root.printLog(); // 0 0
```
`function Point(x, y) {
  this.x = x;
  this.y = y;

  this.printLog = function () {
    console.log(this.x, this.y);
  };
}

let root = new Point(0, 0);
root.printLog(); // 0 0` Để tạo nhiều object phức tạp hơn, bạn có thể sử dụng cú pháp nâng cao hơn nhưprototypehayclass(sẽ được giới thiệu sau)."
308,Khởi tạo đối tượng với từ khóa new trong javascript có tác dụng gì,Tổng kết,"Sau đây là những kiến thức cơ bản cần nhớ về khởi tạo object với toán tửnewtrong JavaScript:
`new` `new` `this` `return` `this` `this` `new function(){...}` `return` `return` `return` `this`"
309,Khởi tạo đối tượng với từ khóa new trong javascript có tác dụng gì,Thực hành,"Cho đoạn code sau:

```js
function A() { ... }
    function B() { ... }

    let a = new A;
    let b = new B;

    console.log(a === b); // true
```
`function A() { ... }
    function B() { ... }

    let a = new A;
    let b = new B;

    console.log(a === b); // true` Có cách nào để tạo hàmAvàBsao chonew A() === new B()?
`A` `B` `new A() === new B()` Xem đáp án
Đáp án là:Có.
Đểnew A() === new B()làtruethì hàm khởi tạoAvàBphải trả về cùng một object.
`new A() === new B()` `true` `A` `B` 
```js
let obj = {};
function A() {
  return obj;
}
function B() {
  return obj;
}
let a = new A();
let b = new B();

console.log(a === b); // true
```
`let obj = {};
function A() {
  return obj;
}
function B() {
  return obj;
}
let a = new A();
let b = new B();

console.log(a === b); // true` Viết hàm khởi tạo objectCalculatorvới ba phương thức:
`Calculator` `read()` `prompt` `add()` `mul()` Ví dụ:

```js
let calculator = new Calculator();
calculator.read();
console.log(calculator.sum());
console.log(calculator.mul());
```
`let calculator = new Calculator();
calculator.read();
console.log(calculator.sum());
console.log(calculator.mul());` Xem đáp án

```js
function Calculator() {
  // Phương thức read()
  this.read = function () {
    this.a = +prompt(""Nhập vào số a:"", 0);
    this.b = +prompt(""Nhập vào số b:"", 0);
  };

  // Phương thức add()
  this.add = function () {
    return this.a + this.b;
  };

  // Phương thức mul()
  this.mul = function () {
    return this.a * this.b;
  };
}

let calculator = new Calculator();
calculator.read();
console.log(calculator.add());
console.log(calculator.mul());
```
`function Calculator() {
  // Phương thức read()
  this.read = function () {
    this.a = +prompt(""Nhập vào số a:"", 0);
    this.b = +prompt(""Nhập vào số b:"", 0);
  };

  // Phương thức add()
  this.add = function () {
    return this.a + this.b;
  };

  // Phương thức mul()
  this.mul = function () {
    return this.a * this.b;
  };
}

let calculator = new Calculator();
calculator.read();
console.log(calculator.add());
console.log(calculator.mul());` Lưu ý
Hàmprompttrả về kết quả là string. Vì vậy, mình thêm toán tử+đằng trước đểchuyển đổi kiểu dữ liệuvề number, trước khi gán chothis.avàthis.b.
`prompt` `+` `this.a` `this.b` Viết hàm khởi tạoCounter(startValue)(giả sửstartValuelà số).
`Counter(startValue)` `startValue` Object tạo ra có những đặc điểm sau:
`startValue` `value` `read()` `prompt()` `value` Ví dụ:

```js
let counter = new Counter(1);

counter.read();
counter.read();

console.log(counter.value); // giá trị hiện tại của value
```
`let counter = new Counter(1);

counter.read();
counter.read();

console.log(counter.value); // giá trị hiện tại của value` Xem đáp án

```js
function Counter(startValue) {
  this.value = startValue;

  this.read = function () {
    this.value += +prompt(""Nhập vào một số:"", 0);
  };
}

let counter = new Counter(1);

counter.read();
counter.read();

console.log(counter.value); // giá trị hiện tại của value
```
`function Counter(startValue) {
  this.value = startValue;

  this.read = function () {
    this.value += +prompt(""Nhập vào một số:"", 0);
  };
}

let counter = new Counter(1);

counter.read();
counter.read();

console.log(counter.value); // giá trị hiện tại của value`"
310,Kiểu dữ liệu number trong Javascript,Giới thiệu,"Có hai kiểu dữ liệu liên quan đếnnumber trong JavaScriptlà: number thông thường và bigInt.
`253` `-253` KiểubigIntlà kiểu số đặc biết nên mình sẽ tìm hiểu sau. Bài viết này chỉ tập trung vàonumber thông thường."
311,Kiểu dữ liệu number trong Javascript,Cách khác để biểu diễn number trong JavaScript,"Giả sử bạn cần biểu diễn số 1 tỷ:

```js
let oneBillion = 1000000000;
```
`let oneBillion = 1000000000;` Nếu bạn chỉ nhìn qua thì rất khó nhận biết đó là số 1 tỷ. Có thể bạn sẽ phảiđếm xem có bao nhiêu số 0trong đó.
Thay vì phải đếm như vậy, JavaScript cho phép bạn sử dụng kí tự gạch chân_để phân tách các chữ số:
`_` 
```js
let oneBillion = 1_000_000_000;
```
`let oneBillion = 1_000_000_000;` Rõ ràng cách viết nàydễ nhìn hơn. Và kết quả thì vẫn không thay đổi. Vì JavaScript engine sẽ bỏ qua, không xử lý kí tự_trong number.
`_` Trong thực tế cuộc sống, chúng ta thường không muốn viết hết các chữ số0mà thường viết tắt, ví dụ: 1000 thành 1K, 1000000 thành 1M,...
`0` Với JavaScript cũng vậy, bạn có thể dùng chữ cáieđể biểu diễn số lượng chữ số0, ví dụ:
`e` `0` 
```js
let a = 1e3; // 1_000 - 1 nghìn
let b = 1e6; // 1_000_000 - 1 triệu
let c = 1e9; // 1_000_000_000 - 1 tỷ
let d = 4.6e9; // 4_600_000_000 - 4.6 tỷ
```
`let a = 1e3; // 1_000 - 1 nghìn
let b = 1e6; // 1_000_000 - 1 triệu
let c = 1e9; // 1_000_000_000 - 1 tỷ
let d = 4.6e9; // 4_600_000_000 - 4.6 tỷ` Nói cách khác,eNthực hiệnnhân số(trướce) bởi với số10 mũ N.
`eN` `e` 
```js
1e3 === 1 * 1000; // e3 tương đương *1000
1.23e4 === 1.23 * 10000; // e4 tương đương *10000
```
`1e3 === 1 * 1000; // e3 tương đương *1000
1.23e4 === 1.23 * 10000; // e4 tương đương *10000` Tương tự, bạn cũng có thể dùngeđể biểu diễn những số rất nhỏ bằng cách thayNở trên bằng số âm:
`e` `N` 
```js
0.000001 === 1e-6;
```
`0.000001 === 1e-6;` Nói cách khác,e-Nthực hiệnchia số(trướce) bởi số10 mũ N.
`e-N` `e` 
```js
1e-3 === 1 / 1000; // e3 tương đương /1000
1.23e-4 === 1.23 / 10000; // e4 tương đương /10000
```
`1e-3 === 1 / 1000; // e3 tương đương /1000
1.23e-4 === 1.23 / 10000; // e4 tương đương /10000` Các số mình thường viết trên đây là biểu diễn ở hệ thập phân (cơ số 10). Ngoài ra, bạn có thể biểu diễn number trong JavaScript ở hệ thập lục phân (cơ số 16), bát phân (cơ số 8) và nhị phân (cơ số 2).
`0x` `0o` `0b` biểu diễn số ở hệ 16, 8 và 2 là:

```js
// Hệ cơ số 16
console.log(0xff); // 255
console.log(0xff); // 255 - không phân biệt hoa thường

// Hệ cơ số 8
console.log(0o377); // 255

// Hệ cơ số 2
console.log(0b11111111); // 255
```
`// Hệ cơ số 16
console.log(0xff); // 255
console.log(0xff); // 255 - không phân biệt hoa thường

// Hệ cơ số 8
console.log(0o377); // 255

// Hệ cơ số 2
console.log(0b11111111); // 255` Phương thứcnum.toString(base)trả về string biểu diễn sốnumở hệ cơ sốbase, ví dụ:
`num.toString(base)` `num` `base` 
```js
let num = 255;

// chuyển sang hệ cơ số 16
console.log(num.toString(16)); // ff

// chuyển sang hệ cơ số 2
console.log(num.toString(2)); // 11111111
```
`let num = 255;

// chuyển sang hệ cơ số 16
console.log(num.toString(16)); // ff

// chuyển sang hệ cơ số 2
console.log(num.toString(2)); // 11111111` Trong đó,basecó giá trị nằm trong đoạntừ 2 đến 36. Mặc định,baselà10.
`base` `base` Một số trường hợp phổ biến:
`base=16` `0..9` `A-F` `base=2` `0` `1` `base=36` `0..9` `A..Z` 
```js
console.log((1234567890).toString(36)); // kf12oi
```
`console.log((1234567890).toString(36)); // kf12oi` `..` `toString()` Nếu bạn dùngmột dấu chấmthì sẽ có lỗi cú pháp:

```js
console.log(1234567890.toString(36));
    // Uncaught SyntaxError: Invalid or unexpected token
```
`console.log(1234567890.toString(36));
    // Uncaught SyntaxError: Invalid or unexpected token` Bởi vì, JavaScript hiểu rằng sau dấu.đầu tiên làphần thập phâncủa số thực. Mà đằng sau.lại làtoStringthì chắc chắn sai cú pháp.
`.` `.` `toString` Ngược lại, khi bạn viết hai dấu chấm.., JavaScript ngầm định phần thập phân làrỗng, rồi sau đó đến phương thức.
`..` Nói cách khác, cách viết hai dấu chấm..tương đương với cách viết sử dụng()như sau:
`..` `()` 
```js
//console.log(1234567890..toString(36)); // kf12oi
console.log((1234567890).toString(36)); // kf12oi
```
`//console.log(1234567890..toString(36)); // kf12oi
console.log((1234567890).toString(36)); // kf12oi` Để code rõ ràng và an toàn hơn, bạn nên sử dụng()
`()`"
312,Kiểu dữ liệu number trong Javascript,Làm tròn number trong JavaScript,"Một trong những phép toánhay sử dụng với numbertrong JavaScript nhất làlàm tròn số. JavaScript có sẵn một số hàm giúp bạn làm tròn số như:
►Math.floor:
`Math.floor` Từfloordịch ra làsàn nhà- suy ra hàmMath.floordùng đểlàm tròn xuống. Ví dụ:3.1trở thành3và-1.1trở thành-2.
`Math.floor` `3.1` `3` `-1.1` `-2` ►Math.ceil:
`Math.ceil` Từceildịch ra làtrần nhà- suy ra hàmMath.ceildùng đểlàm tròn lên. Ví dụ:3.1trở thành4và-1.1trở thành-1.
`Math.ceil` `3.1` `4` `-1.1` `-1` ►Math.round:
`Math.round` Hàm này trả vềsố nguyên gần nhất(có thể làm tròn lên hoặc làm tròn xuống). Ví dụ:3.1trả về3,3.6trở thành4và giá trị ở giữa3.5cũng trở thành4.
`3.1` `3` `3.6` `4` `3.5` `4` ►Math.trunc(không hỗ trợ bởi trình duyệtIE):
`Math.trunc` Hàm này trả về số nguyên bằng cách xóa bỏ đi tất cả thành phần sau dấu phẩy. Ví dụ:3.1trở thành3và-1.1trở thành-1.
`3.1` `3` `-1.1` `-1` Trên đây là những hàm giúplàm tròn thành số nguyên. Vậy làm sao đểlàm tròn thành số thựcvới chính xácnchữ số sau dấu phẩy.
`n` làm sao để làm tròn số1.2345thành1.23(2 chữ số sau dấu phẩy)?
`1.2345` `1.23` Cóhai cáchđể giải quyết vấn đề trên.
Ví dụ để làm tròn 2 chữ số sau dấu phẩy, bạn nhân số ban đầu với100(2 chữ số0). Sau đó, bạn dùngMath.roundđể làm tròn kết quả về số nguyên gần nhất. Cuối cùng, bạn chia kết quả cho100sẽ thu được kết quả như mong muốn.
`100` `0` `Math.round` `100` 
```js
let a = 1.2345;

// a nhân với 100
let b = a * 100; // 123.45

// làm tròn b với Math.round
let c = Math.round(b); // 123

// chia c cho 100
let d = c / 100; // bằng 123 / 100

console.log(d); // 1.23
```
`let a = 1.2345;

// a nhân với 100
let b = a * 100; // 123.45

// làm tròn b với Math.round
let c = Math.round(b); // 123

// chia c cho 100
let d = c / 100; // bằng 123 / 100

console.log(d); // 1.23` `toFixed(n)` Phương thức này sẽ làm tròn số vàtrả về stringvới chính xácnchữ số sau dấu phẩy.
`n` 
```js
let a = 1.2345;
let b = a.toFixed(2);
console.log(b); // ""1.23""
```
`let a = 1.2345;
let b = a.toFixed(2);
console.log(b); // ""1.23""` Trường hợp phần thập phân không đủnchữ số thì phương thứctoFixed(n)tự động thêm các chữ số0phía sau cho đủnchữ số.
`n` `toFixed(n)` `0` `n` 
```js
let a = 1.2345;
let b = a.toFixed(6);
console.log(b); // ""1.234500""
```
`let a = 1.2345;
let b = a.toFixed(6);
console.log(b); // ""1.234500""` Đểchuyển đổi kiểu dữ liệustring về number, bạn có thể dùng hàmNumber()hoặc toán tử một ngôi+, ví dụ:
`Number()` `+` 
```js
let a = 1.2345;
let b = a.toFixed(2); // ""1.23""

let c = Number(b);
console.log(c, typeof c); // 1.23 number
```
`let a = 1.2345;
let b = a.toFixed(2); // ""1.23""

let c = Number(b);
console.log(c, typeof c); // 1.23 number`"
313,Kiểu dữ liệu number trong Javascript,Sai số với number trong JavaScript,"Trong JavaScript, số thông thường được biểu diễn dưới dạng số thực dấu phẩy động theo chuẩnIEEE-754. Định dạng này sử dụng64 bitđể lưu trữ một số, trong đó:
`0` `1` Nếu một số quá lớn,vượt ngoài khả năng biểu diễn của 64 bitthì sẽ trở thànhInfinityhoặc-Infinity:
`Infinity` `-Infinity` 
```js
console.log(1e500); // Infinity
console.log(-1e500); // -Infinity
```
`console.log(1e500); // Infinity
console.log(-1e500); // -Infinity` Đối với các số thực, một vấn đề thường xuyên xảy ra làsự sai số.
Một ví dụ kinh điển:

```js
console.log(0.1 + 0.2 === 0.3); // false
```
`console.log(0.1 + 0.2 === 0.3); // false` Kết quả làfalsevì thực tế0.1 + 0.2bằng số khác:
`false` `0.1 + 0.2` 
```js
console.log(0.1 + 0.2); // 0.30000000000000004
```
`console.log(0.1 + 0.2); // 0.30000000000000004` Hiểu đơn giản là: khibiểu diễn số thực dưới dạng nhị phântrong máy tính, không có cách nào để biểu diễn chính xác số0.1và0.2. Dẫn đến kết quả bị sai số như trên.
`0.1` `0.2` Ví dụ mình sử dụng phương thứctoFixed(20)để xem giá trị thực sự của các số thế nào:
`toFixed(20)` 
```js
console.log((0.1).toFixed(20)); // 0.10000000000000000555
console.log((0.2).toFixed(20)); // 0.20000000000000001110
```
`console.log((0.1).toFixed(20)); // 0.10000000000000000555
console.log((0.2).toFixed(20)); // 0.20000000000000001110` Rõ ràng là chúng không thực sự bằng0.1và0.2.
`0.1` `0.2` Để giải quyết vấn đề này, bạn có thể sử dụng phương phápnhân-rồi-chiahoặc phương thứctoFixed(1)như mình đã đề cập ở trên:
`toFixed(1)` 
```js
let a = 0.1;
let b = 0.2;

// Sử dụng nhân-rồi-chia
let sum1 = (a * 10 + b * 10) / 10;
console.log(sum1); // 0.3

// Sử dụng toFixed(1)
let sum2 = (a + b).toFixed(1);
console.log(sum2); // 0.3
```
`let a = 0.1;
let b = 0.2;

// Sử dụng nhân-rồi-chia
let sum1 = (a * 10 + b * 10) / 10;
console.log(sum1); // 0.3

// Sử dụng toFixed(1)
let sum2 = (a + b).toFixed(1);
console.log(sum2); // 0.3`"
314,Kiểu dữ liệu number trong Javascript,Kiểm tra số vớiisNaNvàisFinite,"`isNaN` `isFinite` Để kiểm tra number trong JavaScript, bạn có thể dùng một trong hai hàm là:isNaNhoặcisFinite.
`isNaN` `isFinite` ► HàmisNaN(value):
`isNaN(value)` Hàm này chuyển đổivaluethành dạng số rồi kiểm tra xem có bằngNaNhay không.
`value` `NaN` 
```js
console.log(isNaN(NaN)); // true
console.log(isNaN(1)); // false
console.log(isNaN(""1"")); // false - ""1"" chuyển sang số thành 1
console.log(isNaN(""abc"")); // true - ""abc"" không thể chuyển thành số
```
`console.log(isNaN(NaN)); // true
console.log(isNaN(1)); // false
console.log(isNaN(""1"")); // false - ""1"" chuyển sang số thành 1
console.log(isNaN(""abc"")); // true - ""abc"" không thể chuyển thành số` Vấn đề là hàmisNaNcó thật sự cần thiết hay không?
`isNaN` Câu trả lời làCÓ. Bởi vì giá trịNaNlà duy nhất.NaNkhông bằng bất kỳ giá trị nào khác:
`NaN` `NaN` 
```js
let a = NaN;
let b = NaN;

console.log(a === a); // false
console.log(a === b); // false
```
`let a = NaN;
let b = NaN;

console.log(a === a); // false
console.log(a === b); // false` Nghĩa là bạn không thể dùng toán tử so sánh bằng===để so sánh số vớiNaN.
`===` `NaN` ► HàmisFinite(value):
`isFinite(value)` Hàm này chuyển đổi giá trịvaluethành dạng số và trả vềtruenếu số đó khácInfinity,-InfinityvàNaN, ngược lại thì trả vềfalse.
`value` `true` `Infinity` `-Infinity` `NaN` `false` 
```js
console.log(isFinite(""1"")); // true - ""1"" chuyển thành 1
console.log(isFinite(""abc"")); // false - ""abc"" chuyển sang số thành NaN
console.log(isFinite(1e500)); // false - 1e500 bằng Infinity
```
`console.log(isFinite(""1"")); // true - ""1"" chuyển thành 1
console.log(isFinite(""abc"")); // false - ""abc"" chuyển sang số thành NaN
console.log(isFinite(1e500)); // false - 1e500 bằng Infinity` HàmisFinite(value)cũng thường dùng để kiểm tra một giá trị string có phải là số bình thường hay không.
`isFinite(value)` Ví dụ khi nhập vào một số vớihàmprompt:
`prompt` 
```js
let num = +prompt(""Nhập vào một số:"", """");

// trả về true
// trừ khi người dùng nhập vào Infinity, -Infinity hoặc không phải number
console.log(isFinite(num));
```
`let num = +prompt(""Nhập vào một số:"", """");

// trả về true
// trừ khi người dùng nhập vào Infinity, -Infinity hoặc không phải number
console.log(isFinite(num));` `0` `Object.is` `NaN` `Object.is(NaN,NaN)` `true` `0` `-0` `Object.is(0,-0)` `false` `0` `1` `0` `-0` `Object.is` `===`"
315,Kiểu dữ liệu number trong Javascript,HàmparseIntvà hàmparseFloat,"`parseInt` `parseFloat` Có thể bạn đã biết hai cách để chuyển đổi string thành dạng số là:
`Number()` `+` 
```js
console.log(Number(""1.23"")); // 1.23
console.log(+""1.23""); // 1.23
```
`console.log(Number(""1.23"")); // 1.23
console.log(+""1.23""); // 1.23` Tuy nhiên, nếu trong string chứa kí tự không phải dạng số thì kết quả làNaN:
`NaN` 
```js
console.log(Number(""100px"")); // NaN
console.log(+""100px""); // NaN
```
`console.log(Number(""100px"")); // NaN
console.log(+""100px""); // NaN` Thực tế, có một số trường hợp string chứacả số và đơn vịphía sau như100px,10rem,1.1em,... Làm sao để tách lấy phần số từ các string này?
`100px` `10rem` `1.1em` Trong JavaScript, bạn có thể sử dụng hai hàmparseIntvàparseFloat. Hai hàm này sẽ đọc string từ trái sang phải cho đến khi gặp kí tự không thỏa mãn thì dừng lại.
`parseInt` `parseFloat` `parseInt` `parseFloat` Một số ví dụ:

```js
console.log(parseInt(""100px"")); // 100
console.log(parseFloat(""1.1em"")); // 1.1

console.log(parseInt(""1.2"")); // 1
console.log(parseFloat(""1.2.3"")); // 1.2
```
`console.log(parseInt(""100px"")); // 100
console.log(parseFloat(""1.1em"")); // 1.1

console.log(parseInt(""1.2"")); // 1
console.log(parseFloat(""1.2.3"")); // 1.2` Nếu không thể tách được số nào thìparseIntvàparseFloattrả vềNaN:
`parseInt` `parseFloat` `NaN` 
```js
console.log(parseInt(""$100"")); // NaN
console.log(parseFloat(""$100"")); // NaN
```
`console.log(parseInt(""$100"")); // NaN
console.log(parseFloat(""$100"")); // NaN` HàmparseInt(value, radix)có tham số thứ hairadixbiểu diễn hệ cơ số (từ2đến36)
`parseInt(value, radix)` `radix` `2` `36` Ví dụ tách lấy số nguyên ở các hệ cơ số khác nhau:

```js
console.log(parseInt(""0xff"", 16)); // 255
console.log(parseInt(""ff"", 16)); // 255 - có thể bỏ qua phần tiền tố

console.log(parseInt(""kf12oi"", 36)); // 1234567890
console.log(parseInt(""100"", 2)); // 4
```
`console.log(parseInt(""0xff"", 16)); // 255
console.log(parseInt(""ff"", 16)); // 255 - có thể bỏ qua phần tiền tố

console.log(parseInt(""kf12oi"", 36)); // 1234567890
console.log(parseInt(""100"", 2)); // 4`"
316,Kiểu dữ liệu number trong Javascript,Một số hàm toán học,"Ngoài các phương thứcMath.floor,Math.ceil,Math.roundvàMath.truncđã trình bày ở trên, đối tượngMathcòn có các phương thức khác giúp bạn thực hiện một số hàm toán học.
`Math.floor` `Math.ceil` `Math.round` `Math.trunc` `Math` ►Math.random()
`Math.random()` Phương thức này trả về một giá trị ngẫu nhiên từ0đến1(không bao gồm1), ví dụ:
`0` `1` `1` 
```js
console.log(Math.random()); // 0.7097565480172887
console.log(Math.random()); // 0.6064789549780443
console.log(Math.random()); // 0.730830858416105
```
`console.log(Math.random()); // 0.7097565480172887
console.log(Math.random()); // 0.6064789549780443
console.log(Math.random()); // 0.730830858416105` ►Math.max(a, b, c,...)vàMath.min(a, b, c,...)
`Math.max(a, b, c,...)` `Math.min(a, b, c,...)` Hai phương thức này trả về giá trị lớn nhất (nhỏ nhất) từ một dãy số đầu vào.

```js
console.log(Math.max(1, 3.2, -1, 10, 4)); // 10
console.log(Math.min(1, 3.2, -1, 10, 4)); // -1
```
`console.log(Math.max(1, 3.2, -1, 10, 4)); // 10
console.log(Math.min(1, 3.2, -1, 10, 4)); // -1` ►Math.pow(n, base)
`Math.pow(n, base)` Trả về sốnmũbase.
`n` `base` 
```js
console.log(Math.pow(2, 3)); // 8 - vì bằng 2 mũ 3
```
`console.log(Math.pow(2, 3)); // 8 - vì bằng 2 mũ 3` Đối tượngMathcòn rất nhiều phương thức hữu ích khác. Bạn có thể tham khảo thêm tại bài viết:Math.
`Math`"
317,Kiểu dữ liệu number trong Javascript,Tổng kết,"Sau đây là một số kiến thức về number trong JavaScript.
Bạn có thể dùng kí tự_để ngăn cách các chữ số cho dễ nhìn. Ví dụ1_000_000_000tương đương1000000000.
`_` `1_000_000_000` `1000000000` Trường hợp có nhiều chữ số0đằng sau, bạn có thể dùng kí tựetheo sau là một sốNđể biểu diễn:
`0` `e` `N` `N` `eN` `2e6` `2000000` `N` `eN` `2e-6` `0.000002` JavaScript hỗ trợ biểu diễn số ở hệ cơ số khác:
`0x` `0o` `0b` Để chuyển một số sang string với hệ cơ số tương ứng, bạn dùngnum.toString(base), vớibaselà hệ cơ số có giá trị từ2đến36.
`num.toString(base)` `base` `2` `36` Để kiểm tra xem một số có phảiNaNhay không, bạn dùng hàmisNaN. HàmisNaN(value)chuyển giá trịvaluethành dạng số, rồi trả vềtruenếu số đó làNaN, ngược lại thì trả vềfalse.
`NaN` `isNaN` `isNaN(value)` `value` `true` `NaN` `false` Để kiểm tra xem một số có phải số thông thường hay không, bạn dùngisFinite. HàmisFinite(value)chuyển giá trịvaluethành dạng số, rồi trả vềtruenếu số đó khácInfinity,-InfinityvàNaN.
`isFinite` `isFinite(value)` `value` `true` `Infinity` `-Infinity` `NaN` Để chuyển đổi string thành dạng số, bạn có thể dùng hàmparseInthoặc hàmparseFloat. Cả hai hàm này đều đọc string từ trái sang phải cho đến khi gặp kí tự không thỏa mãn thì dừng lại:
`parseInt` `parseFloat` `parseInt` `parseFloat` Đối tượngMathcó các phương thức giúp bạn thực hiện các phép toán số học với number trong JavaScript như:
`Math` `Math.floor` `Math.ceil` `Math.round` `Math.trunc` `Math.random` `Math.max` `Math.min` `Math.pow`"
318,Kiểu dữ liệu number trong Javascript,Thực hành,"Viết code thực hiện yêu cầu sau:
`prompt` Xem đáp án

```js
// 1. Dùng hàm `prompt` yêu cầu người dùng nhập vào hai số.
let a = +prompt(""Nhập vào số thứ nhất:"", 0);
let b = +prompt(""Nhập vào số thứ hai:"", 0);

// 2. Tính và hiển thị tổng hai số.
console.log(a + b);
```
`// 1. Dùng hàm `prompt` yêu cầu người dùng nhập vào hai số.
let a = +prompt(""Nhập vào số thứ nhất:"", 0);
let b = +prompt(""Nhập vào số thứ hai:"", 0);

// 2. Tính và hiển thị tổng hai số.
console.log(a + b);` Viết hàmreadNumberthực hiện yêu cầu sau:
`readNumber` `prompt` Xem đáp án

```js
// định nghĩa hàm
function readNumber() {
  while (true) {
    // yêu cầu người dùng nhập vào số
    let n = prompt(""Nhập vào số:"", 0);

    // kiểm tra điều kiện không phải số bình thường
    if (n === """" || n === null || n === undefined || !isFinite(n)) {
      continue;
    }

    return +n;
  }
}

// gọi hàm
let n = readNumber();
console.log(n);
```
`// định nghĩa hàm
function readNumber() {
  while (true) {
    // yêu cầu người dùng nhập vào số
    let n = prompt(""Nhập vào số:"", 0);

    // kiểm tra điều kiện không phải số bình thường
    if (n === """" || n === null || n === undefined || !isFinite(n)) {
      continue;
    }

    return +n;
  }
}

// gọi hàm
let n = readNumber();
console.log(n);`"
319,Kiểu dữ liệu string trong Javascript,Giới thiệu,"Kiểu dữ liệu string trong JavaScript dùng đểlưu trữ giá trị dạng text. Và không có kiểu dữ liệu đặc biệt nào cho một ký tự.
Cóba loại kí tựdùng để biểu diễn string trong JavaScript là: dấu nháy đơn, dấu nháy kép và dấu ""backtick"", ví dụ:

```js
let singleQuote = ""hello"";
let doubleQuote = ""hello"";
let backticks = `hello`;
```
`let singleQuote = ""hello"";
let doubleQuote = ""hello"";
let backticks = `hello`;` Trong đó, dấu nháy đơn và dấu nháy képhoàn toàn tương đương. Còn dấu ""backtick"" thì khác hơn. Dấu ""backtick"" cho phép bạn viết biểu thức hoặc gọi hàm bên trong${...}, ví dụ:
`${...}` 
```js
function add(a, b) {
  return a + b;
}

console.log(`Sum of 1 and 2 is ${add(1, 2)}`); // 3
```
`function add(a, b) {
  return a + b;
}

console.log(`Sum of 1 and 2 is ${add(1, 2)}`); // 3` Ứng dụng khác của dấu ""backtick"" là cho phép bạn viết string trên nhiều dòng:

```js
let userList = `Users:
    + Alex
    + John
    + Anna
    `;

console.log(userList);
```
`let userList = `Users:
    + Alex
    + John
    + Anna
    `;

console.log(userList);` Nếu viết string trên nhiều dòng vớidấu nháy đơn hoặc dấu nháy képtheo cách tương tự thì bạn sẽ bị lỗi:

```js
let userList = ""Users:
    + Alex
    + John
    + Anna
    "";

    // Uncaught SyntaxError: Invalid or unexpected token
```
`let userList = ""Users:
    + Alex
    + John
    + Anna
    "";

    // Uncaught SyntaxError: Invalid or unexpected token`"
320,Kiểu dữ liệu string trong Javascript,Biểu diễn kí tự đặc biệt,"Thực tế, bạn vẫn có thể biểu diễn string trên nhiều dòng vớidấu nháy đơn hoặc dấu nháy képbằng cách sử dụng kí tựnewline\n:
`\n` 
```js
let userList = ""Users: \n+ Alex \n+ John \n+ Anna"";

console.log(userList);

/*
    Users:
    + Alex
    + John
    + Anna
    */
```
`let userList = ""Users: \n+ Alex \n+ John \n+ Anna"";

console.log(userList);

/*
    Users:
    + Alex
    + John
    + Anna
    */` Kí tự\nlà một kí tự đặc biệt, có nghĩa lànewline(dòng mới).
`\n` Sau đây là tổng hợp một số kí tự đặc biệt:
`\n` `\r` `\r\n` `\n` `\'` `\""` `\\` `\t` `\xXX` `XX` `\x7A` `z` `\uXXXX` `XXXX` `\u00A9` `©` `\u{X..XXX}` `X..XXX` Một vài ví dụ với unicode:

```js
console.log(""\u00A9""); // ©
console.log(""\u{20331}""); // 佫
console.log(""\u{1F60D}""); // 😍
```
`console.log(""\u00A9""); // ©
console.log(""\u{20331}""); // 佫
console.log(""\u{1F60D}""); // 😍` Tất cả các kí tự đặc biệt đều bắt đầu bằng kí tự\.
`\` Ví dụ sử dụng dấu nháy đơn trong string:

```js
console.log(""I'm a js dev""); // I'm a js dev
```
`console.log(""I'm a js dev""); // I'm a js dev` Dĩ nhiên, bạn có thểkết hợpcác dấu nháy với nhau để tránh sử dụng kí tự\:
`\` 
```js
console.log(""I'm a js dev""); // I'm a js dev
```
`console.log(""I'm a js dev""); // I'm a js dev` Với cách viết này, string trở nên rõ ràng và trực quan hơn rất nhiều."
321,Kiểu dữ liệu string trong Javascript,Độ dài string trong JavaScript,"Để lấy độ dài của string trong JavaScript, bạn sử dụng thuộc tínhlength:
`length` 
```js
console.log(`Me\n`.length); // 3
```
`console.log(`Me\n`.length); // 3` Kí tự\nlà kí tự đặc biệt. Nên stringMe\nchỉ có độ dài bằng 3, chứ không phải bằng 4.lengthlà thuộc tính chứ không phải phương thức. Vì vậy, nếu bạn gọi""str"".length()thì sẽ bị lỗi""str "".length is not a function.
`\n` `Me\n` `length` `""str"".length()`"
322,Kiểu dữ liệu string trong Javascript,Truy cập các kí tự của string trong JavaScript,"Để lấy giá trị của kí tự ở vị trípositiontrong string, bạn có thể dùngstr[position]hoặcstr.charAt(position)(vị trí bắt đầu là0):
`position` `str[position]` `str.charAt(position)` `0` 
```js
let str = ""hello"";

// Lấy kí tự đầu tiên
console.log(str[0]); // h

// Lấy kí tự cuối cùng
console.log(str[str.length - 1]); // o
```
`let str = ""hello"";

// Lấy kí tự đầu tiên
console.log(str[0]); // h

// Lấy kí tự cuối cùng
console.log(str[str.length - 1]); // o` Cách sử dụng[]là cách mới, trong khi cách dùngcharAtlà một cách cũ.
`[]` `charAt` Điểm khác nhau giữa hai cách này là: nếu không tìm thấy vị trípositionthì[position]trả vềundefined, còncharAt(position)trả về string rỗng.
`position` `[position]` `undefined` `charAt(position)` 
```js
let str = ""hello"";

console.log(str[1000]); // undefined
console.log(str.charAt(1000)); // """"
```
`let str = ""hello"";

console.log(str[1000]); // undefined
console.log(str.charAt(1000)); // """"` Để duyệt hết các kí tự trong string, bạn có thể dùngvòng lặp for bình thường:

```js
let str = ""hello"";

for (let i = 0; i < str.length; i++) {
  console.log(str[i]);
}
```
`let str = ""hello"";

for (let i = 0; i < str.length; i++) {
  console.log(str[i]);
}` Kết quả:

```js
h
e
l
l
o
```
`h
e
l
l
o` Hoặc sử dụng vòng lặpfor...ofđể ngắn gọn hơn:
`for...of` 
```js
let str = ""hello"";

for (let c of str) {
  console.log(c);
}
```
`let str = ""hello"";

for (let c of str) {
  console.log(c);
}`"
323,Kiểu dữ liệu string trong Javascript,String trong JavaScript là bất biến,"String trong JavaScript làbất biếnvì bạn không thể thay đổi kí tự trong string.

```js
let str = ""hello"";
str[0] = ""H"";
console.log(str); // hello - string không thay đổi
```
`let str = ""hello"";
str[0] = ""H"";
console.log(str); // hello - string không thay đổi` Để giải quyết vấn đề này, bạnbắt buộc phải tạo một string mới.
Sau đây, mình sẽ tìm hiểu kỹ hơn về bài toán này."
324,Kiểu dữ liệu string trong Javascript,Thay đổi chữ hoa và thường,"Có một sốphương thứcgiúp thay đổi chữ hoa và chữ thường của string trong JavaScript.
Phương thứctoLowerCase()trả về string mới vớitất cả các kí tự đều viết thường:
`toLowerCase()` 
```js
console.log(""Hello"".toLowerCase()); // hello
```
`console.log(""Hello"".toLowerCase()); // hello` Phương thứctoUpperCase()trả về string mới vớitất cả các kí tự đều viết hoa:
`toUpperCase()` 
```js
console.log(""Hello"".toUpperCase()); // HELLO
```
`console.log(""Hello"".toUpperCase()); // HELLO`"
325,Kiểu dữ liệu string trong Javascript,Tìm kiếm substring,"Có nhiều cách để tìm kiếm substring (string con) trong một string.
► Phương thứcstr.indexOf(substr, pos):
`str.indexOf(substr, pos)` Phương thức này tìm kiếmsubstrbên trong stringstrbắt đầu từ vị trípos. Kết quả trả về là vị trí của substring (vị trí kí tự đầu tiên) nếu tìm thấy, ngược lại thì trả về -1, ví dụ:
`substr` `str` `pos` 
```js
let str = ""I am a js dev"";

console.log(str.indexOf(""js"")); // 7
console.log(str.indexOf(""JS"")); // -1 vì không tìm thấy
console.log(str.indexOf(""a"")); // 2 - vị trí đầu tiên tìm thấy
```
`let str = ""I am a js dev"";

console.log(str.indexOf(""js"")); // 7
console.log(str.indexOf(""JS"")); // -1 vì không tìm thấy
console.log(str.indexOf(""a"")); // 2 - vị trí đầu tiên tìm thấy` Tham số thứ haiposcho phép bạn xác định vị trí bắt đầu tìm kiếm:
`pos` 
```js
let str = ""I am a js dev"";
console.log(str.indexOf(""a"", 3)); // 5 - vị trí đầu tiên tìm thấy bắt đầu từ 3
```
`let str = ""I am a js dev"";
console.log(str.indexOf(""a"", 3)); // 5 - vị trí đầu tiên tìm thấy bắt đầu từ 3` Nếu bạn muốntìm tất cả vị trí của substring, bạn có thể sử dụng vòng lặp. Khi tìm thấy một vị trí, bạn lưu lại ví trí đó để sử dụng cho lần lặp tiếp theo. Cho đến khi kết quả là-1thì dừng lại.
`-1` 
```js
let str = ""I am a js dev"";
let target = ""a"";

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos === -1) break;

  console.log(""found pos:"", foundPos);
  pos = foundPos + 1;
}
```
`let str = ""I am a js dev"";
let target = ""a"";

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos === -1) break;

  console.log(""found pos:"", foundPos);
  pos = foundPos + 1;
}` ► Phương thứcstr.lastIndexOf(substr, pos)
`str.lastIndexOf(substr, pos)` Tương tự như phương thứcstr.indexOf(substr, pos)nhưng thực hiệntìm kiếm từ cuối lên đầu, ví dụ:
`str.indexOf(substr, pos)` 
```js
let str = ""I am a js dev"";
console.log(str.lastIndexOf(""a"")); // 5 - vị trí đầu tiên tìm thấy tính từ cuối
```
`let str = ""I am a js dev"";
console.log(str.lastIndexOf(""a"")); // 5 - vị trí đầu tiên tìm thấy tính từ cuối` ► Phương thứcstr.includes(substr, pos)
`str.includes(substr, pos)` Phương thức này cũng tìmsubstrtrongstr, nhưng thay vì trả về vị trí thì phương thức này trả vềtruenếu tìm thấy và trả vềfalsenếu không tìm thấy.
`substr` `str` `true` `false` Phương thức này đặc biệt hữu ích khi bạn cần kiểm tra tính tồn tại của substring mà không quan tâm vị trí:

```js
let str = ""I am a js dev"";
console.log(str.includes(""js"")); // true
console.log(str.includes(""JS"")); // false
```
`let str = ""I am a js dev"";
console.log(str.includes(""js"")); // true
console.log(str.includes(""JS"")); // false` Tham số thứ haiposcho phép bạn kiểm tra tính tồn tại bắt đầu từ vị trípos:
`pos` `pos` 
```js
let str = ""I am a js dev"";
console.log(str.includes(""js"", 1)); // true
console.log(str.includes(""js"", 9)); // false
```
`let str = ""I am a js dev"";
console.log(str.includes(""js"", 1)); // true
console.log(str.includes(""js"", 9)); // false` ► Phương thứcstr.startsWith(substr)
`str.startsWith(substr)` Trả vềtruenếustrbắt đầubằngsubstr, ngược lại trả vềfalse.
`true` `str` `substr` `false` 
```js
let str = ""I am a js dev"";
console.log(str.startsWith(""I am"")); // true
console.log(str.startsWith(""js"")); // false
```
`let str = ""I am a js dev"";
console.log(str.startsWith(""I am"")); // true
console.log(str.startsWith(""js"")); // false` ► Phương thứcstr.endsWith(substr)
`str.endsWith(substr)` Trả vềtruenếustrkết thúcbằngsubstr, ngược lại trả vềfalse.
`true` `str` `substr` `false` 
```js
let str = ""I am a js dev"";
console.log(str.endsWith(""I am"")); // false
console.log(str.endsWith(""dev"")); // true
```
`let str = ""I am a js dev"";
console.log(str.endsWith(""I am"")); // false
console.log(str.endsWith(""dev"")); // true`"
326,Kiểu dữ liệu string trong Javascript,Lấy giá trị substring trong string,"Cóba phương thứcđể lấy giá trị substring của string trong JavaScript.
► Phương thứcstr.slice(start [, end])
`str.slice(start [, end])` Trả về substring bắt đầu từ vị trístartđến vị tríend(không bao gồm vị tríendvàstartluôn phải nhỏ hơnend), ví dụ:
`start` `end` `end` `start` `end` 
```js
let str = ""I am a js dev"";
console.log(str.slice(2, 4)); // am
```
`let str = ""I am a js dev"";
console.log(str.slice(2, 4)); // am` Nếu không truyền vào giá trịendthì phương thức này sẽ lấy đến cuối string:
`end` 
```js
let str = ""I am a js dev"";
console.log(str.slice(2)); // am a js dev
```
`let str = ""I am a js dev"";
console.log(str.slice(2)); // am a js dev` Trường hợp giá trị củastartvàendlà số âm thì vị trí được đếm từ cuối lên đầu (vị trí cuối cùng ứng với-1):
`start` `end` `-1` 
```js
let str = ""I am a js dev"";
console.log(str.slice(-3, -1)); // de
```
`let str = ""I am a js dev"";
console.log(str.slice(-3, -1)); // de` ► Phương thứcstr.substring(start [, end])
`str.substring(start [, end])` Trả về substring trong string giữa vị trístartvà vị tríend(không bao gồm vị tríend).
`start` `end` `end` Phương thức này gần giống phương thứcstr.slice(start, [, end])chỉ khác ở chỗ là: phương thứcsubstringcho phépstartcó thể lớn hơnendvàsubstringkhông áp dụng được cho trường hợpstart,endcó giá trị âm, ví dụ:
`str.slice(start, [, end])` `substring` `start` `end` `substring` `start` `end` 
```js
let str = ""I am a js dev"";

// trường hợp bình thường
console.log(str.substring(2, 4)); // am

// trường hợp không có end
console.log(str.substring(2)); // am a js dev

// trường hợp start lớn hơn end
console.log(str.substring(4, 2)); // am
```
`let str = ""I am a js dev"";

// trường hợp bình thường
console.log(str.substring(2, 4)); // am

// trường hợp không có end
console.log(str.substring(2)); // am a js dev

// trường hợp start lớn hơn end
console.log(str.substring(4, 2)); // am` ► Phương thứcstr.substr(start [, length])
`str.substr(start [, length])` Trả về substring bắt đầu từ vị trístartvà lấy số kí tự làlength.
`start` `length` 
```js
let str = ""I am a js dev"";
console.log(str.substr(2, 2)); // am - bắt đầu từ vị trí 2, lấy 2 kí tự
```
`let str = ""I am a js dev"";
console.log(str.substr(2, 2)); // am - bắt đầu từ vị trí 2, lấy 2 kí tự` Trường hợp không có giá trịlengththì trả về đến string:
`length` 
```js
let str = ""I am a js dev"";
console.log(str.substr(2)); // am a js dev - trả về đến hết string
```
`let str = ""I am a js dev"";
console.log(str.substr(2)); // am a js dev - trả về đến hết string` Nếu giá trịstartlà âm, thì việc lấy substring được tính từ cuối (vị trí kí tự cuối cùng là-1):
`start` `-1` 
```js
let str = ""I am a js dev"";
console.log(str.substr(-2, 2)); // ev
```
`let str = ""I am a js dev"";
console.log(str.substr(-2, 2)); // ev` `slice` `substr`"
327,Kiểu dữ liệu string trong Javascript,So sánh string trong JavaScript,"So sánh string thực hiện so sánh từng kí tự từ trái sang phải. Và khi so sánh string, bạn thấy rằngkí tự viết thườnglớn hơnkí tự viết hoa, ví dụ:

```js
console.log(""a"" > ""A""); // true
```
`console.log(""a"" > ""A""); // true` Tại sao lại như vậy?
Vì string trong JavaScript được encode bằng UTF-16. Nghĩa là mỗi kí tự tương ứng với một số.
Sau đây là những phương thức giúp bạn chuyển đổi string sang số unicode và ngược lại.
► Phương thứcstr.codePointAt(pos)
`str.codePointAt(pos)` Trả về mã code (số) tương ứng với kí tự tại vị trípos, ví dụ:
`pos` 
```js
console.log(""a"".codePointAt(0)); // 97
console.log(""A"".codePointAt(0)); // 65
```
`console.log(""a"".codePointAt(0)); // 97
console.log(""A"".codePointAt(0)); // 65` Bạn thấy rằng mã code ứng với""a""(bằng97) lớn hơn của""A""(bằng 65).
`""a""` `97` `""A""` ► Phương thứcString.fromCodePoint(code)
`String.fromCodePoint(code)` Trả về kí tự ứng với mã code, ví dụ:

```js
console.log(String.fromCodePoint(97)); // a
console.log(String.fromCodePoint(65)); // A
```
`console.log(String.fromCodePoint(97)); // a
console.log(String.fromCodePoint(65)); // A` Bạn cũng có thể sử dụng mã Unicode bằng cách thêm kí tự\utrước mã hexa:
`\u` 
```js
console.log(""\u0061""); // a - mã hexa của a là 61
console.log(""\u0041""); // A - mã hexa của A là 41
```
`console.log(""\u0061""); // a - mã hexa của a là 61
console.log(""\u0041""); // A - mã hexa của A là 41` Thực tế, việc so sánh string phức tạp hơn nhiều vì nó còn phụ thuộc vào ngôn ngữ vùng miền.
Ví dụ so sánh tiếng việt:

```js
let str1 = ""Hải Dương"";
let str2 = ""Hòa Bình"";

console.log(str1 > str2); // true
```
`let str1 = ""Hải Dương"";
let str2 = ""Hòa Bình"";

console.log(str1 > str2); // true` Theo ví dụ trên, kết quảstr1 > str2bằngtrue. Nghĩa làstr1lớn hơnstr2.
`str1 > str2` `true` `str1` `str2` Nhưng theo thực tế khi sắp xếp Tiếng Việt, chữ cáiabao giờ cũng đứng trước chữ cáio. Nói cách khácHải Dươngphải nhỏ hơnHòa Bình.
`a` `o` Để giải quyết vấn đề này, bạn có thể dùng phương thứclocaleCompare.
`localeCompare` Đối vớistr1.localeCompare(str2), có ba trường hợp xảy ra là:
`str1.localeCompare(str2)` `0` `str1` `str2` `0` `str1` `str2` `0` `str1` `str2` Áp dụnglocaleComparevới ví dụ trên:
`localeCompare` 
```js
let str1 = ""Hải Dương"";
let str2 = ""Hòa Bình"";

console.log(str1.localeCompare(str2)); // -1
```
`let str1 = ""Hải Dương"";
let str2 = ""Hòa Bình"";

console.log(str1.localeCompare(str2)); // -1` Kết quả là-1(nhỏ hơn0). Nói cách khác,str1nhỏ hơnstr2.
`-1` `0` `str1` `str2`"
328,Kiểu dữ liệu string trong Javascript,Tổng kết,"Sau đây là những kiến thức cơ bản về string trong JavaScript:

```js
""hello""; // nháy đơn
""hello""; // nháy kép
`hello`; // backtick
```
`""hello""; // nháy đơn
""hello""; // nháy kép
`hello`; // backtick` `\` `pos` `str[pos]` `str.charAt(pos)` `str.toLowerCase` `str.toUpperCase` `slice` `substring` `indexOf` `includes` `startsWith` `endsWith` `localeCompare` Ngoài ra, string còn nhiều phương thức khác nữa. Bạn có thể tham khảo thêm tại:"
329,Kiểu dữ liệu string trong Javascript,Thực hành,"Viết hàmupperFirst(str)nhận vào tham số là stringstrvà trả về string mới với kí tự đầu tiên được viết hoa, ví dụ:
`upperFirst(str)` `str` 
```js
let s = upperFirst(""hello"");
console.log(s); // Hello
```
`let s = upperFirst(""hello"");
console.log(s); // Hello` Xem đáp án

```js
// định nghĩa hàm
function upperFirst(str) {
  // nếu tham số truyền vào là empty thì trả về chính nó
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

let s = upperFirst(""hello"");
console.log(s); // Hello
```
`// định nghĩa hàm
function upperFirst(str) {
  // nếu tham số truyền vào là empty thì trả về chính nó
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

let s = upperFirst(""hello"");
console.log(s); // Hello` Viết hàmextractMoney(value)nhận vàovaluelà string biểu diễn tiền với đơn vị đô la$ở đầu (ví dụ""$1000"") và trả về số tiền (ví dụ1000).
`extractMoney(value)` `value` `$` `""$1000""` `1000` Xem đáp án

```js
// định nghĩa hàm
function extractMoney(str) {
  if (!str) return 0;

  return +str.slice(1);
}

let money = extractMoney(""$1000"");
console.log(money); // 1000
```
`// định nghĩa hàm
function extractMoney(str) {
  if (!str) return 0;

  return +str.slice(1);
}

let money = extractMoney(""$1000"");
console.log(money); // 1000`"
330,Local storage thay cho Index DB,Giới thiệu,"IndexedDBlà một local database dạng NoSQL cho phép lưu trữ dữ liệu ngay trên trình duyệt. Nó cho phép lưu trữ một lượng dữ liệu lớn với các kiểu dữ liệu khác nhau (bao gồm cả file/blob); hỗ trợ trên nhiều trình duyệt và cung cấp khả năng truy cập nhanh. Qua đó, IndexedDB giúp cho web app có khả năng hoạt động offline một cách mượt mà.
Tuy nhiên, IndexedDB lại có nhược điểm lớn là nó chỉ cung cấp API cấp thấp. Khi sử dụng IndexedDB bạn phải quan tâm đến những thứ như: transaction, objectStore, cursor,... và nó còn không hỗ trợPromise. Điều này làm cho việc sử dụng IndexedDB trở nên khá khó khăn và phức tạp.
May mắn thay,localForageđã ra đời và giúp cho việc sử dụng IndexedDB trở nên đơn giản hơn rất nhiều."
331,Local storage thay cho Index DB,LocalForage là gì?,"LocalForage là một thư viện JavaScript mã nguồn mở, giúp cho việc giao tiếp với database trên trình duyệt (đặc biệt là IndexedDB) trở nên đơn giản hơn và tiện lợi hơn với những đặc điểm:"
332,Local storage thay cho Index DB,Cài đặt,"Việc cài đặt localForage khá đơn giản. Bạn có thể sử dụng thông qua CDN và chèn thẳng vào HTML như sau:

```js
<script src=""https://unpkg.com/localforage@1.7.3/dist/localforage.min.js""></script>
```
`<script src=""https://unpkg.com/localforage@1.7.3/dist/localforage.min.js""></script>` Hoặc tảiphiên bản release mới nhấttrên Github về rồi sử dụng luôn:

```js
<script src=""localforage.js""></script>
<script>
  console.log(""localforage is: "", localforage);
</script>
```
`<script src=""localforage.js""></script>
<script>
  console.log(""localforage is: "", localforage);
</script>` mà không cần phảiinithay chờ các sự kiện nhưonready.
Ngoài ra, bạn cũng có thể cài đặt localForage thông qua npm hoặc bower như sau:

```js
# Cài đặt qua npm:
npm install localforage

# Hoặc cài đặt qua bower:
bower install localforage
```
`# Cài đặt qua npm:
npm install localforage

# Hoặc cài đặt qua bower:
bower install localforage` Và sử dụng nó với các bundler (như Webpack) bằng cách:

```js
import localforage from ""localforage"";
localforage.setItem(""key"", ""value"");
```
`import localforage from ""localforage"";
localforage.setItem(""key"", ""value"");`"
333,Local storage thay cho Index DB,Cách sử dụng một số API của localForage,"Như mình đã nói ở trên, vớilocalForagebạn không cần phải cài đặt, init database nên có thể ghi dữ liệu ngay lập tức với phương thứcsetItem().
`localForage` Cú pháp:

```js
// Sử dụng callback
localforage.setItem(key, value, successCallback);

// Hoặc sử dụng promise
localforage
  .setItem(key, value)
  .then(function (value) {
    // Xử lý khi việc lưu key-value thành công
    console.log(value);
  })
  .catch(function (err) {
    // Xử lý khi việc lưu key-value bị lỗi
    console.log(err);
  });
```
`// Sử dụng callback
localforage.setItem(key, value, successCallback);

// Hoặc sử dụng promise
localforage
  .setItem(key, value)
  .then(function (value) {
    // Xử lý khi việc lưu key-value thành công
    console.log(value);
  })
  .catch(function (err) {
    // Xử lý khi việc lưu key-value bị lỗi
    console.log(err);
  });` Trong đó:
Ví dụ:

```js
localforage
  .setItem(""my point"", { x: 1, y: 2 })
  .then(function (value) {
    console.log(value);
    // => {x: 1, y: 2}
  })
  .catch(function (err) {
    console.log(err);
  });
```
`localforage
  .setItem(""my point"", { x: 1, y: 2 })
  .then(function (value) {
    console.log(value);
    // => {x: 1, y: 2}
  })
  .catch(function (err) {
    console.log(err);
  });` Lưu ý
Nếu bạn sử dụngsetItem()lại một lần nữa với key đã tồn tại thì giá trị của nó sẽ bị ghi đè.
Sau khi sử dụngsetItem()để ghi dữ liệu, bạn có thể dùnggetItem()để lấy dữ liệu ra, với cú pháp như sau:

```js
// Sử dụng callback
localforage.getItem(key, successCallback);

// Hoặc sử dụng promise
localforage
  .getItem(key)
  .then(function (value) {
    // Xử lý khi việc lấy giá trị với key thành công
    console.log(value);
  })
  .catch(function (err) {
    // Xử lý khi việc lấy giá trị với key bị lỗi
    console.log(err);
  });
```
`// Sử dụng callback
localforage.getItem(key, successCallback);

// Hoặc sử dụng promise
localforage
  .getItem(key)
  .then(function (value) {
    // Xử lý khi việc lấy giá trị với key thành công
    console.log(value);
  })
  .catch(function (err) {
    // Xử lý khi việc lấy giá trị với key bị lỗi
    console.log(err);
  });` Ví dụ:

```js
localforage
  .getItem(""my point"")
  .then(function (value) {
    console.log(value.x, value.y);
    // => 1 2
  })
  .catch(function (err) {
    console.log(err);
  });
```
`localforage
  .getItem(""my point"")
  .then(function (value) {
    console.log(value.x, value.y);
    // => 1 2
  })
  .catch(function (err) {
    console.log(err);
  });` Lưu ý
Nếu bạn sử dụnggetItem()với key chưa tồn tại thì promise vẫn trả về trường hợp thành công, nhưng lúc này giá trị của value lànull.

```js
localforage
  .getItem(""her point"")
  .then(function (value) {
    console.log(value);
    // => null
  })
  .catch(function (err) {
    console.log(err);
  });
```
`localforage
  .getItem(""her point"")
  .then(function (value) {
    console.log(value);
    // => null
  })
  .catch(function (err) {
    console.log(err);
  });` Phương thức này dùng để loại bỏ cặp key-value ra khỏi database.
Cú pháp:

```js
// Sử dụng callback
localforage.removeItem(key, successCallback);

// Hoặc sử dụng promise
localforage
  .removeItem(key)
  .then(function () {
    // Xử lý khi việc remove thành công
    console.log(""Key is cleared!"");
  })
  .catch(function (err) {
    // Xử lý khi việc remove bị lỗi
    console.log(err);
  });
```
`// Sử dụng callback
localforage.removeItem(key, successCallback);

// Hoặc sử dụng promise
localforage
  .removeItem(key)
  .then(function () {
    // Xử lý khi việc remove thành công
    console.log(""Key is cleared!"");
  })
  .catch(function (err) {
    // Xử lý khi việc remove bị lỗi
    console.log(err);
  });` Ví dụ:

```js
localforage
  .removeItem(""my point"")
  .then(function () {
    console.log(""Key is cleared!"");
    // => Key is cleared!
  })
  .catch(function (err) {
    console.log(err);
  });
```
`localforage
  .removeItem(""my point"")
  .then(function () {
    console.log(""Key is cleared!"");
    // => Key is cleared!
  })
  .catch(function (err) {
    console.log(err);
  });` Lưu ý
Nếu bạnremoveItem()với key không tồn tại, thì phương thức này vẫn coi như thành công.

```js
localforage
  .removeItem(""her point"")
  .then(function () {
    console.log(""Key is cleared!"");
    // => Key is cleared!
  })
  .catch(function (err) {
    console.log(err);
  });
```
`localforage
  .removeItem(""her point"")
  .then(function () {
    console.log(""Key is cleared!"");
    // => Key is cleared!
  })
  .catch(function (err) {
    console.log(err);
  });` Phương thứcclear()sẽ xoá bỏ toàn bộ cặp key-value tồn tại trong database.
Cú pháp:

```js
// Sử dụng callback
localforage.clear(successCallback);

// Hoặc sử dụng promise
localforage
  .clear()
  .then(function () {
    // Xử lý khi xoá database thành công
    console.log(""Database is now empty."");
  })
  .catch(function (err) {
    // Xử lý khi việc xoá bị lỗi.
    console.log(err);
  });
```
`// Sử dụng callback
localforage.clear(successCallback);

// Hoặc sử dụng promise
localforage
  .clear()
  .then(function () {
    // Xử lý khi xoá database thành công
    console.log(""Database is now empty."");
  })
  .catch(function (err) {
    // Xử lý khi việc xoá bị lỗi.
    console.log(err);
  });` Lưu ý
Khi sử dụng phương thức này đồng nghĩa với toàn bộ dữ liệu trong database sẽ bị xoá. Vì vậy, bạn cần phải cẩn trọng khi sử dụng phương thức này.
Ngoài 4 API giống với localStorage như trên ra, localForage còn hỗ trợ một số API khác như:
`length(successCallback)` `keys(successCallback)` `iterate(iteratorCallback, successCallback)`"
334,Local storage thay cho Index DB,Cấu hình localForage,"Mặc dù, bạn không cần phải cài đặt gì vẫn có thể sử dụng localForage (như trên). Tuy nhiên, localForage cũng hỗ trợ bạn cấu hình những thông tin quan trọng cho nó.
Phương thức này dùng để xác định loại storage sẽ được sử dụng cho localForage.
Mặc định, nếu sử dụng như trên mà không dùngsetDriver()thì localForage sẽ sử dụng các loại storage mặc định theo thứ tự là:IndexedDB,WebSQL,localStorage. Nghĩa là localForage sẽ ưu tiên dùng IndexedDB trước; nếu trình duyệt không hỗ trợ thì chuyển sang dùng WebSQL; nếu trình duyệt cũng không hỗ trợ WebSQL nữa thì chuyển sang dùng localStorage.
Cú pháp của phương thức này là:

```js
setDriver(driverName);

// Hoặc
setDriver([driverName, nextDriverName]);
```
`setDriver(driverName);

// Hoặc
setDriver([driverName, nextDriverName]);` Trong đó, các tham số của phương thức nhận một trong 3 giá trị là:
Ví dụ:

```js
// Yêu cầu localForage sử dụng localStorage
localforage.setDriver(localforage.LOCALSTORAGE);

// Yêu cầu localForage ưu tiên sử dụng WebSQL rồi mới đến IndexedDB
localforage.setDriver([localforage.WEBSQL, localforage.INDEXEDDB]);
```
`// Yêu cầu localForage sử dụng localStorage
localforage.setDriver(localforage.LOCALSTORAGE);

// Yêu cầu localForage ưu tiên sử dụng WebSQL rồi mới đến IndexedDB
localforage.setDriver([localforage.WEBSQL, localforage.INDEXEDDB]);` Phương thức này dùng để cài đặt một số thông tin như:driver, name, size, storeName, version, description.
Cú pháp:

```js
localforage.config({
  driver,
  name,
  size,
  storeName,
  version,
  description,
});
```
`localforage.config({
  driver,
  name,
  size,
  storeName,
  version,
  description,
});` Chú ý:khác với hầu hết các API của localForage - là bất đồng bộ, thì phương thứcconfig()lại xử lý đồng bộ."
335,Local storage thay cho Index DB,Sử dụng nhiều database,"Mặc định như trên, localForage sẽ lưu dữ liệu ở một nơi gọi làglobal store(toàn cục). Tuy nhiên, nhiều khi bạn muốn lưu trữ dữ liệu thành nhiều store khác nhau để quản lý cho dễ, lúc này bạn có thể sử dụng phương thứccreateInstance().
Ví dụ mình tạo ra 2 instance của localForage để lưu trữ toạ độ điểm ở không gian 2 chiều và 3 chiều:

```js
let twoDStore = localforage.createInstance({
  name: ""2-D"",
});

let threeDStore = localforage.createInstance({
  name: ""3-D"",
});
```
`let twoDStore = localforage.createInstance({
  name: ""2-D"",
});

let threeDStore = localforage.createInstance({
  name: ""3-D"",
});` Khi đó dữ liệu ở mỗi instance sẽ không liên quan đến nhau (kể cả khi chúng có cùng key):

```js
twoDStore.setItem(""a"", { x: 1, y: 2 });
threeDStore.setItem(""a"", { x: 1, y: 2, z: 3 });

twoDStore.getItem(""a"").then((value) => {
  console.log(value);
  // => {x: 1, y: 2}
});

threeDStore.getItem(""a"").then((value) => {
  console.log(value);
  // => {x: 1, y: 2, z: 3}
});
```
`twoDStore.setItem(""a"", { x: 1, y: 2 });
threeDStore.setItem(""a"", { x: 1, y: 2, z: 3 });

twoDStore.getItem(""a"").then((value) => {
  console.log(value);
  // => {x: 1, y: 2}
});

threeDStore.getItem(""a"").then((value) => {
  console.log(value);
  // => {x: 1, y: 2, z: 3}
});`"
336,Local storage thay cho Index DB,Lời kết,"Trên đây là những kiến thức cơ bản về localForage. Theo mình, đây là một trong những công cụ tốt nhất để quản lý dữ liệu database phía client.
Còn theo bạn, việc sử dụng localForage là dễ hay khó? Và bạn thường sử dụng công cụ nào để quản lý database phía trình duyệt? Để lại bình luận phía dưới để chia sẻ ý kiến của mình nhé!
Để xem thêm các API khác của localForage, bạn có thể xem thêm tại:"
337,Mảng array trong Javascript,Giới thiệu,"Array trong JavaScript cũng là một loạiobject. Nhưng array khác object bình thường ở chỗ là:
Sau đây, mình sẽ tìm hiểu chi tiết về array trong JavaScript."
338,Mảng array trong Javascript,Khởi tạo array trong JavaScript,"Cóhai cáchđể khởi tạo array rỗng là:
`[]` `new Array()` 
```js
let a1 = [];
let a2 = new Array();
```
`let a1 = [];
let a2 = new Array();` Trong đó, cú pháp sử dụng[]là phổ biển hơn cả vì cách nàynhanh và ngắn gọn hơn.
`[]` Ngoài ra, bạn có thể khởi tạo array trong JavaScript vớimột số phần tử cho trước:

```js
let letters = [""a"", ""b"", ""c""];
```
`let letters = [""a"", ""b"", ""c""];` Khi đó, các phần tử trong mảng được sắp xếp theo thứ tự, phần tử đầu tiên có chỉ số là0. Phần tử cuối cùng có chỉ số bằng độ dài mảng trừ đi 1 đơn vị.
`0` Để truy cập các phần tử trong mảng, bạn sử dụngarr[index]vớiindexlà chỉ số của phần tử:
`arr[index]` `index` 
```js
let letters = [""a"", ""b"", ""c""];

console.log(letters[0]); // a
console.log(letters[1]); // b
console.log(letters[2]); // c

// trường hợp chỉ số ngoài phạm vi giới hạn thì kết quả là undefined
console.log(letters[-1]); // undefined
console.log(letters[3]); // undefined
```
`let letters = [""a"", ""b"", ""c""];

console.log(letters[0]); // a
console.log(letters[1]); // b
console.log(letters[2]); // c

// trường hợp chỉ số ngoài phạm vi giới hạn thì kết quả là undefined
console.log(letters[-1]); // undefined
console.log(letters[3]); // undefined` Bạn cũng có thể thay đổi giá trị của phần tử trong mảng:

```js
let letters = [""a"", ""b"", ""c""];

// thay đổi giá trị của mảng tại chỉ số 0
letters[0] = ""A"";
console.log(letters[0]); // A
```
`let letters = [""a"", ""b"", ""c""];

// thay đổi giá trị của mảng tại chỉ số 0
letters[0] = ""A"";
console.log(letters[0]); // A` Hoặc thêm phần tử mới vào mảng:

```js
let letters = [""a"", ""b"", ""c""];

// thêm phần tử vào mảng tại chỉ số 3
letters[3] = ""d"";
console.log(letters[3]); // d
```
`let letters = [""a"", ""b"", ""c""];

// thêm phần tử vào mảng tại chỉ số 3
letters[3] = ""d"";
console.log(letters[3]); // d`"
339,Mảng array trong Javascript,Một số đặc điểm của array trong JavaScript,"Tổng số phần tử trong mảng được xác định qua thuộc tínhlength:
`length` 
```js
let letters = [""a"", ""b"", ""c""];

console.log(letters.length); // 3
```
`let letters = [""a"", ""b"", ""c""];

console.log(letters.length); // 3` Bạn có thể in ra toàn bộ giá trị của mảng:

```js
let letters = [""a"", ""b"", ""c""];

console.log(letters); // (3) ['a', 'b', 'c']
```
`let letters = [""a"", ""b"", ""c""];

console.log(letters); // (3) ['a', 'b', 'c']` Giá trị các phần tử trong mảng có thể thuộc bất kỳkiểu dữ liệunào:

```js
let arr = [
  ""a"", // string
  1, // number
  null, // null
  undefined, // undefined
  { x: 1 }, // object
  function () {
    // hàm
    console.log(""hello"");
  },
];

// giá trị tại chỉ số 4 là object { x: 1}
console.log(arr[4].x); // 1

// giá trị tại chỉ số 5 là hàm
arr[5](); // hello
```
`let arr = [
  ""a"", // string
  1, // number
  null, // null
  undefined, // undefined
  { x: 1 }, // object
  function () {
    // hàm
    console.log(""hello"");
  },
];

// giá trị tại chỉ số 4 là object { x: 1}
console.log(arr[4].x); // 1

// giá trị tại chỉ số 5 là hàm
arr[5](); // hello` Tương tự như object, array có thểcó hoặc khôngdùng ""dấu phẩy đuôi"" - dấu phẩy sau phần tử cuối cùng.

```js
let arr = [
  ""a"",
  1,
  null,
  undefined,
  { x: 1 },
  function () {
    console.log(""hello"");
  },
];
```
`let arr = [
  ""a"",
  1,
  null,
  undefined,
  { x: 1 },
  function () {
    console.log(""hello"");
  },
];` Việc thêm dấu phẩy sau phần tử cuối cùng giúpphần biểu diễn các thuộc tính giống nhau. Qua đó, việcthêm/xóaphần tử trở nên dễ dàng hơn."
340,Mảng array trong Javascript,Một số phương thức cơ bản của array,"Một số phương thức cơ bản của array trong JavaScript là:arr.pop(),arr.push(),arr.shift()vàarr.unshift().
`arr.pop()` `arr.push()` `arr.shift()` `arr.unshift()` ► Phương thứcarr.pop()
`arr.pop()` Lấy ra và trả về phần tử cuối cùng của mảng.

```js
let letters = [""a"", ""b"", ""c""];
let item = letters.pop();

console.log(item); // c
console.log(letters); // (2) ['a', 'b']
```
`let letters = [""a"", ""b"", ""c""];
let item = letters.pop();

console.log(item); // c
console.log(letters); // (2) ['a', 'b']` ► Phương thứcarr.push()
`arr.push()` Thêmmột hoặc nhiềuphần tử vào cuối mảng và trả về độ dài mới của mảng.

```js
let letters = [""a"", ""b"", ""c""];

// thêm một phần tử vào cuối mảng
let length = letters.push(""d"");
console.log(length); // 4
console.log(letters); // (4) ['a', 'b', 'c', 'd']

// thêm nhiều phần tử vào cuối mảng
length = letters.push(""e"", ""f"");
console.log(length); // 6
console.log(letters); // (6) ['a', 'b', 'c', 'd', 'e', 'f']
```
`let letters = [""a"", ""b"", ""c""];

// thêm một phần tử vào cuối mảng
let length = letters.push(""d"");
console.log(length); // 4
console.log(letters); // (4) ['a', 'b', 'c', 'd']

// thêm nhiều phần tử vào cuối mảng
length = letters.push(""e"", ""f"");
console.log(length); // 6
console.log(letters); // (6) ['a', 'b', 'c', 'd', 'e', 'f']` ► Phương thứcarr.shift()
`arr.shift()` Lấy ra và trả về phần tử đầu tiên của mảng.

```js
let letters = [""a"", ""b"", ""c""];
let item = letters.shift();

console.log(item); // a
console.log(letters); // (2) ['b', 'c']
```
`let letters = [""a"", ""b"", ""c""];
let item = letters.shift();

console.log(item); // a
console.log(letters); // (2) ['b', 'c']` ► Phương thứcarr.unshift()
`arr.unshift()` Thêmmột hoặc nhiềuphần tử vào đầu mảng.

```js
let letters = [""a"", ""b"", ""c""];

// thêm một phần tử vào đầu mảng
let length = letters.unshift(""d"");
console.log(length); // 4
console.log(letters); // (4) ['d', 'a', 'b', 'c']

// thêm nhiều phần tử vào đầu mảng
length = letters.unshift(""e"", ""f"");
console.log(length); // 6
console.log(letters); // (6) ['e', 'f', 'd', 'a', 'b', 'c']
```
`let letters = [""a"", ""b"", ""c""];

// thêm một phần tử vào đầu mảng
let length = letters.unshift(""d"");
console.log(length); // 4
console.log(letters); // (4) ['d', 'a', 'b', 'c']

// thêm nhiều phần tử vào đầu mảng
length = letters.unshift(""e"", ""f"");
console.log(length); // 6
console.log(letters); // (6) ['e', 'f', 'd', 'a', 'b', 'c']`"
341,Mảng array trong Javascript,Mối liên hệ giữa array và object,"Như mình đã nói ở trên, array về bản chất cũng là object. Cú pháp truy cập phần tử của mảngarr[index]tương tự như cú pháp của objectobj[key]. Nói cách khác,indexở array tương đươngkeycủa object.
`arr[index]` `obj[key]` `index` `key` Và khicopy arraythì đó cũng làcopy qua tham chiếu- tương tự nhưcopy object:

```js
let letters = [""a"", ""b"", ""c""];
let copied = letters;

// giá trị của copied hoàn toàn giống letters
console.log(copied); // (3) ['a', 'b', 'c']

// khi thay đổi giá trị của copied
copied[1] = ""new value"";

// giá trị của letters cũng thay đổi
console.log(letters[1]); // new value
```
`let letters = [""a"", ""b"", ""c""];
let copied = letters;

// giá trị của copied hoàn toàn giống letters
console.log(copied); // (3) ['a', 'b', 'c']

// khi thay đổi giá trị của copied
copied[1] = ""new value"";

// giá trị của letters cũng thay đổi
console.log(letters[1]); // new value` Điều đặc biệt hơn của array so với object là: array lưu trữ dữ liệu theo thứ tự.
JavaScript Engine sẽ cố gắng lưu trữ các phần tử của mảng vào các vùng nhớ liên tiếp nhau. Và tối ưu hóa để làm sao truy cập các phần tử mảng nhanh nhất.
Nhưng tất cả những điều này sẽ không còn đúng nữa, nếu bạnsử dụng array theo kiểu của object, ví dụ:

```js
// mảng ban đầu có 3 phần tử
let letters = [""a"", ""b"", ""c""];

// thêm một phần tử vào mảng ở chỉ số lớn hơn kích thước mảng
letters[1000] = ""d"";
console.log(letters[1000]); // d

// thêm thuộc tính với tên tùy ý vào mảng
letters.x = 100;
console.log(letters.x); // 100

// độ dài của mảng tăng bất thường
console.log(letters.length); // 1001
```
`// mảng ban đầu có 3 phần tử
let letters = [""a"", ""b"", ""c""];

// thêm một phần tử vào mảng ở chỉ số lớn hơn kích thước mảng
letters[1000] = ""d"";
console.log(letters[1000]); // d

// thêm thuộc tính với tên tùy ý vào mảng
letters.x = 100;
console.log(letters.x); // 100

// độ dài của mảng tăng bất thường
console.log(letters.length); // 1001` Cách sử dụng trênkhông có lỗi cú phápnhưng không đúng với ý nghĩa khi tạo raarray trong JavaScript.
Mục đích của array là để lưu trữ dữ liệu theo thứ tự. Nếu bạn muốn lưu trữ thuộc tính với key bất kỳ thì hãy sử dụng object thông thường{}.
`{}`"
342,Mảng array trong Javascript,Duyệt tất cả các phần tử trong mảng,"Cách cơ bản nhất đểduyệt tất cả các phần tửcủa mảng trong JavaScript là dùngvòng lặp forvới chỉ số:

```js
let letters = [""a"", ""b"", ""c""];

for (let i = 0; i < letters.length; i++) {
  console.log(letters[i]);
}
```
`let letters = [""a"", ""b"", ""c""];

for (let i = 0; i < letters.length; i++) {
  console.log(letters[i]);
}` Kết quả
abc
Nếu không quan tâm đến chỉ số, bạn có thể dùng vòng lặpfor...ofcho ngắn gọn hơn:
`for...of` 
```js
let letters = [""a"", ""b"", ""c""];

for (let value of letters) {
  console.log(value);
}
```
`let letters = [""a"", ""b"", ""c""];

for (let value of letters) {
  console.log(value);
}` Ngoài ra, bạn cũng có thể dùng vòng lặpfor...intương tự như cách duyệt tất cả các key trong object:
`for...in` 
```js
let letters = [""a"", ""b"", ""c""];

for (let key in letters) {
  console.log(letters[key]);
}
```
`let letters = [""a"", ""b"", ""c""];

for (let key in letters) {
  console.log(letters[key]);
}` Cách sử dụngfor...inkhông sai, nhưng có một số vấn đề là:
`for...in` `length` `for...in` Nói chung, không nên sử dụngfor...inđể duyệt hết tất cả các phần tử của array trong JavaScript.
`for...in`"
343,Mảng array trong Javascript,Vấn đề liên quan đếnlengthcủa array,"`length` Thuộc tínhlengthđược tự động cập nhật mỗi khi bạn thêm/xóa phần tử trong mảng. Nhưnglengthkhông thật sự biểu thị số lượng phần tử trong mảng.
`length` `length` Giá trị củalengthbằng chỉ số lớn nhất trong mảng cộng thêm 1 đơn vị, ví dụ:
`length` 
```js
let arr = [];
arr[1000] = ""a"";
console.log(arr.length); // 1001
```
`let arr = [];
arr[1000] = ""a"";
console.log(arr.length); // 1001` Lưu ý
Đây chỉ là ví dụ minh họa, bạnkhông nênsử dụng array theo cách này.
Thuộc tínhlengthlàwritable. Nghĩa là bạn có thể thay đổi giá trị của thuộc tínhlength.
`length` `length` Nếu bạn tăng nó lên thì không sao. Nhưng ngược lại, nếu bạn giảm giá trị củalengththì mảng sẽ bị cắt ngắn đi:
`length` 
```js
let letters = [""a"", ""b"", ""c""];
console.log(letters.length); // 3

// giảm length xuống thành 2
letters.length = 2;
console.log(letters); // (2) ['a', 'b']

// tăng length thành 5
letters.length = 5;
console.log(letters[2]); // undefined - giá trị cũ là ""c""
```
`let letters = [""a"", ""b"", ""c""];
console.log(letters.length); // 3

// giảm length xuống thành 2
letters.length = 2;
console.log(letters); // (2) ['a', 'b']

// tăng length thành 5
letters.length = 5;
console.log(letters[2]); // undefined - giá trị cũ là ""c""` Trong ví dụ trên, khi bạn giảmlengthrồi tănglengthtrở lại, giá trị trước đó trong mảng (letters[2]) không được khôi phục trở lại.
`length` `length` `letters[2]` 💡 Cách đơn giản nhất để xóa mảng là gánlengthbằng 0:arr.length = 0.
`length` `arr.length = 0` Đây là một cú pháp khác để khởi tạo array trong JavaScript:

```js
let letters = new Array(""a"", ""b"", ""c"");

console.log(letters); // (3) ['a', 'b', 'c']
```
`let letters = new Array(""a"", ""b"", ""c"");

console.log(letters); // (3) ['a', 'b', 'c']` Cú pháp trên khởi tạo array với ba phần tử tương tự như sau:

```js
let letters = [""a"", ""b"", ""c""];
```
`let letters = [""a"", ""b"", ""c""];` Tuy nhiên, việc sử dụngnew Array()lại khá ít dùng vì nó chậm và có một trường hợp khó hiểu.
`new Array()` Câu lệnhnew Array(number)vớinumberlà một số, không khởi tạo mảng có 1 phần tử lànumbermà khởi tạo mảng cónumberphần tử.
`new Array(number)` `number` `number` `number` 
```js
// Tham số truyền vào là string
let arr1 = new Array(""1"");
console.log(arr1); // [""1""]

// Tham số truyền vào là số
let arr2 = new Array(1);
console.log(arr2); // [empty]
```
`// Tham số truyền vào là string
let arr1 = new Array(""1"");
console.log(arr1); // [""1""]

// Tham số truyền vào là số
let arr2 = new Array(1);
console.log(arr2); // [empty]` 💡 Để tránh nhầm lẫn, bạn chỉ nên sử dụng dấu ngoặc vuông[]để khởi tạo mảng (trừ khi bạn có mục đích đặc biệt nào khác).
`[]`"
344,Mảng array trong Javascript,Mảng nhiều chiều,"Mảng trong JavaScript có thể chứa phần tử cũng là một mảng. Đó gọi làmảng nhiều chiều.
Ví dụ sử dụng mảng hai chiều để lưu ma trận 2x2:

```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

// truy cập phần tử ở hàng 1, cột 1
console.log(matrix[1][1]); // 5
```
`let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

// truy cập phần tử ở hàng 1, cột 1
console.log(matrix[1][1]); // 5` Array có triển khai phương thứctoString()theo cách riêng. Phương thức này trả về một string chứa giá trị của các phần tử mảng - được ngăn cách nhau bởi dấu phẩy:
`toString()` 
```js
let letters = [""a"", ""b"", ""c""];
console.log(letters.toString()); // a,b,c
```
`let letters = [""a"", ""b"", ""c""];
console.log(letters.toString()); // a,b,c` Ví dụ cộng array với số:

```js
console.log([] + 3); // 3
console.log([1] + 3); // 13
console.log([1, 2] + 3); // 1,23
```
`console.log([] + 3); // 3
console.log([1] + 3); // 13
console.log([1, 2] + 3); // 1,23` Bởi vì, array không có phương thứcSymbol.toPrimitivevàvalueOf()mà chỉ có phương thứctoString().
`Symbol.toPrimitive` `valueOf()` `toString()` Vì vậy khi thực hiện phép cộng trên,[]trở thành string rỗng,[1]trở thành""1""và[1,2]trở thành""1,2"". Nên đoạn code trên tương đương với:
`[]` `[1]` `""1""` `[1,2]` `""1,2""` 
```js
console.log("""" + 3); // 3
console.log(""1"" + 3); // 13
console.log(""1,2"" + 3); // 1,23
```
`console.log("""" + 3); // 3
console.log(""1"" + 3); // 13
console.log(""1,2"" + 3); // 1,23` Tiếp theo, khi cộng string với số thì số sẽ đượcchuyển đổi kiểu dữ liệuvề string. Nên kết quả thu được như trên."
345,Mảng array trong Javascript,So sánh array trong JavaScript,"Tương tự như object, array cũng là kiểu dữ liệu tham chiếu. Vì vậy, việc so sánh array làso sánh qua tham chiếu.
Nghĩa là hai array chỉ bằng nhau khi chúng cùng tham chiếu. Ngược lại, dù cho hai array có các phần tử giống nhau thì chúng cũng không bằng nhau.

```js
let a = [];
let b = [];

// a và b cùng là mảng rỗng nhưng không bằng nhau
console.log(a === a); // true
console.log(a === b); // false
```
`let a = [];
let b = [];

// a và b cùng là mảng rỗng nhưng không bằng nhau
console.log(a === a); // true
console.log(a === b); // false` Để so sánh hai array với nhau theo giá trị các phần tử, bạn có thể tham khảo cách mình triển khai với object trong bài viết:So sánh hai object trong JavaScript."
346,Mảng array trong Javascript,Tổng kết,"Array trong JavaScript là một loại object đặc biệt dùng để lưu trữ dữ liệu theo thứ tự.
Để khởi tạo array, bạn có hai cách:

```js
// cách phổ biến
let a1 = [item1, item2,...];

// cách ít dùng
let a2 = new Array(item1, item2,...);
```
`// cách phổ biến
let a1 = [item1, item2,...];

// cách ít dùng
let a2 = new Array(item1, item2,...);` Cách gọinew Array(number)vớinumberlà số sẽ tạo một mảng mới có giá trịlengthlànumber, nhưng lại không có phần tử nào.
`new Array(number)` `number` `length` `number` Thuộc tínhlengthcó giá trị là độ dài của mảng, chính xác hơn thìlengthbằng giá trị chỉ số lớn nhất cộng thêm 1 đơn vị. Mỗi khi bạn thêm/xóa phần tử trong mảng thì thuộc tínhlengthtăng/giảm tương ứng.
`length` `length` `length` Nhưng bạn cũng có thể thay đổi trực tiếp giá trị củalength. Nếu giá trị củalengthgiảm đi thì mảng cũng bị cắt ngắn đi. Và khilengthbằng 0, đồng nghĩa với mảng bị xóa.
`length` `length` `length` Một sốphương thức phổ biến trong mảnglà:
`arr.push(item1, item2,...)` `arr.pop()` `arr.shift()` `arr.unshift(item1, item2,...)` Có ba cách để duyệt hết tất cả các phần tử của mảng:
`for` `for (let i=0; i < arr.length; i++)` `for (let item of arr)` `for (let i in arr)` So sánh array thực chất là so sánh theo tham chiếu. Để so sánh từng phần tử của mảng, bạn có thể dùng vòng lặpfor...ofđể duyệt hết tất cả các phần tử hoặc sử dụng thư viện_.isEqual.
`for...of` `_.isEqual`"
347,Mảng array trong Javascript,Thực hành,"Đoạn code sau hiển thị như thế nào:

```js
let letters = [""a"", ""b"", ""c""];
let otherArr = letters;
otherArr.push(""d"");

// giá trị length của letters bằng bao nhiêu?
console.log(letters.length); // ?
```
`let letters = [""a"", ""b"", ""c""];
let otherArr = letters;
otherArr.push(""d"");

// giá trị length của letters bằng bao nhiêu?
console.log(letters.length); // ?` Xem đáp án
Kết quả là: 4
`Kết quả là: 4` Giải thích:
`otherArr = letters` `otherArr` `letters` `otherArr.push(""d"")` `otherArr` `letters` Hãy viết code thực hiện các bước sau:
`letters` Xem đáp án

```js
// 1. Tạo mảng `letters` với hai phần tử ""a"" và ""b"".
let letters = [""a"", ""b""];

// 2. Thêm phần tử ""c"" vào cuối mảng.
letters.push(""c"");

// 3. Thay đổi giá trị của phần tử ở giữa thành ""d"".
let length = letters.length;
letters[Math.floor(length / 2)] = ""d"";
console.log(letters); // (3) ['a', 'd', 'c']

// 4. Lấy ra và trả về giá trị phần tử đầu tiên của mảng.
let first = letters.shift();
console.log(first); // a

// 5. Thêm hai số 1, 2 vào đầu mảng.
letters.unshift(1, 2);
console.log(letters); // (4) [1, 2, 'd', 'c']
```
`// 1. Tạo mảng `letters` với hai phần tử ""a"" và ""b"".
let letters = [""a"", ""b""];

// 2. Thêm phần tử ""c"" vào cuối mảng.
letters.push(""c"");

// 3. Thay đổi giá trị của phần tử ở giữa thành ""d"".
let length = letters.length;
letters[Math.floor(length / 2)] = ""d"";
console.log(letters); // (3) ['a', 'd', 'c']

// 4. Lấy ra và trả về giá trị phần tử đầu tiên của mảng.
let first = letters.shift();
console.log(first); // a

// 5. Thêm hai số 1, 2 vào đầu mảng.
letters.unshift(1, 2);
console.log(letters); // (4) [1, 2, 'd', 'c']` Kết quả hiển thị là gì?

```js
let letters = [""a"", ""b""];

letters.push(function () {
  alert(this);
});

letters[2](); // ?
```
`let letters = [""a"", ""b""];

letters.push(function () {
  alert(this);
});

letters[2](); // ?` Xem đáp án

```js
let letters = [""a"", ""b""];

letters.push(function () {
  console.log(this);
});

letters[2](); // a,b,function(){...}
```
`let letters = [""a"", ""b""];

letters.push(function () {
  console.log(this);
});

letters[2](); // a,b,function(){...}` Cách viếtletters[2]tương tự như cách truy cập phần tử trong objectobj[key]. Mà giá trị tạiletters[2]là một hàm. Nói cách khác, đó là phương thức của object.
`letters[2]` `obj[key]` `letters[2]` Vì vậy, giá trị củathisđược bind với đối tượng gọi phương thức. Nênthischính làletters.
`this` `this` `letters` Viết hàmsumInputthực hiện các yêu cầu sau:
`sumInput` `prompt` Xem đáp án

```js
// định nghĩa hàm
function sumInput() {
  // khởi tạo mảng rỗng để lưu số
  let arr = [];

  // 1. hỏi người dùng để nhập vào số
  while (true) {
    let n = prompt(""Nhập vào một số:"", 0);

    // 2. kiểm tra điều kiện dừng
    if (n === """" || n === null || n === undefined || !isFinite(n)) {
      break;
    }

    // lưu lại số vào mảng
    arr.push(+n);
  }

  // 3. tính tổng các số nhập vào
  let s = 0;
  for (let num of arr) {
    s += num;
  }
  return s;
}

// gọi hàm
sumInput();
```
`// định nghĩa hàm
function sumInput() {
  // khởi tạo mảng rỗng để lưu số
  let arr = [];

  // 1. hỏi người dùng để nhập vào số
  while (true) {
    let n = prompt(""Nhập vào một số:"", 0);

    // 2. kiểm tra điều kiện dừng
    if (n === """" || n === null || n === undefined || !isFinite(n)) {
      break;
    }

    // lưu lại số vào mảng
    arr.push(+n);
  }

  // 3. tính tổng các số nhập vào
  let s = 0;
  for (let num of arr) {
    s += num;
  }
  return s;
}

// gọi hàm
sumInput();` Tham khảo:"
348,Map trong Javascript,Giới thiệu,"Map trong JavaScriptlà một loại object cho phép lưu trữ dữ liệu theo kiểukey-value.
Nghe qua thì Map có vẻ giống vớiobjectbình thường. Nhưng không phải tự nhiên mà người tatạo thêm kiểu dữ liệu Map.
Thực tế, Map cónhững đặc điểm riêng biệtso với object thông thường. Sau đây, mình cùng tìm hiểu về Map trong JavaScript nhé!"
349,Map trong Javascript,Map trong JavaScript là gì?,"Nói một cách đầy đủ, Map trong JavaScript là mộtcấu trúc dữ liệucho phép lưu trữ dữ liệu theo kiểukey-value, tương tự như object. Tuy nhiên, chúng khác nhau ở chỗ là:
Lưu ý
Để tránh hiểu lầm, mỗi khi mình dùng từobjectthì bạn hiểu đó làobject thông thườngmà từ trước đến giờ bạn vẫn sử dụng, không phảiMap.

```js
const map1 = new Map();
console.log(typeof map1); // object
```
`const map1 = new Map();
console.log(typeof map1); // object`"
350,Map trong Javascript,Khởi tạo Map trong JavaScript,"Cú pháp khởi tạo Map trong JavaScript là:

```js
new Map([iterable]);
```
`new Map([iterable]);` Bạn có thể truyền vào mộtiterable objectđể khởi tạo Map. Khi đó, mỗi phần tử của iterable object sẽ tương ứng với một phần tử của Map.
Dĩ nhiên, tham sốiterablelàkhông bắt buộc. Khi bạn không truyền vàoiterable, Map sẽ rỗng và không có phần tử nào.
`iterable` `iterable` Chú ý: vì Map lưu trữ dữ liệu theo kiểukey-valuenên mỗi phần tử của iterable object phải là mộtmảnggồm 2 phần tửcó dạng:[key, value].
`[key, value]` Một số ví dụ:
`[1, 2, 3, 4]` `[[1, 2], [3, 4]]` `[1, 2]` `[3, 4]` `1` `2` `3` `4` Dựa vào những đặc điểm nêu trên, mình có thể khởi tạo Map trong JavaScript theo những cách sau đây.
Để khởi tạo Map rỗng, bạn chỉ cầnkhông truyền vào tham sốcho hàm khởi tạo:

```js
const map1 = new Map();
console.log(map1);
// Map(0) {}
```
`const map1 = new Map();
console.log(map1);
// Map(0) {}` Array hợp lệ để khởi tạo Map là các phần tử của array phải làmột mảng hai phần tử.

```js
// Trường hợp hợp lệ:
// Mỗi phần tử của mảng đầu vào là một mảng hai phần tử
const map2 = new Map([
  [1, ""a""],
  [2, ""b""],
]);
console.log(map2);
// Map(2) {1 => ""a"", 2 => ""b""}

// Trường hợp KHÔNG hợp lệ:
// Mỗi phần tử của mảng đầu vào không phải mảng hai phần tử
const map3 = new Map([1, ""a"", 2, ""b""]);
// Uncaught TypeError: Iterator value 1 is not an entry object
```
`// Trường hợp hợp lệ:
// Mỗi phần tử của mảng đầu vào là một mảng hai phần tử
const map2 = new Map([
  [1, ""a""],
  [2, ""b""],
]);
console.log(map2);
// Map(2) {1 => ""a"", 2 => ""b""}

// Trường hợp KHÔNG hợp lệ:
// Mỗi phần tử của mảng đầu vào không phải mảng hai phần tử
const map3 = new Map([1, ""a"", 2, ""b""]);
// Uncaught TypeError: Iterator value 1 is not an entry object` `arguments` Đối tượng arguments là đối tượng có sẵn trong hàm, dùng để lưu trữ mảng các tham số truyền vào.

```js
function func4() {
  const map4 = new Map(arguments);
  console.log(map4);
}

func4([""one"", 1], [""two"", 2], [""three"", 3]);
// Map(3) {""one"" => 1, ""two"" => 2, ""three"" => 3}
```
`function func4() {
  const map4 = new Map(arguments);
  console.log(map4);
}

func4([""one"", 1], [""two"", 2], [""three"", 3]);
// Map(3) {""one"" => 1, ""two"" => 2, ""three"" => 3}` Bạn có thể khởi tạo Map từ một Map khác:

```js
// Khởi tạo map thứ nhất
const map6 = new Map([
  [""a"", 1],
  [""b"", 2],
]);
console.log(map6);
// => Map(2) {""a"" => 1, ""b"" => 2}

// Khởi tạo map thứ hai từ map thứ nhất
const map6_clone = new Map(map6);
console.log(map6_clone);
// Map(2) {""a"" => 1, ""b"" => 2}
```
`// Khởi tạo map thứ nhất
const map6 = new Map([
  [""a"", 1],
  [""b"", 2],
]);
console.log(map6);
// => Map(2) {""a"" => 1, ""b"" => 2}

// Khởi tạo map thứ hai từ map thứ nhất
const map6_clone = new Map(map6);
console.log(map6_clone);
// Map(2) {""a"" => 1, ""b"" => 2}` Ngoài ra, bạn có thể khởi tạo Map từSet:

```js
// Khởi tạo Set
const set5 = new Set([
  [""a"", 1],
  [""b"", 2],
]);
console.log(set5);
// Set(2) {Array(2), Array(2)}

const map5 = new Map(set5);
console.log(map5);
// Map(2) {""a"" => 1, ""b"" => 2}
```
`// Khởi tạo Set
const set5 = new Set([
  [""a"", 1],
  [""b"", 2],
]);
console.log(set5);
// Set(2) {Array(2), Array(2)}

const map5 = new Map(set5);
console.log(map5);
// Map(2) {""a"" => 1, ""b"" => 2}` Trên đây là một số cách để khởi tạo Map trong JavaScript. Tiếp theo, mình sẽ tìm hiểu về cách để thêm phần tử vào Map."
351,Map trong Javascript,Thêm phần tử vào Map,"Để thêm phần tử vào Map trong JavaScript, bạn có thể sử dụng phương thứcset, với cú pháp:
`set` 
```js
map.set(key, value);
```
`map.set(key, value);` Phương thức này gán giá trịvaluecho khoákeybên trong Map.
`value` `key` Nếukeychưa tồn tạithì Map tạo mới phần tử vớikeytương ứng. Ngược lại, nếukeyđã tồn tạithì Map sẽ gán giá trị mới cho nó.
`key` `key` `key` Vấn đề làm sao biết đượckeyđã tồn tại hay chưa?
`key` Map sử dụng thuật toánSameValueZerođểso sánh giá trịcủa các key với nhau.
Thuật toánSameValueZerovề cơ bản là giống với việc sử dụng toán tử===để so sánh. Chỉ khác làSameValueZerocoiNaNlà giống nhau, mặc dùNaN !== NaNlàtrue.
`===` `NaN` `NaN !== NaN` `true` Ví dụ:

```js
// Khởi tạo Map rỗng.
const map7 = new Map();

// Thêm phần tử ""a"" -> 1 vào map.
map7.set(""a"", 1);
// Map(1) {""a"" => 1}

// Thêm phần tử ""b"" -> 2 vào map, ""b"" !== ""a"" nên Map tạo phần tử mới.
map7.set(""b"", 2);
// Map(2) {""a"" => 1, ""b"" => 2}

// Thêm phần tử [1] -> 3 vào map, [1] đều khác ""a"" và ""b"".
map7.set([1], 3);
// Map(3) {""a"" => 1, ""b"" => 2, [1] => 3}

// Thêm phần tử ""a"" -> 4 vào map, tuy nhiên key ""a"" đã tồn tại.
// => cập nhật vào phần tử cũ - số lượng phần tử không đổi
map7.set(""a"", 4);
// Map(3) {""a"" => 4, ""b"" => 2, [1] => 3}

// Thêm phần tử [1] -> 5 vào map.
// Trong map đã có phần tử với key [1], tuy nhiên mảng là kiểu tham chiếu.
// Vì vậy [1] !== [1]. Do đó, phần tử mới được thêm vào map.
map7.set([1], 5);
// Map(4) {""a"" => 4, ""b"" => 2, [1] => 3, [1] => 5}

// Thêm phần tử NaN -> 6 vào map.
// NaN khác các giá trị key đã có, nên phần tử mới được thêm vào map.
map7.set(NaN, 6);
// Map(5) {""a"" => 4, ""b"" => 2, [1] => 3, [1] => 5, NaN => 6}
```
`// Khởi tạo Map rỗng.
const map7 = new Map();

// Thêm phần tử ""a"" -> 1 vào map.
map7.set(""a"", 1);
// Map(1) {""a"" => 1}

// Thêm phần tử ""b"" -> 2 vào map, ""b"" !== ""a"" nên Map tạo phần tử mới.
map7.set(""b"", 2);
// Map(2) {""a"" => 1, ""b"" => 2}

// Thêm phần tử [1] -> 3 vào map, [1] đều khác ""a"" và ""b"".
map7.set([1], 3);
// Map(3) {""a"" => 1, ""b"" => 2, [1] => 3}

// Thêm phần tử ""a"" -> 4 vào map, tuy nhiên key ""a"" đã tồn tại.
// => cập nhật vào phần tử cũ - số lượng phần tử không đổi
map7.set(""a"", 4);
// Map(3) {""a"" => 4, ""b"" => 2, [1] => 3}

// Thêm phần tử [1] -> 5 vào map.
// Trong map đã có phần tử với key [1], tuy nhiên mảng là kiểu tham chiếu.
// Vì vậy [1] !== [1]. Do đó, phần tử mới được thêm vào map.
map7.set([1], 5);
// Map(4) {""a"" => 4, ""b"" => 2, [1] => 3, [1] => 5}

// Thêm phần tử NaN -> 6 vào map.
// NaN khác các giá trị key đã có, nên phần tử mới được thêm vào map.
map7.set(NaN, 6);
// Map(5) {""a"" => 4, ""b"" => 2, [1] => 3, [1] => 5, NaN => 6}` Khi sử dụngtoán tử so sánhbằng nghiêm ngặt===thì[1] === [1]làfalse. Vì vậy, Map trên tồn tại 2 cặp phần tử với key là[1]với value lần lượt là3và5.
`===` `[1] === [1]` `false` `[1]` `3` `5` Ngoài ra, phương thứcsetcòn trả về chính đối tượng Map. Nên mình có thể áp dụng kỹ thuật Method Chaining ở đây, sẽ giúp cho code trở nên ngắn gọn hơn.
`set` Đoạn code trên có thể trở nên gọn hơn bằng cách:

```js
const map7 = new Map();
map7.set(""a"", 1).set(""b"", 2).set([1], 3).set(""a"", 4).set([1], 5).set(NaN, 6);
// Map(5) {""a"" => 4, ""b"" => 2, [1] => 3, [1] => 5, NaN => 6}
```
`const map7 = new Map();
map7.set(""a"", 1).set(""b"", 2).set([1], 3).set(""a"", 4).set([1], 5).set(NaN, 6);
// Map(5) {""a"" => 4, ""b"" => 2, [1] => 3, [1] => 5, NaN => 6}`"
352,Map trong Javascript,Lấy giá trị của phần tử trong Map,"Để lấyvaluetương ứng vớikeycủa map trong JavaScript, bạn có thể sử dụng phương thứcmap.get(key)như sau:
`value` `key` `map.get(key)` 
```js
const map7 = new Map([
  [""a"", 1],
  [""b"", 1],
]);

console.log(map7.get(""a"")); // 1
console.log(map7.get(""c"")); // undefined
```
`const map7 = new Map([
  [""a"", 1],
  [""b"", 1],
]);

console.log(map7.get(""a"")); // 1
console.log(map7.get(""c"")); // undefined` Nếukeytồn tại trong Map thì phương thứcmap.get(key)trả vềvaluetương ứng, ngược lại thì trả vềundefined.
`key` `map.get(key)` `value` `undefined`"
353,Map trong Javascript,Lấy số lượng phần tử trong Map,"Để lấy rasố lượng các phần tửcủa Map trong JavaScript, bạn sử dụng phương thứcmap.size, ví dụ:
`map.size` 
```js
const map8 = new Map();
console.log(map8.size);
// 0 - mảng rỗng

map8.set(""a"", 1).set(""b"", 2);
console.log(map8.size);
// 2 - mảng có 2 phần tử
```
`const map8 = new Map();
console.log(map8.size);
// 0 - mảng rỗng

map8.set(""a"", 1).set(""b"", 2);
console.log(map8.size);
// 2 - mảng có 2 phần tử`"
354,Map trong Javascript,Kiểm tra phần tử tồn tại trong Map,"Để kiểm tra xemmột phần tử đã tồn tạitrong Map hay chưa - thực chất là kiểm tra xem một giá trịkeyđã tồn tại hay chưa, bạn có thể dùng phương thứchasnhư sau:
`key` `has` 
```js
map.has(key);
```
`map.has(key);` Nếu trong Map tồn tạikeythì phương thứcmap.has(key)trả vềtrue, ngược lại thì trả vềfalse.
`key` `map.has(key)` `true` `false` 
```js
const map9 = new Map([
  [""a"", 1],
  [1, 2],
  [[2], 3],
  [NaN, 4],
]);

console.log(map9.has(""a"")); // true
console.log(map9.has(""1"")); // false
console.log(map9.has(1)); // true
console.log(map9.has([2])); // false - vì [2] !== [2]
console.log(map9.has(NaN)); // true
```
`const map9 = new Map([
  [""a"", 1],
  [1, 2],
  [[2], 3],
  [NaN, 4],
]);

console.log(map9.has(""a"")); // true
console.log(map9.has(""1"")); // false
console.log(map9.has(1)); // true
console.log(map9.has([2])); // false - vì [2] !== [2]
console.log(map9.has(NaN)); // true` Bạn nhớ là Map sử dụng thuật toánSameValueZerođể so sánh nhé!"
355,Map trong Javascript,Xoá một phần tử trong Map,"Đểxóa một phần tửtrong Map, bạn sử dụng phương thứcdelete:
`delete` 
```js
map.delete(key);
```
`map.delete(key);` Nếu trong Map tồn tạikeythì phần tử ứng vớikeysẽ bị xóa khỏi Map. Phương thứcmap.delete(key)trả vềtruenếukeytồn tại, ngược lại thì trả vềfalse.
`key` `key` `map.delete(key)` `true` `key` `false` 
```js
const map10 = new Map([
  [""one"", 1],
  [""two"", 2],
  [""three"", 3],
]);
console.log(map10);
// Map(3) {""one"" => 1, ""two"" => 2, ""three"" => 3}

// xóa phần tử với key là ""two"" - tồn tại
console.log(map10.delete(""two""));
// true

// sau khi xóa, map còn lại 2 phần tử
console.log(map10);
// {""one"" => 1, ""three"" => 3}
```
`const map10 = new Map([
  [""one"", 1],
  [""two"", 2],
  [""three"", 3],
]);
console.log(map10);
// Map(3) {""one"" => 1, ""two"" => 2, ""three"" => 3}

// xóa phần tử với key là ""two"" - tồn tại
console.log(map10.delete(""two""));
// true

// sau khi xóa, map còn lại 2 phần tử
console.log(map10);
// {""one"" => 1, ""three"" => 3}`"
356,Map trong Javascript,Xoá tất cả phần tử trong Map,"Phía trên là cách xóamột phần tửkhỏi Map. Để xóa hếttất cả các phần tửkhỏi Map, bạn sử dụng phương thứcclear:
`clear` 
```js
const map11 = new Map([
  [""a"", 1],
  [""b"", 2],
  [""c"", 3],
]);
console.log(map11);
// Map(3) {""a"" => 1, ""b"" => 2, ""c"" => 3}

// xóa hết các phần tử
map11.clear();

// map trở thành empty
console.log(map11);
// Map(0) {}
```
`const map11 = new Map([
  [""a"", 1],
  [""b"", 2],
  [""c"", 3],
]);
console.log(map11);
// Map(3) {""a"" => 1, ""b"" => 2, ""c"" => 3}

// xóa hết các phần tử
map11.clear();

// map trở thành empty
console.log(map11);
// Map(0) {}`"
357,Map trong Javascript,Duyệt qua các phần tử trong Map,"Sau đây là các cách để duyệt qua các phần tử của Map trong JavaScript.
`for...of` Map làiterable object. Do đó, bạn có thể sử dụngfor...ofđể duyệt qua các phần tử của Map.
`for...of` 
```js
const map12 = new Map([
  [1, ""a""],
  [2, ""b""],
  [3, ""c""],
]);

for (const item of map12) {
  console.log(item);
}
/*
 * [1, ""a""]
 * [2, ""b""]
 * [3, ""c""]
 */
```
`const map12 = new Map([
  [1, ""a""],
  [2, ""b""],
  [3, ""c""],
]);

for (const item of map12) {
  console.log(item);
}
/*
 * [1, ""a""]
 * [2, ""b""]
 * [3, ""c""]
 */` `forEach` Bạn cũng có thể sử dụngforEachduyệt qua các phần tử của map như sau:
`forEach` 
```js
const map13 = new Map([
  [1, ""a""],
  [2, ""b""],
  [3, ""c""],
]);

map13.forEach((value, key, map) => {
  console.log(value, key, map);
});
/*
 * a 1 Map(3) {1 => ""a"", 2 => ""b"", 3 => ""c""}
 * b 2 Map(3) {1 => ""a"", 2 => ""b"", 3 => ""c""}
 * c 3 Map(3) {1 => ""a"", 2 => ""b"", 3 => ""c""}
 */
```
`const map13 = new Map([
  [1, ""a""],
  [2, ""b""],
  [3, ""c""],
]);

map13.forEach((value, key, map) => {
  console.log(value, key, map);
});
/*
 * a 1 Map(3) {1 => ""a"", 2 => ""b"", 3 => ""c""}
 * b 2 Map(3) {1 => ""a"", 2 => ""b"", 3 => ""c""}
 * c 3 Map(3) {1 => ""a"", 2 => ""b"", 3 => ""c""}
 */` Bạn chú ýhàm callback:
`value` `key` `map` Cú pháp này tương tự với củaforEach khi duyệt mảng:

```js
arr.forEach(function (value, index, arr) {
  // code xử lý
});
```
`arr.forEach(function (value, index, arr) {
  // code xử lý
});` ► Phương thứcmap.keys()
`map.keys()` Trả về một iterable object chứa giá trịkeycủa các phần tử theo thứ tự chèn vào.
`key` 
```js
const map14 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

for (const key of map14.keys()) {
  console.log(key);
}
/*
 * 1
 * b
 * 3
 */
```
`const map14 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

for (const key of map14.keys()) {
  console.log(key);
}
/*
 * 1
 * b
 * 3
 */` ► Phương thứcmap.values()trả về một iterable object chứa giá trịvaluecủa các phần tử theo thứ tự chèn vào.
`map.values()` `value` 
```js
const map14 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

for (const value of map14.values()) {
  console.log(value);
}
/*
 * a
 * 2
 * c
 */
```
`const map14 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

for (const value of map14.values()) {
  console.log(value);
}
/*
 * a
 * 2
 * c
 */` ► Phương thứcmap.entries()trả về một iterable object mà mỗi phần tử tương ứng là một mảng[key, value].
`map.entries()` `[key, value]` 
```js
const map14 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

for (const item of map14.entries()) {
  console.log(item);
}
/*
 * [1, ""a""]
 * [""b"", 2]
 * [3, ""c""]
 */
```
`const map14 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

for (const item of map14.entries()) {
  console.log(item);
}
/*
 * [1, ""a""]
 * [""b"", 2]
 * [3, ""c""]
 */`"
358,Map trong Javascript,Chuyển Map thành Array,"Sau đây là một số cách chuyển map trong JavaScript thành array sử dụngcú pháp spread.

```js
const map15 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

const keys = [...map15.keys()];
console.log(keys);
// [1, ""b"", 3]
```
`const map15 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

const keys = [...map15.keys()];
console.log(keys);
// [1, ""b"", 3]` 
```js
const map16 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

const values = [...map16.values()];
console.log(values);
// [""a"", 2, ""c""]
```
`const map16 = new Map([
  [1, ""a""],
  [""b"", 2],
  [3, ""c""],
]);

const values = [...map16.values()];
console.log(values);
// [""a"", 2, ""c""]`"
359,Map trong Javascript,Tổng kết,"Map trong JavaScript là một loại object dùng để lưu trữ dữ liệu theo kiểukey-value, nhưng Map khác object ở một số điểm sau:
Một số phương thức và thuộc tính của Map:
`new Map([iterable])` `[key, value]` `map.set(key, value)` `value` `key` `map` `map.get(key)` `value` `key` `key` `undefined` `map.has(key)` `true` `key` `false` `map.delete(key)` `key` `true` `key` `false` `map.clear()` `map` `map.size` `map` Tham khảo:"
360,Method chaining trong Javascript,Giới thiệu,"Trong lập trình nói chung và lập trình JavaScript nói riêng, có một kĩ thuật khá hay với tên gọi trong tiếng Anh là:Method Chaining,Function ChaininghoặcCascading. Vậy kĩ thuật này có gì hay và cách sử dụng nó như thế thế nào? Mời bạn theo dõi bài viết!"
361,Method chaining trong Javascript,Kĩ thuật Method Chaining có gì hay?,"Kĩ thuật Method Chaining giúp code trở nên ngắn gọn, dễ theo dõi và hạn chế việc sử dụng các biến tạm.
Ví dụ: khi sử dụng jQuery, bạn có thể dễ dàng nhìn thấy những đoạn code như sau:

```js
$("".myClass"").addClass(""bird"").show().animate({
  /* some animation */
});
```
`$("".myClass"").addClass(""bird"").show().animate({
  /* some animation */
});` Nếu không sử dụng kĩ thuật Method Chaining thì đoạn code trên sẽ khá dài dòng:

```js
const $myClass = $("".myClass"");
$.addClass($myClass, ""bird"");
$.show($myClass);
$.animate($myClass, {
  /* some animation */
});
```
`const $myClass = $("".myClass"");
$.addClass($myClass, ""bird"");
$.show($myClass);
$.animate($myClass, {
  /* some animation */
});` Bạn có thể thấy rằng, khi sử dụng Method Chaining, bạn hầu như chỉ cần viết các đoạn code trên cùng 1 dòng.
Thực tế, kĩ thuật này đã và đang được sử dụng rất nhiều trong hầu hết các thư viện, Framework JavaScript."
362,Method chaining trong Javascript,Cách sử dụng kĩ thuật Method Chaining cơ bản,"Trong bài viết này, mình sẽ chỉ giới thiệu một cách cơ bản về kĩ thuật Method Chaining. Hy vọng qua đó bạn có thể tự tìm hiểu thêm sau này.

```js
class Number {
  constructor(value) {
    this.value = value;
  }
  add(value) {
    this.value += value;
  }
  sub(value) {
    this.value -= value;
  }
  mul(value) {
    this.value *= value;
  }
  div(value) {
    this.value /= value;
  }
}

let num = new Number(10);
num.add(5); // 10 + 5 => 15
num.sub(3); // 15 - 3 => 12
num.mul(2); // 12 * 2 => 24
num.div(8); // 24 / 8 => 3

console.log(num.value);
// => 3
```
`class Number {
  constructor(value) {
    this.value = value;
  }
  add(value) {
    this.value += value;
  }
  sub(value) {
    this.value -= value;
  }
  mul(value) {
    this.value *= value;
  }
  div(value) {
    this.value /= value;
  }
}

let num = new Number(10);
num.add(5); // 10 + 5 => 15
num.sub(3); // 15 - 3 => 12
num.mul(2); // 12 * 2 => 24
num.div(8); // 24 / 8 => 3

console.log(num.value);
// => 3` Ví dụ trên xây dựng classNumbervới 4 phương thứcadd,sub,mul,div. Và bạn có thể thấy với mỗi phương thức được gọi, bạn phải lặp lại biếnnumvà mỗi câu lệnh thường viết trên 1 dòng.
Như vậy khá dài dòng phải không bạn?

```js
class Number {
  constructor(value) {
    this.value = value;
  }
  add(value) {
    this.value += value;
    return this;
  }
  sub(value) {
    this.value -= value;
    return this;
  }
  mul(value) {
    this.value *= value;
    return this;
  }
  div(value) {
    this.value /= value;
    return this;
  }
}

let num = new Number(10);
num.add(5).sub(3).mul(2).div(8);
console.log(num.value);
```
`class Number {
  constructor(value) {
    this.value = value;
  }
  add(value) {
    this.value += value;
    return this;
  }
  sub(value) {
    this.value -= value;
    return this;
  }
  mul(value) {
    this.value *= value;
    return this;
  }
  div(value) {
    this.value /= value;
    return this;
  }
}

let num = new Number(10);
num.add(5).sub(3).mul(2).div(8);
console.log(num.value);` Trong đoạn code trên, mình đã triển khai các phương thức theo Method Chaining. Nhờ vậy mà mình có thể gọi liên tiếp các phương thức trên cùng 1 dòng.
Cách thực hiện ở đây rất đơn giản là: mình chỉ cần thêmreturn thisvào cuối mỗi phương thức.
Thisở đây đại diện choobjectđược tạo ra (num) sau khi sử dụng từ khóanew.
Rất dễ hiểu phải không bạn?"
363,Method chaining trong Javascript,Kết luận,"Trên đây là những thông tin cơ bản về kĩ thuật Method Chaining. Để hiểu thêm về kĩ thuật này, bạn có thể đọc thêm trong các bài viết ở phần tham khảo dưới đây."
364,Một số lỗi khi sử dụng Strict mode JavaScript,Giới thiệu,"Trongbài viết trước, mình có đề cập tới việc sử dụng Strict mode trong JavaScript để giảm thiểu những lỗi ngớ ngẩn của lập trình viên khi lập trình JavaScript. Như đã hứa, mình sẽ đưa ra một số lỗi phổ biến khi sử dụng chế độ này."
365,Một số lỗi khi sử dụng Strict mode JavaScript,Sử dụng biến không khai báo,"Bình thường khi bạn đưa ra một biến mà không khai báo thì mặc định biến đó sẽ trở thành một thuộc tính của đối tượng global. Đối với browser thì đối tượng global đó chính làwindow.

```js
x = 10;
console.log(window.x);
// => 10
```
`x = 10;
console.log(window.x);
// => 10` Ở strict mode, bạn sẽ bị lỗix chưa được định nghĩa:Uncaught ReferenceError: x is not defined

```js
x = 10;
console.log(window.x);
// => Uncaught ReferenceError: x is not defined
```
`x = 10;
console.log(window.x);
// => Uncaught ReferenceError: x is not defined`"
366,Một số lỗi khi sử dụng Strict mode JavaScript,"Gán giá trị cho biến global, thuộc tính chỉ đọc, thuộc tính getter","Ở chế độ bình thường, việc gán giá trị cho biến Global như Infinity, NaN,... hay những thuộc tính chỉ đọc,... sẽ không có thông báo lỗi. Mặc dù việc gán giá trị này là hoàn toàn sai và không có ý nghĩa.

```js
var undefined = 5;
console.log(undefined);
// => undefined

var NaN = 10;
console.log(NaN);
// => NaN

var Infinity = 11;
console.log(Infinity);
// => Infinity

var obj = {};
Object.defineProperty(obj, ""x"", { value: 42, writable: false });
obj.x = 9;
console.log(obj.x);
// => 42

var obj = {
  get x() {
    return 15;
  },
};
obj.x = 10;
console.log(obj.x);
// => 15

var fixed = {};
Object.preventExtensions(fixed);
fixed.x = 10;
console.log(fixed.x);
// => undefined
```
`var undefined = 5;
console.log(undefined);
// => undefined

var NaN = 10;
console.log(NaN);
// => NaN

var Infinity = 11;
console.log(Infinity);
// => Infinity

var obj = {};
Object.defineProperty(obj, ""x"", { value: 42, writable: false });
obj.x = 9;
console.log(obj.x);
// => 42

var obj = {
  get x() {
    return 15;
  },
};
obj.x = 10;
console.log(obj.x);
// => 15

var fixed = {};
Object.preventExtensions(fixed);
fixed.x = 10;
console.log(fixed.x);
// => undefined` Khi ở strict mode, bạn chắc chắn sẽ nhận được lỗi như:

```js
- Uncaught TypeError: Cannot assign to read only property 'undefined' of object '#<Window>'
- Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#<Window>'
- Uncaught TypeError: Cannot assign to read only property 'Infinity' of object '#<Window>'
- Uncaught TypeError: Cannot assign to read only property 'x' of object '#<Object>'
- Uncaught TypeError: Cannot set property x of #<Object> which has only a getter
- Uncaught TypeError: Cannot add property x, object is not extensible

  var undefined = 5;
  console.log(undefined);
  // => Uncaught TypeError:
  // Cannot assign to read only property 'undefined' of object '#<Window>'

  var NaN = 10;
  console.log(NaN);
  // => Uncaught TypeError:
  // Cannot assign to read only property 'NaN' of object '#<Window>'

  var Infinity = 11;
  console.log(Infinity);
  // => Uncaught TypeError:
  // Cannot assign to read only property 'Infinity' of object '#<Window>'

  var obj = {};
  Object.defineProperty(obj, ""x"", { value: 42, writable: false });
  obj.x = 9;
  console.log(obj.x);
  // => Uncaught TypeError:
  // Cannot assign to read only property 'x' of object '#<Object>'

  var obj = {
  get x() {
  return 15;
  },
  };
  obj.x = 10;
  console.log(obj.x);
  // => Uncaught TypeError:
  // Cannot set property x of #<Object> which has only a getter

  var fixed = {};
  Object.preventExtensions(fixed);
  fixed.x = 10;
  console.log(fixed.x);
  // => Uncaught TypeError:
  // Cannot add property x, object is not extensible
```
`- Uncaught TypeError: Cannot assign to read only property 'undefined' of object '#<Window>'
- Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#<Window>'
- Uncaught TypeError: Cannot assign to read only property 'Infinity' of object '#<Window>'
- Uncaught TypeError: Cannot assign to read only property 'x' of object '#<Object>'
- Uncaught TypeError: Cannot set property x of #<Object> which has only a getter
- Uncaught TypeError: Cannot add property x, object is not extensible

  var undefined = 5;
  console.log(undefined);
  // => Uncaught TypeError:
  // Cannot assign to read only property 'undefined' of object '#<Window>'

  var NaN = 10;
  console.log(NaN);
  // => Uncaught TypeError:
  // Cannot assign to read only property 'NaN' of object '#<Window>'

  var Infinity = 11;
  console.log(Infinity);
  // => Uncaught TypeError:
  // Cannot assign to read only property 'Infinity' of object '#<Window>'

  var obj = {};
  Object.defineProperty(obj, ""x"", { value: 42, writable: false });
  obj.x = 9;
  console.log(obj.x);
  // => Uncaught TypeError:
  // Cannot assign to read only property 'x' of object '#<Object>'

  var obj = {
  get x() {
  return 15;
  },
  };
  obj.x = 10;
  console.log(obj.x);
  // => Uncaught TypeError:
  // Cannot set property x of #<Object> which has only a getter

  var fixed = {};
  Object.preventExtensions(fixed);
  fixed.x = 10;
  console.log(fixed.x);
  // => Uncaught TypeError:
  // Cannot add property x, object is not extensible`"
367,Một số lỗi khi sử dụng Strict mode JavaScript,Xoá thuộc tính của đối tượng Global,"Bình thường, bạn sẽ không thể xoá thuộc tính của một đối tượng Global, mặc dù không có thông báo lỗi nào. Khi ở strict mode, bạn sẽ bị lỗi nếu cố gắng xoá một thuộc tính của đối tượng Global:
Ví dụ: Uncaught TypeError: Cannot delete property 'prototype' of function Object() { [native code] }

```js
""use strict"";
delete Object.prototype;
// Uncaught TypeError:
// Cannot delete property 'prototype' of function Object() { [native code] }
```
`""use strict"";
delete Object.prototype;
// Uncaught TypeError:
// Cannot delete property 'prototype' of function Object() { [native code] }`"
368,Một số lỗi khi sử dụng Strict mode JavaScript,Tên tham số trùng nhau ở khai báo hàm,"Strict mode JavaScript yêu cầu các tham số phải có tên khác nhau. Ngược lại thì bạn sẽ gặp lỗi:
Uncaught SyntaxError: Duplicate parameter name not allowed in this context

```js
function sum(a, a, c) {
  ""use strict"";
  return a + b + c;
}
// => Uncaught SyntaxError:
// Duplicate parameter name not allowed in this context
```
`function sum(a, a, c) {
  ""use strict"";
  return a + b + c;
}
// => Uncaught SyntaxError:
// Duplicate parameter name not allowed in this context`"
369,Một số lỗi khi sử dụng Strict mode JavaScript,Thêm thuộc tính cho những giá trị nguyên thuỷ,"Như bạn đã biết, giá trị nguyên thuỷ bao gồm:number, string, boolean. Ngược lại, bạn sẽ bị lỗi như:

```js
- Uncaught TypeError: Cannot create property 'true' on boolean 'false'
- Uncaught TypeError: Cannot create property 'sailing' on number '14'
- Uncaught TypeError: Cannot create property 'you' on string 'with'

  ""use strict"";
  false.true = false;
  // => Uncaught TypeError:
  // Cannot create property 'true' on boolean 'false'

  (14).sailing = ""home"";
  // => Uncaught TypeError:
  // Cannot create property 'sailing' on number '14'

  ""with"".you = ""far away"";
  // => Uncaught TypeError:
  // Cannot create property 'you' on string 'with'
```
`- Uncaught TypeError: Cannot create property 'true' on boolean 'false'
- Uncaught TypeError: Cannot create property 'sailing' on number '14'
- Uncaught TypeError: Cannot create property 'you' on string 'with'

  ""use strict"";
  false.true = false;
  // => Uncaught TypeError:
  // Cannot create property 'true' on boolean 'false'

  (14).sailing = ""home"";
  // => Uncaught TypeError:
  // Cannot create property 'sailing' on number '14'

  ""with"".you = ""far away"";
  // => Uncaught TypeError:
  // Cannot create property 'you' on string 'with'`"
370,Một số lỗi khi sử dụng Strict mode JavaScript,Xoá một biến thông thường ở Strict mode trong JavaScript,"Strict mode cấm bạn xoá tên biến. Ngược lại, bạn sẽ bị lỗi là:
Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.

```js
""use strict"";

var x = 10;
delete x;
// => Uncaught SyntaxError:
// Delete of an unqualified identifier in strict mode.
```
`""use strict"";

var x = 10;
delete x;
// => Uncaught SyntaxError:
// Delete of an unqualified identifier in strict mode.`"
371,Một số lỗi khi sử dụng Strict mode JavaScript,Đặt tên biến trùng với từ dự trữ,"Ngoài từ khoá,JavaScriptquy định danh sách những từ dự trữ - những từ sẽ được sử dụng làm từ khoá ở những phiên bản tiếp theo, như: implements, interface, let, package, private, protected, public, static, và yield.
Do đó, strict mode nghiêm cấm bạn đặt tên biến số trùng với những từ này. Nếu bạn đặt tên biến trùng với từ dự trữ thì bạn sẽ bị lỗi như sau:

```js
Uncaught SyntaxError: Unexpected strict mode reserved word

""use strict"";
var implements = 10;
// => Uncaught SyntaxError: Unexpected strict mode
```
`Uncaught SyntaxError: Unexpected strict mode reserved word

""use strict"";
var implements = 10;
// => Uncaught SyntaxError: Unexpected strict mode`"
372,Một số lỗi khi sử dụng Strict mode JavaScript,Kết luận,"Trên đây là một số lỗi thường gặp phải khi bạn sử dụng JavaScript strict mode. Nói vậy, không có nghĩa là mình khuyên bạn tránh sử dụng strict mode. Ngược lại, chế độ này giúp bạn dễ dàngphát hiện lỗi. Và đây là sự đảm bảo cho code bạn không bị xung đột với những phiên bản JavaScript mới hơn sau này.
Bài viết này sẽ dừng lại ở đây.
Xin chào và hẹn gặp lại bạn ởbài viết tiếp theo, thân ái!"
373,Module pattern trong JavaScript,Giới thiệu,"Module pattern là một loại pattern khá mạnh và được sử dụng rất phổ biến, với một số các đặc điểm sau:"
374,Module pattern trong JavaScript,Ví dụ sử dụng Module Pattern,"```js
var countModule = (function () {
  var count = 0;
  var log = function (funcName) {
    console.log(funcName, count);
  };
  return {
    increase: function () {
      count++;
      log(""increase"");
    },
    decrease: function () {
      count--;
      log(""decrease"");
    },
    reset: function () {
      count = 0;
      log(""reset"");
    },
  };
})();

// Usage:
countModule.increase(); // increase 1
countModule.increase(); // increase 2
countModule.decrease(); // increase 1
countModule.reset(); // reset 0
```
`var countModule = (function () {
  var count = 0;
  var log = function (funcName) {
    console.log(funcName, count);
  };
  return {
    increase: function () {
      count++;
      log(""increase"");
    },
    decrease: function () {
      count--;
      log(""decrease"");
    },
    reset: function () {
      count = 0;
      log(""reset"");
    },
  };
})();

// Usage:
countModule.increase(); // increase 1
countModule.increase(); // increase 2
countModule.decrease(); // increase 1
countModule.reset(); // reset 0` Ví dụ trên định nghĩa một module tên là:countModule. Có thể bạn sẽ thắc mắc về cú pháp sau:

```js
var countModule = (function () {})();
```
`var countModule = (function () {})();` Thực chất, đoạn code trên có thể tách ra làm 2 phần: Khai báo hàm và gọi hàm.

```js
// Khai báo hàm
var funcModule = function () {};
// Gọi hàm
var countModule = funcModule();
```
`// Khai báo hàm
var funcModule = function () {};
// Gọi hàm
var countModule = funcModule();` Do đó, nếu muốn truyền tham số vào function (chẳng hạn nhưjQuery) thì bạn có thể viết như sau:

```js
var countModule = (function (jQ) {})(jQuery);
```
`var countModule = (function (jQ) {})(jQuery);` Theo cách phân tích trên, thực chấtcountModulelà thành phầnreturncủa function - dạngobject({}). Do đó, ta chỉ có thể truy cập đến những thuộc tính bên trong object này là:increase, decrease, reset. Hay nói cách khác, những hàm số này thuộc dạngpublic.
Ngược lại, biến sốcount,logchỉ truy cập được ở trong hàm số trên, nên thuộc dạngprivate."
375,Module pattern trong JavaScript,Revealing Module Pattern,"Module Patterncó một nhược điểm là khó theo dõi các phương thức được public. Sau đây là cách sử dụngRevealing Module Patternđể khắc phục nhược điểm này:

```js
var countModule = (function () {
  var count = 0;
  var log = function (funcName) {
    console.log(funcName, count);
  };
  function increaseFunc() {
    count++;
    log(""increase"");
  }
  function decreaseFunc() {
    count--;
    log(""decrease"");
  }
  function resetFunc() {
    count = 0;
    log(""reset"");
  }
  return {
    increase: increaseFunc,
    decrease: decreaseFunc,
    reset: resetFunc,
  };
})();

// Usage:
countModule.increase(); // increase 1
countModule.increase(); // increase 2
countModule.decrease(); // increase 1
countModule.reset(); // reset 0
```
`var countModule = (function () {
  var count = 0;
  var log = function (funcName) {
    console.log(funcName, count);
  };
  function increaseFunc() {
    count++;
    log(""increase"");
  }
  function decreaseFunc() {
    count--;
    log(""decrease"");
  }
  function resetFunc() {
    count = 0;
    log(""reset"");
  }
  return {
    increase: increaseFunc,
    decrease: decreaseFunc,
    reset: resetFunc,
  };
})();

// Usage:
countModule.increase(); // increase 1
countModule.increase(); // increase 2
countModule.decrease(); // increase 1
countModule.reset(); // reset 0` Bây giờ, ta có thể dễ dàng thấy rằngcountModulecó 3 phương thức được public là:increase, decrease, reset.
Hy vọng với sự giải thích ngắn gọn trên, bạn có thể hiểu và áp dụng được Module Pattern."
376,Một số biểu thức regex hay,Giới thiệu,"Trong bài viếttìm hiểu Regular Expression JavaScript, mình có giới thiệu với bạn về Regular Expression trong JavaScript rồi. Hy vọng qua bài viết đó, bạn đã biết và hiểu về các cú pháp cơ bản của RegExp. Còn trong trường hợp bạn vẫn chưa biết gì về nó, mình khuyên bạn nên quay lại bài viết kia để tìm hiểu về RegExp thật kỹ trước đã. Vì trong bài viết này, mình sẽ chỉ tổng hợp lại một số biểu thức chính quy RegExp hay mà mình sưu tầm được và sẽ không giải thích gì nhiều.
Trước khi đi vào nội dung chính của bài viết, mình sẽ tóm tắt lại một số kiến thức cơ bản về biểu thức chính quy RegExp để bạn tiện theo dõi:
`/abc/` `/\[abc\]` `/\[^abc\]` `/\[0-9\]/` `/x+/` `/x\*/` `/x?/` `/x{2, 4}/` `/(abc)/` `/a|b|c/` `/\\d/` `/\\w/` `/\\s/` `/./` `/\\b/` `/^/` `/$/` Bây giờ, mình bắt đầu vào nội dung chính nhé!
Regex:
/^[a-zA-Z]+$/;
`/^[a-zA-Z]+$/;` Test:

```js
const isAlpha = /^[a-zA-Z]+$/;
console.log(isAlpha.test(""javascript"")); // true
console.log(isAlpha.test(""JavaScript"")); // true
console.log(isAlpha.test(""2019"")); // false
console.log(isAlpha.test(""javascript2019"")); // false
console.log(isAlpha.test(""J@vascr!pt"")); // false
console.log(isAlpha.test(""java script"")); // false
console.log(isAlpha.test(""java-script"")); // false
console.log(isAlpha.test("""")); // false
```
`const isAlpha = /^[a-zA-Z]+$/;
console.log(isAlpha.test(""javascript"")); // true
console.log(isAlpha.test(""JavaScript"")); // true
console.log(isAlpha.test(""2019"")); // false
console.log(isAlpha.test(""javascript2019"")); // false
console.log(isAlpha.test(""J@vascr!pt"")); // false
console.log(isAlpha.test(""java script"")); // false
console.log(isAlpha.test(""java-script"")); // false
console.log(isAlpha.test("""")); // false` Regex:
/^\d+$/;
`/^\d+$/;` Test:

```js
const isNumeric = /^\d+$/;
console.log(isNumeric.test(""2019"")); // true
console.log(isNumeric.test(""javascript"")); // false
console.log(isNumeric.test(""JavaScript"")); // false
console.log(isNumeric.test(""20 19"")); // false
console.log(isNumeric.test(""javascript2019"")); // false
console.log(isNumeric.test(""J@vascr!pt"")); // false
console.log(isNumeric.test(""java script"")); // false
console.log(isNumeric.test(""java-script"")); // false
console.log(isNumeric.test("""")); // false
```
`const isNumeric = /^\d+$/;
console.log(isNumeric.test(""2019"")); // true
console.log(isNumeric.test(""javascript"")); // false
console.log(isNumeric.test(""JavaScript"")); // false
console.log(isNumeric.test(""20 19"")); // false
console.log(isNumeric.test(""javascript2019"")); // false
console.log(isNumeric.test(""J@vascr!pt"")); // false
console.log(isNumeric.test(""java script"")); // false
console.log(isNumeric.test(""java-script"")); // false
console.log(isNumeric.test("""")); // false` Regex:
/^[a-zA-Z0-9]+$/;
`/^[a-zA-Z0-9]+$/;` Test:

```js
const isNumeric = /^[a-zA-Z0-9]+$/;
console.log(isNumeric.test(""javascript"")); // true
console.log(isNumeric.test(""JavaScript"")); // true
console.log(isNumeric.test(""2019"")); // true
console.log(isNumeric.test(""javascript2019"")); // true
console.log(isNumeric.test(""20 19"")); // false
console.log(isNumeric.test(""J@vascr!pt"")); // false
console.log(isNumeric.test(""java script"")); // false
console.log(isNumeric.test(""java-script"")); // false
console.log(isNumeric.test("""")); // false
```
`const isNumeric = /^[a-zA-Z0-9]+$/;
console.log(isNumeric.test(""javascript"")); // true
console.log(isNumeric.test(""JavaScript"")); // true
console.log(isNumeric.test(""2019"")); // true
console.log(isNumeric.test(""javascript2019"")); // true
console.log(isNumeric.test(""20 19"")); // false
console.log(isNumeric.test(""J@vascr!pt"")); // false
console.log(isNumeric.test(""java script"")); // false
console.log(isNumeric.test(""java-script"")); // false
console.log(isNumeric.test("""")); // false`"
377,Một số biểu thức regex hay,Kiểm tra string là base64,"Regex:
/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
`/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;` Test:

```js
const isBase64 =
  /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
console.log(isBase64.test(""SomeStringObviouslyNotBase64Encoded..."")); // false
console.log(isBase64.test(""U29tZVN0cmluZ09idmlvdXNseU5vdEJhc2U2NEVuY29kZWQ="")); // true
```
`const isBase64 =
  /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
console.log(isBase64.test(""SomeStringObviouslyNotBase64Encoded..."")); // false
console.log(isBase64.test(""U29tZVN0cmluZ09idmlvdXNseU5vdEJhc2U2NEVuY29kZWQ="")); // true` Tham khảo:Determine if string is in base64 using JavaScript"
378,Một số biểu thức regex hay,Kiểm tra string là boolean,"Regex:
/^true|false$/;
`/^true|false$/;` Test:

```js
const isBoolean = /^true|false$/;
console.log(isBoolean.test(""true"")); // true
console.log(isBoolean.test(""false"")); // true
console.log(isBoolean.test(""TRUE"")); // false
console.log(isBoolean.test(""FAlse"")); // false
console.log(isBoolean.test(""abc"")); // false
console.log(isBoolean.test(""123"")); // false
console.log(isBoolean.test("""")); // false
```
`const isBoolean = /^true|false$/;
console.log(isBoolean.test(""true"")); // true
console.log(isBoolean.test(""false"")); // true
console.log(isBoolean.test(""TRUE"")); // false
console.log(isBoolean.test(""FAlse"")); // false
console.log(isBoolean.test(""abc"")); // false
console.log(isBoolean.test(""123"")); // false
console.log(isBoolean.test("""")); // false`"
379,Một số biểu thức regex hay,Kiểm tra string là số thập phân,"Regex:
/^[+-]?((\d+(\.\d*)?)|(\.\d+))$/;
`/^[+-]?((\d+(\.\d*)?)|(\.\d+))$/;` Test:

```js
const isDecimal = /^[+-]?((\d+(\.\d*)?)|(\.\d+))$/;
console.log(isDecimal.test(""123"")); // true
console.log(isDecimal.test(""23.45"")); // true
console.log(isDecimal.test(""34."")); // true
console.log(isDecimal.test("".45"")); // true
console.log(isDecimal.test(""-123"")); // true
console.log(isDecimal.test(""-273.15"")); // true
console.log(isDecimal.test(""-42."")); // true
console.log(isDecimal.test(""-.45"")); // true
console.log(isDecimal.test(""+516"")); // true
console.log(isDecimal.test(""+9.8"")); // true
console.log(isDecimal.test(""+2."")); // true
console.log(isDecimal.test(""+.5"")); // true
console.log(isDecimal.test(""."")); // false
console.log(isDecimal.test(""-."")); // false
console.log(isDecimal.test(""+."")); // false
console.log(isDecimal.test(""*12.34"")); // false
console.log(isDecimal.test(""abc"")); // false
console.log(isDecimal.test("""")); // false
```
`const isDecimal = /^[+-]?((\d+(\.\d*)?)|(\.\d+))$/;
console.log(isDecimal.test(""123"")); // true
console.log(isDecimal.test(""23.45"")); // true
console.log(isDecimal.test(""34."")); // true
console.log(isDecimal.test("".45"")); // true
console.log(isDecimal.test(""-123"")); // true
console.log(isDecimal.test(""-273.15"")); // true
console.log(isDecimal.test(""-42."")); // true
console.log(isDecimal.test(""-.45"")); // true
console.log(isDecimal.test(""+516"")); // true
console.log(isDecimal.test(""+9.8"")); // true
console.log(isDecimal.test(""+2."")); // true
console.log(isDecimal.test(""+.5"")); // true
console.log(isDecimal.test(""."")); // false
console.log(isDecimal.test(""-."")); // false
console.log(isDecimal.test(""+."")); // false
console.log(isDecimal.test(""*12.34"")); // false
console.log(isDecimal.test(""abc"")); // false
console.log(isDecimal.test("""")); // false` Tham khảo:Decimal number regular expression, where digit after decimal is optional"
380,Một số biểu thức regex hay,Kiểm tra string là số Hexadecimal,"Regex:

```js
/^[0-9a-fA-F]+$/;
```
`/^[0-9a-fA-F]+$/;` Test:

```js
const isHexaDecimal = /^[0-9a-fA-F]+$/;
console.log(isHexaDecimal.test(""012"")); // true
console.log(isHexaDecimal.test(""A23A1"")); // true
console.log(isHexaDecimal.test(""1AFFa1"")); // true
console.log(isHexaDecimal.test(""2f43"")); // true
console.log(isHexaDecimal.test(""12308"")); // true
console.log(isHexaDecimal.test(""1ab6"")); // true
console.log(isHexaDecimal.test(""1a2b4c5d6e7f"")); // true
console.log(isHexaDecimal.test(""abcdef"")); // true
console.log(isHexaDecimal.test(""xyz"")); // false
console.log(isHexaDecimal.test(""1.23"")); // false
console.log(isHexaDecimal.test("".09"")); // false
console.log(isHexaDecimal.test(""#F0h"")); // false
console.log(isHexaDecimal.test(""#1234567"")); // false
```
`const isHexaDecimal = /^[0-9a-fA-F]+$/;
console.log(isHexaDecimal.test(""012"")); // true
console.log(isHexaDecimal.test(""A23A1"")); // true
console.log(isHexaDecimal.test(""1AFFa1"")); // true
console.log(isHexaDecimal.test(""2f43"")); // true
console.log(isHexaDecimal.test(""12308"")); // true
console.log(isHexaDecimal.test(""1ab6"")); // true
console.log(isHexaDecimal.test(""1a2b4c5d6e7f"")); // true
console.log(isHexaDecimal.test(""abcdef"")); // true
console.log(isHexaDecimal.test(""xyz"")); // false
console.log(isHexaDecimal.test(""1.23"")); // false
console.log(isHexaDecimal.test("".09"")); // false
console.log(isHexaDecimal.test(""#F0h"")); // false
console.log(isHexaDecimal.test(""#1234567"")); // false` Tham khảo:Verify if String is hexadecimal"
381,Một số biểu thức regex hay,Kiểm tra string là mã màu dạng hexa,"Regex:
/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
`/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;` Test:

```js
const isHexColor = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
console.log(isHexColor.test(""#1f1f1F"")); // true
console.log(isHexColor.test(""#AFAFAF"")); // true
console.log(isHexColor.test(""#1AFFa1"")); // true
console.log(isHexColor.test(""#222fff"")); // true
console.log(isHexColor.test(""#F00"")); // true
console.log(isHexColor.test(""123456"")); // false
console.log(isHexColor.test(""#afafah"")); // false
console.log(isHexColor.test(""#123abce"")); // false
console.log(isHexColor.test(""aFaE3f"")); // false
console.log(isHexColor.test(""F00"")); // false
console.log(isHexColor.test(""#afaf"")); // false
console.log(isHexColor.test(""#F0h"")); // false
console.log(isHexColor.test(""#1234567"")); // false
```
`const isHexColor = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
console.log(isHexColor.test(""#1f1f1F"")); // true
console.log(isHexColor.test(""#AFAFAF"")); // true
console.log(isHexColor.test(""#1AFFa1"")); // true
console.log(isHexColor.test(""#222fff"")); // true
console.log(isHexColor.test(""#F00"")); // true
console.log(isHexColor.test(""123456"")); // false
console.log(isHexColor.test(""#afafah"")); // false
console.log(isHexColor.test(""#123abce"")); // false
console.log(isHexColor.test(""aFaE3f"")); // false
console.log(isHexColor.test(""F00"")); // false
console.log(isHexColor.test(""#afaf"")); // false
console.log(isHexColor.test(""#F0h"")); // false
console.log(isHexColor.test(""#1234567"")); // false` Tham khảo:How to validate Hex color code with regular expression"
382,Một số biểu thức regex hay,Kiểm tra string là mã màu RGB,"Regex:
/^rgb\(((\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*),){2}(\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*)\)$/;
`/^rgb\(((\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*),){2}(\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*)\)$/;` Test:

```js
const isRGBColor =
  /^rgb\(((\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*),){2}(\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*)\)$/;
console.log(isRGBColor.test(""rgb(0, 0, 0)"")); // true
console.log(isRGBColor.test(""rgb(0, 15, 120)"")); // true
console.log(isRGBColor.test(""rgb(10, 1, 230)"")); // true
console.log(isRGBColor.test(""rgb(255, 15, 9)"")); // true
console.log(isRGBColor.test(""rgb(255, 255, 255)"")); // true
console.log(isRGBColor.test(""rgb(255,15,120)"")); // true
console.log(isRGBColor.test(""rgb( 255, 15,  120 )"")); // true
console.log(isRGBColor.test(""rgc(255,15,120)"")); // false
console.log(isRGBColor.test(""rgb[255,15,120]"")); // false
console.log(isRGBColor.test(""rgb(255-15-120)"")); // false
console.log(isRGBColor.test(""rgb( 255,5,120,)"")); // false
console.log(isRGBColor.test(""rgb(355, 5, 120)"")); // false
console.log(isRGBColor.test(""rgb(155, 405, 120)"")); // false
console.log(isRGBColor.test(""rgb(5, 5, 520)"")); // false
console.log(isRGBColor.test(""rgb(255,,120)"")); // false
console.log(isRGBColor.test(""rgb(03, 15, 120)"")); // false
```
`const isRGBColor =
  /^rgb\(((\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*),){2}(\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*)\)$/;
console.log(isRGBColor.test(""rgb(0, 0, 0)"")); // true
console.log(isRGBColor.test(""rgb(0, 15, 120)"")); // true
console.log(isRGBColor.test(""rgb(10, 1, 230)"")); // true
console.log(isRGBColor.test(""rgb(255, 15, 9)"")); // true
console.log(isRGBColor.test(""rgb(255, 255, 255)"")); // true
console.log(isRGBColor.test(""rgb(255,15,120)"")); // true
console.log(isRGBColor.test(""rgb( 255, 15,  120 )"")); // true
console.log(isRGBColor.test(""rgc(255,15,120)"")); // false
console.log(isRGBColor.test(""rgb[255,15,120]"")); // false
console.log(isRGBColor.test(""rgb(255-15-120)"")); // false
console.log(isRGBColor.test(""rgb( 255,5,120,)"")); // false
console.log(isRGBColor.test(""rgb(355, 5, 120)"")); // false
console.log(isRGBColor.test(""rgb(155, 405, 120)"")); // false
console.log(isRGBColor.test(""rgb(5, 5, 520)"")); // false
console.log(isRGBColor.test(""rgb(255,,120)"")); // false
console.log(isRGBColor.test(""rgb(03, 15, 120)"")); // false`"
383,Một số biểu thức regex hay,Kiểm tra string là mã màu RGBA,"Regex:
/^rgba\(((\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*),){3}(\s*(1(\.0+)?|0?\.\d+)\s*)\)$/;
`/^rgba\(((\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*),){3}(\s*(1(\.0+)?|0?\.\d+)\s*)\)$/;` Test:

```js
const isRGBAColor =
  /^rgba\(((\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*),){3}(\s*(1(\.0+)?|0?\.\d+)\s*)\)$/;
console.log(isRGBAColor.test(""rgba(0, 0, 0, 1)"")); // true
console.log(isRGBAColor.test(""rgba(0, 15, 120, 1.0)"")); // true
console.log(isRGBAColor.test(""rgba(10, 1, 230, 1.00)"")); // true
console.log(isRGBAColor.test(""rgba(255, 15, 9, 0.3)"")); // true
console.log(isRGBAColor.test(""rgba(255, 255, 255, .555)"")); // true
console.log(isRGBAColor.test(""rgba(255,15,120,0.4)"")); // true
console.log(isRGBAColor.test(""rgba( 255, 15,  120 , 1.0)"")); // true
console.log(isRGBAColor.test(""rgbd(255,15,120,1.0)"")); // false
console.log(isRGBAColor.test(""rgba[255,15,120,1.0]"")); // false
console.log(isRGBAColor.test(""rgba(255-15-120-1.0)"")); // false
console.log(isRGBAColor.test(""rgba( 255,5,120,1,)"")); // false
console.log(isRGBAColor.test(""rgba(155, 5, 120,2)"")); // false
console.log(isRGBAColor.test(""rgba(155, 405, 120, 0.3)"")); // false
console.log(isRGBAColor.test(""rgba(5, 5, 520, 0.4)"")); // false
console.log(isRGBAColor.test(""rgba(255,,120, 1)"")); // false
console.log(isRGBAColor.test(""rgba(03, 15, 120, 0.5)"")); // false
```
`const isRGBAColor =
  /^rgba\(((\s*(\d|[1-9]\d|1\d\d|2[0-4][0-9]|25[0-5])\s*),){3}(\s*(1(\.0+)?|0?\.\d+)\s*)\)$/;
console.log(isRGBAColor.test(""rgba(0, 0, 0, 1)"")); // true
console.log(isRGBAColor.test(""rgba(0, 15, 120, 1.0)"")); // true
console.log(isRGBAColor.test(""rgba(10, 1, 230, 1.00)"")); // true
console.log(isRGBAColor.test(""rgba(255, 15, 9, 0.3)"")); // true
console.log(isRGBAColor.test(""rgba(255, 255, 255, .555)"")); // true
console.log(isRGBAColor.test(""rgba(255,15,120,0.4)"")); // true
console.log(isRGBAColor.test(""rgba( 255, 15,  120 , 1.0)"")); // true
console.log(isRGBAColor.test(""rgbd(255,15,120,1.0)"")); // false
console.log(isRGBAColor.test(""rgba[255,15,120,1.0]"")); // false
console.log(isRGBAColor.test(""rgba(255-15-120-1.0)"")); // false
console.log(isRGBAColor.test(""rgba( 255,5,120,1,)"")); // false
console.log(isRGBAColor.test(""rgba(155, 5, 120,2)"")); // false
console.log(isRGBAColor.test(""rgba(155, 405, 120, 0.3)"")); // false
console.log(isRGBAColor.test(""rgba(5, 5, 520, 0.4)"")); // false
console.log(isRGBAColor.test(""rgba(255,,120, 1)"")); // false
console.log(isRGBAColor.test(""rgba(03, 15, 120, 0.5)"")); // false`"
384,Một số biểu thức regex hay,Kiểm tra string là email,"Regex:
/^[a-z0-9!#$%&'*+/=?^_{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_{|}~-]+)_@(?:[a-z0-9](?:[a-z0-9-]_[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
`/^[a-z0-9!#$%&'*+/=?^_` `{|}~-]+)_@(?:[a-z0-9](?:[a-z0-9-]_[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;` Test:

```js
const isEmail =
  /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
console.log(isEmail.test(""123"")); // false
console.log(isEmail.test(""email"")); // false
console.log(isEmail.test(""lam@hotmail"")); // false
console.log(isEmail.test(""@lpv@yahoo"")); // false
console.log(isEmail.test(""+admin@test"")); // false
console.log(isEmail.test(""editer@dm.vn_"")); // false
console.log(isEmail.test(""lampv@gmail.com"")); // true
console.log(isEmail.test(""-lamp@mail.co"")); // true
console.log(isEmail.test(""LM.pv666@domain.vn"")); // true
console.log(isEmail.test(""124la@test.com"")); // true
console.log(isEmail.test(""+Admin@test.io"")); // true
console.log(isEmail.test(""user@test.com.vn"")); // true
console.log(isEmail.test(""lam-pv@js.vn"")); // true
```
`const isEmail =
  /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
console.log(isEmail.test(""123"")); // false
console.log(isEmail.test(""email"")); // false
console.log(isEmail.test(""lam@hotmail"")); // false
console.log(isEmail.test(""@lpv@yahoo"")); // false
console.log(isEmail.test(""+admin@test"")); // false
console.log(isEmail.test(""editer@dm.vn_"")); // false
console.log(isEmail.test(""lampv@gmail.com"")); // true
console.log(isEmail.test(""-lamp@mail.co"")); // true
console.log(isEmail.test(""LM.pv666@domain.vn"")); // true
console.log(isEmail.test(""124la@test.com"")); // true
console.log(isEmail.test(""+Admin@test.io"")); // true
console.log(isEmail.test(""user@test.com.vn"")); // true
console.log(isEmail.test(""lam-pv@js.vn"")); // true` Tham khảo:How to validate an email address in JavaScript?"
385,Một số biểu thức regex hay,Kiểm tra string là IPv4,"Regex:
/^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
`/^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;` Test:

```js
const isIPv4 =
  /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
console.log(isIPv4.test(""255.255.255.255"")); // true
console.log(isIPv4.test(""0.0.0.0"")); // true
console.log(isIPv4.test(""0.12.34.56"")); // true
console.log(isIPv4.test(""255.0.0.255"")); // true
console.log(isIPv4.test(""12.34.56.78"")); // true
console.log(isIPv4.test(""02.34.56.78"")); // false
console.log(isIPv4.test(""12.04.56.78"")); // false
console.log(isIPv4.test(""12.34.06.78"")); // false
console.log(isIPv4.test(""12.34.56.08"")); // false
console.log(isIPv4.test(""12.34.56.055"")); // false
console.log(isIPv4.test(""12..34.56.0"")); // false
console.log(isIPv4.test(""ab.ab.ab.ab"")); // false
console.log(isIPv4.test("".255.255.23"")); // false
console.log(isIPv4.test(""11.11.0.256"")); // false
console.log(isIPv4.test(""1000.0.0.00"")); // false
console.log(isIPv4.test(""255.255.255.00"")); // false
console.log(isIPv4.test(""12.34.56.78."")); // false
console.log(isIPv4.test(""111111111111"")); // false
```
`const isIPv4 =
  /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
console.log(isIPv4.test(""255.255.255.255"")); // true
console.log(isIPv4.test(""0.0.0.0"")); // true
console.log(isIPv4.test(""0.12.34.56"")); // true
console.log(isIPv4.test(""255.0.0.255"")); // true
console.log(isIPv4.test(""12.34.56.78"")); // true
console.log(isIPv4.test(""02.34.56.78"")); // false
console.log(isIPv4.test(""12.04.56.78"")); // false
console.log(isIPv4.test(""12.34.06.78"")); // false
console.log(isIPv4.test(""12.34.56.08"")); // false
console.log(isIPv4.test(""12.34.56.055"")); // false
console.log(isIPv4.test(""12..34.56.0"")); // false
console.log(isIPv4.test(""ab.ab.ab.ab"")); // false
console.log(isIPv4.test("".255.255.23"")); // false
console.log(isIPv4.test(""11.11.0.256"")); // false
console.log(isIPv4.test(""1000.0.0.00"")); // false
console.log(isIPv4.test(""255.255.255.00"")); // false
console.log(isIPv4.test(""12.34.56.78."")); // false
console.log(isIPv4.test(""111111111111"")); // false` Tham khảo:IP v4 validation REGEX"
386,Một số biểu thức regex hay,Check string là địa chỉ MAC,"Regex:
/^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;
`/^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;` Test:

```js
const isMACAddress = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;
console.log(isMACAddress.test(""3D:F2:C9:A6:B3:4F"")); // true
console.log(isMACAddress.test(""3d:f2:c9:a6:b3:4f"")); // true
console.log(isMACAddress.test(""3D-F2-C9-A6-B3-4F"")); // true
console.log(isMACAddress.test(""3d-f2-c9-a6-b3-4F"")); // true
console.log(isMACAddress.test(""d3-2f-9c-6a-3b-f4"")); // true
console.log(isMACAddress.test(""00-00-00-00-00-00"")); // true
console.log(isMACAddress.test(""3D:F2-C9:A6-B3:4F"")); // true
console.log(isMACAddress.test(""99:99:99:99:99:99"")); // true
console.log(isMACAddress.test(""0:0:0:0:0:0"")); // false
console.log(isMACAddress.test(""d33-2ff-9c4-6aa-3b4-b56"")); // false
console.log(isMACAddress.test(""qw:er:ty:ui:op:as"")); // false
console.log(isMACAddress.test(""3A.FC.C0.B6.A8.45"")); // false
console.log(isMACAddress.test(""3A-FC-C0-B6-A9"")); // false
console.log(isMACAddress.test(""d3-2f-9c-6a-3b-f4-b5"")); // false
```
`const isMACAddress = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;
console.log(isMACAddress.test(""3D:F2:C9:A6:B3:4F"")); // true
console.log(isMACAddress.test(""3d:f2:c9:a6:b3:4f"")); // true
console.log(isMACAddress.test(""3D-F2-C9-A6-B3-4F"")); // true
console.log(isMACAddress.test(""3d-f2-c9-a6-b3-4F"")); // true
console.log(isMACAddress.test(""d3-2f-9c-6a-3b-f4"")); // true
console.log(isMACAddress.test(""00-00-00-00-00-00"")); // true
console.log(isMACAddress.test(""3D:F2-C9:A6-B3:4F"")); // true
console.log(isMACAddress.test(""99:99:99:99:99:99"")); // true
console.log(isMACAddress.test(""0:0:0:0:0:0"")); // false
console.log(isMACAddress.test(""d33-2ff-9c4-6aa-3b4-b56"")); // false
console.log(isMACAddress.test(""qw:er:ty:ui:op:as"")); // false
console.log(isMACAddress.test(""3A.FC.C0.B6.A8.45"")); // false
console.log(isMACAddress.test(""3A-FC-C0-B6-A9"")); // false
console.log(isMACAddress.test(""d3-2f-9c-6a-3b-f4-b5"")); // false` Tham khảo:What is a regular expression for a MAC Address?"
387,Một số biểu thức regex hay,Kiểm tra string là MD5,"Regex:
/^[a-f0-9]{32}$/;
`/^[a-f0-9]{32}$/;` Test:

```js
const isMD5Format = /^[a-f0-9]{32}$/;
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bd987"")); // true
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bd9878"")); // false
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bd98"")); // false
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bd9.8"")); // false
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bdxyz"")); // false
```
`const isMD5Format = /^[a-f0-9]{32}$/;
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bd987"")); // true
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bd9878"")); // false
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bd98"")); // false
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bd9.8"")); // false
console.log(isMD5Format.test(""00236a2ae558018ed13b5222ef1bdxyz"")); // false` Tham khảo:Regex to match md5 hashes"
388,Một số biểu thức regex hay,Kiểm tra string là số điện thoại Việt Nam,"Phần này mình kiểm tra một string nhập vào là số điện thoại di động 10 số ở Việt Nam (sau khi đã chuyển đổi từ 11 số về 10 số).
Còn về phần test thì có khá nhiều trường hợp nên mình không thể viết hết trong bài này được. Do đó, khi sử dụng bạn cần kiểm thử lại độ chính xác với những test case của bạn nhé.
Regex:
/^(0|\+84)(\s|\.)?((3[2-9])|(5[689])|(7[06-9])|(8[1-689])|(9[0-46-9]))(\d)(\s|\.)?(\d{3})(\s|\.)?(\d{3})$/
`/^(0|\+84)(\s|\.)?((3[2-9])|(5[689])|(7[06-9])|(8[1-689])|(9[0-46-9]))(\d)(\s|\.)?(\d{3})(\s|\.)?(\d{3})$/` Test:

```js
const isVNPhoneMobile =
  /^(0|\+84)(\s|\.)?((3[2-9])|(5[689])|(7[06-9])|(8[1-689])|(9[0-46-9]))(\d)(\s|\.)?(\d{3})(\s|\.)?(\d{3})$/;

console.log(isVNPhoneMobile.test(""0866888999"")); // true - Viettel
console.log(isVNPhoneMobile.test(""0.866.888.999"")); // true
console.log(isVNPhoneMobile.test(""+84.866.888.999"")); // true
console.log(isVNPhoneMobile.test(""0 866 888 999"")); // true
console.log(isVNPhoneMobile.test(""0866 888 999"")); // true
console.log(isVNPhoneMobile.test(""+84 866 888 999"")); // true
console.log(isVNPhoneMobile.test(""0966 888 999"")); // true
console.log(isVNPhoneMobile.test(""0977 888 999"")); // true
console.log(isVNPhoneMobile.test(""0988 888 999"")); // true
console.log(isVNPhoneMobile.test(""0322 888 999"")); // true
console.log(isVNPhoneMobile.test(""0333 888 999"")); // true
console.log(isVNPhoneMobile.test(""0344 888 999"")); // true
console.log(isVNPhoneMobile.test(""0355 888 999"")); // true
console.log(isVNPhoneMobile.test(""0366 888 999"")); // true
console.log(isVNPhoneMobile.test(""0377 888 999"")); // true
console.log(isVNPhoneMobile.test(""0388 888 999"")); // true
console.log(isVNPhoneMobile.test(""0399 888 999"")); // true

console.log(isVNPhoneMobile.test(""0899 888 999"")); // true - Mobifone
console.log(isVNPhoneMobile.test(""0900 888 999"")); // true
console.log(isVNPhoneMobile.test(""0933 888 999"")); // true
console.log(isVNPhoneMobile.test(""0700 888 999"")); // true
console.log(isVNPhoneMobile.test(""0799 888 999"")); // true
console.log(isVNPhoneMobile.test(""0777 888 999"")); // true
console.log(isVNPhoneMobile.test(""0766 888 999"")); // true
console.log(isVNPhoneMobile.test(""0788 888 999"")); // true

console.log(isVNPhoneMobile.test(""0888 888 999"")); // true - Vinaphone
console.log(isVNPhoneMobile.test(""0911 888 999"")); // true
console.log(isVNPhoneMobile.test(""0944 888 999"")); // true
console.log(isVNPhoneMobile.test(""0833 888 999"")); // true
console.log(isVNPhoneMobile.test(""0844 888 999"")); // true
console.log(isVNPhoneMobile.test(""0855 888 999"")); // true
console.log(isVNPhoneMobile.test(""0811 888 999"")); // true
console.log(isVNPhoneMobile.test(""0822 888 999"")); // true

console.log(isVNPhoneMobile.test(""0922 888 999"")); // true - Vietnamobile
console.log(isVNPhoneMobile.test(""0566 888 999"")); // true
console.log(isVNPhoneMobile.test(""0588 888 999"")); // true

console.log(isVNPhoneMobile.test(""0999 888 999"")); // true - GMobile
console.log(isVNPhoneMobile.test(""0599 888 999"")); // true

console.log(isVNPhoneMobile.test(""1234 567 890"")); // false
console.log(isVNPhoneMobile.test(""0311 888 999"")); // false
console.log(isVNPhoneMobile.test(""0511 888 999"")); // false
console.log(isVNPhoneMobile.test(""0522 888 999"")); // false
console.log(isVNPhoneMobile.test(""0533 888 999"")); // false
console.log(isVNPhoneMobile.test(""0544 888 999"")); // false
console.log(isVNPhoneMobile.test(""0555 888 999"")); // false
console.log(isVNPhoneMobile.test(""0711 888 999"")); // false
console.log(isVNPhoneMobile.test(""0722 888 999"")); // false
console.log(isVNPhoneMobile.test(""0733 888 999"")); // false
console.log(isVNPhoneMobile.test(""0744 888 999"")); // false
console.log(isVNPhoneMobile.test(""0755 888 999"")); // false
console.log(isVNPhoneMobile.test(""0800 888 999"")); // false
console.log(isVNPhoneMobile.test(""0877 888 999"")); // false
console.log(isVNPhoneMobile.test(""0955 888 999"")); // false
```
`const isVNPhoneMobile =
  /^(0|\+84)(\s|\.)?((3[2-9])|(5[689])|(7[06-9])|(8[1-689])|(9[0-46-9]))(\d)(\s|\.)?(\d{3})(\s|\.)?(\d{3})$/;

console.log(isVNPhoneMobile.test(""0866888999"")); // true - Viettel
console.log(isVNPhoneMobile.test(""0.866.888.999"")); // true
console.log(isVNPhoneMobile.test(""+84.866.888.999"")); // true
console.log(isVNPhoneMobile.test(""0 866 888 999"")); // true
console.log(isVNPhoneMobile.test(""0866 888 999"")); // true
console.log(isVNPhoneMobile.test(""+84 866 888 999"")); // true
console.log(isVNPhoneMobile.test(""0966 888 999"")); // true
console.log(isVNPhoneMobile.test(""0977 888 999"")); // true
console.log(isVNPhoneMobile.test(""0988 888 999"")); // true
console.log(isVNPhoneMobile.test(""0322 888 999"")); // true
console.log(isVNPhoneMobile.test(""0333 888 999"")); // true
console.log(isVNPhoneMobile.test(""0344 888 999"")); // true
console.log(isVNPhoneMobile.test(""0355 888 999"")); // true
console.log(isVNPhoneMobile.test(""0366 888 999"")); // true
console.log(isVNPhoneMobile.test(""0377 888 999"")); // true
console.log(isVNPhoneMobile.test(""0388 888 999"")); // true
console.log(isVNPhoneMobile.test(""0399 888 999"")); // true

console.log(isVNPhoneMobile.test(""0899 888 999"")); // true - Mobifone
console.log(isVNPhoneMobile.test(""0900 888 999"")); // true
console.log(isVNPhoneMobile.test(""0933 888 999"")); // true
console.log(isVNPhoneMobile.test(""0700 888 999"")); // true
console.log(isVNPhoneMobile.test(""0799 888 999"")); // true
console.log(isVNPhoneMobile.test(""0777 888 999"")); // true
console.log(isVNPhoneMobile.test(""0766 888 999"")); // true
console.log(isVNPhoneMobile.test(""0788 888 999"")); // true

console.log(isVNPhoneMobile.test(""0888 888 999"")); // true - Vinaphone
console.log(isVNPhoneMobile.test(""0911 888 999"")); // true
console.log(isVNPhoneMobile.test(""0944 888 999"")); // true
console.log(isVNPhoneMobile.test(""0833 888 999"")); // true
console.log(isVNPhoneMobile.test(""0844 888 999"")); // true
console.log(isVNPhoneMobile.test(""0855 888 999"")); // true
console.log(isVNPhoneMobile.test(""0811 888 999"")); // true
console.log(isVNPhoneMobile.test(""0822 888 999"")); // true

console.log(isVNPhoneMobile.test(""0922 888 999"")); // true - Vietnamobile
console.log(isVNPhoneMobile.test(""0566 888 999"")); // true
console.log(isVNPhoneMobile.test(""0588 888 999"")); // true

console.log(isVNPhoneMobile.test(""0999 888 999"")); // true - GMobile
console.log(isVNPhoneMobile.test(""0599 888 999"")); // true

console.log(isVNPhoneMobile.test(""1234 567 890"")); // false
console.log(isVNPhoneMobile.test(""0311 888 999"")); // false
console.log(isVNPhoneMobile.test(""0511 888 999"")); // false
console.log(isVNPhoneMobile.test(""0522 888 999"")); // false
console.log(isVNPhoneMobile.test(""0533 888 999"")); // false
console.log(isVNPhoneMobile.test(""0544 888 999"")); // false
console.log(isVNPhoneMobile.test(""0555 888 999"")); // false
console.log(isVNPhoneMobile.test(""0711 888 999"")); // false
console.log(isVNPhoneMobile.test(""0722 888 999"")); // false
console.log(isVNPhoneMobile.test(""0733 888 999"")); // false
console.log(isVNPhoneMobile.test(""0744 888 999"")); // false
console.log(isVNPhoneMobile.test(""0755 888 999"")); // false
console.log(isVNPhoneMobile.test(""0800 888 999"")); // false
console.log(isVNPhoneMobile.test(""0877 888 999"")); // false
console.log(isVNPhoneMobile.test(""0955 888 999"")); // false`"
389,Một số biểu thức regex hay,Kiểm tra string là mật khẩu mạnh,"Theo bạn, thế nào là một mật khẩu mạnh? Ở đây, mình định nghĩa một mật khẩu mạnh là cái thỏa mãn những điều kiện sau đây:
Regex:
/^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*]).{8,}$/
`/^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*]).{8,}$/` Test:

```js
const isStrongPassword =
  /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*]).{8,}$/;

console.log(isStrongPassword.test(""Abcd!234"")); // true
console.log(isStrongPassword.test(""aBcd1@345"")); // true
console.log(isStrongPassword.test(""abCd12$4"")); // true
console.log(isStrongPassword.test(""AbcD1234%"")); // true
console.log(isStrongPassword.test(""@bcCd!234^"")); // true
console.log(isStrongPassword.test(""@B&d!234&*7890"")); // true
console.log(isStrongPassword.test(""12345678"")); // false
console.log(isStrongPassword.test(""!2345678"")); // false
console.log(isStrongPassword.test(""abcdefgh"")); // false
console.log(isStrongPassword.test(""AcD1%"")); // false
console.log(isStrongPassword.test(""ABCDEFGH"")); // false
```
`const isStrongPassword =
  /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*]).{8,}$/;

console.log(isStrongPassword.test(""Abcd!234"")); // true
console.log(isStrongPassword.test(""aBcd1@345"")); // true
console.log(isStrongPassword.test(""abCd12$4"")); // true
console.log(isStrongPassword.test(""AbcD1234%"")); // true
console.log(isStrongPassword.test(""@bcCd!234^"")); // true
console.log(isStrongPassword.test(""@B&d!234&*7890"")); // true
console.log(isStrongPassword.test(""12345678"")); // false
console.log(isStrongPassword.test(""!2345678"")); // false
console.log(isStrongPassword.test(""abcdefgh"")); // false
console.log(isStrongPassword.test(""AcD1%"")); // false
console.log(isStrongPassword.test(""ABCDEFGH"")); // false`"
390,Một số biểu thức regex hay,Lời kết,"Trên đây là những biểu thức chính quy RegExp hay, hữu ích mà mình đã sưu tầm được. Tuy nhiên, Regular Expression là một chủ đề khá phức tạp. Vì vậy, rất khó để có được những biểu thức chính quy RegExp chính xác một cách tuyệt đối.
Khi áp dụng vào project thực tế, bạn vẫn nên kiểm tra lại. Hoặc bạn kết hợp với các phương pháp khác để có được giải pháp chính xác nhất. Thay vì việc cứ copy-paste một solution nào đó trên mạng (kể cả của mình).
Cuối cùng, nếu có phần nào khó hiểu hoặc có bài toán nào bạn chưa giải quyết được, thì bạn cứ thoải mái chia sẻ với mình trong phần bình luận phía dưới nhé!
Xin chào và hẹn gặp lại, thân ái!"
391,Một số event trong Javascript,Giới thiệu,"Đối với mỗi trang web, đặc biệt là những trang web có sự tương tác với người dùng, việc xử lý sự kiện chuột và bàn phím là không thể thiếu. Vì vậy, bài viết này mình sẽ giới thiệu với bạn cách xử lý một số Event JavaScript cơ bản. Qua đó, bạn có thể tiếp tục tìm hiểu và làm chủ về JS event."
392,Một số event trong Javascript,Cách đăng ký và huỷ đăng ký Event JavaScript,"Ở bài viết trước vềDOM, bạn biết rằng mỗi phần tử trên trang web là một node. Và chúng ta có thể đăng ký nhận sự kiện cho mỗi node này bằng cách sử dụng phương thứcaddEventListenernhư sau:

```js
Node.addEventListener('tên sự kiện', hàm xử lý);
```
`Node.addEventListener('tên sự kiện', hàm xử lý);` Trong đó:
Chú ý: với một JS event, bạn có thể đăng ký nhiều hàm xử lý. Khi đó, hàm đăng ký trước sẽ được gọi trước.
Ví dụ:

```js
function func1() {
  console.log(""function 1"");
}
function func2() {
  console.log(""function 2"");
}
addEventListener(""click"", func1);
addEventListener(""click"", func2);
```
`function func1() {
  console.log(""function 1"");
}
function func2() {
  console.log(""function 2"");
}
addEventListener(""click"", func1);
addEventListener(""click"", func2);` Trong ví dụ trên, mình đã đăng kí sự kiệnclickcho documentvới hai hàm xử lý làfunc1vàfunc2. Từ nay, mỗi khi bạn click chuột trái vào trang web thì hàmfunc1sẽ được gọi trước, sau đó đến hàmfunc2.
Tương tự, để huỷ event trong JavaScript đã đăng ký, bạn có thể sử dụng phương thứcremoveEventListenernhư sau:

```js
Node.removeEventListener('tên sự kiện', hàm xử lý);
```
`Node.removeEventListener('tên sự kiện', hàm xử lý);` Ví dụ:

```js
function func1() {
  console.log(""function 1"");
}
function func2() {
  console.log(""function 2"");
}
addEventListener(""click"", func1);
addEventListener(""click"", func2);

removeEventListener(""click"", func1);
```
`function func1() {
  console.log(""function 1"");
}
function func2() {
  console.log(""function 2"");
}
addEventListener(""click"", func1);
addEventListener(""click"", func2);

removeEventListener(""click"", func1);` Tiếp theo ví dụ trên, nếu mình huỷ đăng ký sự kiệnclicktrêndocumentvới hàmfunc1bằng phương thức sau:

```js
removeEventListener(""click"", func1);
```
`removeEventListener(""click"", func1);` Thì bây giờ, mỗi khi bạn click chuột trái vào trang web, chỉ có hàmfunc2được gọi.
Bình thường để đăng ký event trong JavaScript cho nhiều node bạn có thể sử dụng phương thứcaddEventListenercho mỗi node. Tuy nhiên, bạn có thể chỉ cần sử dụng phương thức trên 1 lần và sử dụng thuộc tính target củađối tượngevent để phân biệt node được gọi.
Hãy xem ví dụ sau:

```js
<button>A</button>
<button>B</button>
<button>C</button>
<p>Hello</p>
<script>
  document.body.addEventListener(""click"", function (event) {
    if (event.target.nodeName == ""BUTTON"")
      console.log(""Clicked"", event.target.textContent);
    else if (event.target.nodeName == ""P"")
      console.log(""Paragraph clicked"", event.target.textContent);
  });
</script>
```
`<button>A</button>
<button>B</button>
<button>C</button>
<p>Hello</p>
<script>
  document.body.addEventListener(""click"", function (event) {
    if (event.target.nodeName == ""BUTTON"")
      console.log(""Clicked"", event.target.textContent);
    else if (event.target.nodeName == ""P"")
      console.log(""Paragraph clicked"", event.target.textContent);
  });
</script>` Trong ví dụ trên, mình chỉ cần gọi phương thứcaddEventListenermột lần. Sau đó, mình chỉ cần sử dụngevent.target.nodeNameđể biết được node nào thật sự đượcclick.
Một số Event JavaScript có sẵn hàm thực hiện mặc định. Ví dụ: khi bạn click vào một link thì bạn sẽ được chuyển hướng đến trang của link đó, hay khi bạn click chuột phải thì sẽ có một context menu hiện ra,...
Tuy nhiên, nếu bạn không muốn thực hiện những hàm mặc định đó thì bạn có thể sử dụng phương thứcpreventDefault.
Ví dụ:

```js
<a href=""https://developer.mozilla.org/"">MDN</a>
<script>
  var link = document.querySelector(""a"");
  link.addEventListener(""click"", function (event) {
    console.log(""Nope."");
    event.preventDefault();
  });
</script>
```
`<a href=""https://developer.mozilla.org/"">MDN</a>
<script>
  var link = document.querySelector(""a"");
  link.addEventListener(""click"", function (event) {
    console.log(""Nope."");
    event.preventDefault();
  });
</script>` Trong ví dụ trên, khi bạn nhấn vào link thì bạn sẽ không được chuyển đến tranghttps://developer.mozilla.org."
393,Một số event trong Javascript,Một số Event JavaScript cơ bản,"Key event là sự kiện khi bạn nhấn vào một key trên bàn phím. Có 3 sự kiện với key là:
Ví dụ:

```js
addEventListener(""keydown"", function (event) {
  console.log(""keydown"", event.keyCode);
});
addEventListener(""keyup"", function (event) {
  console.log(""keyup"", event.keyCode);
});
addEventListener(""keypress"", function (event) {
  console.log(""keypress"", event.keyCode);
});
```
`addEventListener(""keydown"", function (event) {
  console.log(""keydown"", event.keyCode);
});
addEventListener(""keyup"", function (event) {
  console.log(""keyup"", event.keyCode);
});
addEventListener(""keypress"", function (event) {
  console.log(""keypress"", event.keyCode);
});` Trong ví dụ này, mình ghi ra giá trịkeyCodecủa phím được nhấn dựa vào đối tượngevent (keyEventở đây là giá trị số nguyên của từng phím trong bảng mã Unicode).
Chú ý:với sự kiệnkeydownvàkeyupthì giá trị sẽ ứng với chữ cái thường, trong khi sự kiệnkeypressthì ta sẽ có giá trị của chữ cái viết hoa. Tức là nếu bạn nhấn phím 'a' thì kết quả sẽ là:

```js
keydown 65
keypress 97
keyup 65
```
`keydown 65
keypress 97
keyup 65` Ngoài ra bạn có thể xử lý việc nhấn tổ hợp phím như ví dụ sau:

```js
addEventListener(""keydown"", function (event) {
  if (event.ctrlKey) console.log(""keydown"", ""ctrlKey"", event.keyCode);
});
addEventListener(""keydown"", function (event) {
  if (event.shiftKey) console.log(""keydown"", ""shiftKey"", event.keyCode);
});
addEventListener(""keydown"", function (event) {
  if (event.altKey) console.log(""keydown"", ""altKey"", event.keyCode);
});
```
`addEventListener(""keydown"", function (event) {
  if (event.ctrlKey) console.log(""keydown"", ""ctrlKey"", event.keyCode);
});
addEventListener(""keydown"", function (event) {
  if (event.shiftKey) console.log(""keydown"", ""shiftKey"", event.keyCode);
});
addEventListener(""keydown"", function (event) {
  if (event.altKey) console.log(""keydown"", ""altKey"", event.keyCode);
});` Mouse event là sự kiện khi bạn nhấn hay di chuyển chuột. Một số sự kiện với chuột là:
Đối với sự kiện nhấn chuột, có nhiều bài toán mà bạn sẽ cần phải xác định vị trí nhấn chuột, kéo chuột,... mình sẽ giới thiệu với bạn ở một bài viết khác sau."
394,Một số event trong Javascript,Kết luận,"Trên đây là một số cách xử lý Event JavaScript cơ bản. Mình có thể tóm tắt lại như sau:
Hy vọng bạn có thể nắm được những kiến thức cơ bản về JS event."
395,Native Prototype trong JavaScript,Giới thiệu,"Thuộc tínhprototypethường được sử dụng nhiều trongJavaScript core. Ngoài ra, các hàm khởi tạo sẵn có khác cũng sử dụng thuộc tính này, tạm gọi lànative prototype.
Sau đây, mình sẽ tìm hiểu chi tiết về native prototypes và cách để thêm các tính năng cho chúng."
396,Native Prototype trong JavaScript,Object.prototype,"Hãy xem ví dụ sau:

```js
let obj = {};
alert(obj); // ""[object Object]""
```
`let obj = {};
alert(obj); // ""[object Object]""` Rõ ràng,objlà mộtđối tượng rỗng. Vậy thì đoạn code tạo ra""[object Object]""nằm ở đâu?
`obj` `""[object Object]""` Kết quả trên được tạo ra từ phương thứctoString.
`toString` Thực chất,obj = {}tương đương vớiobj = new Object(), vớiObjectlà mộthàm khởi tạo sẵn cótrong JavaScript. Và hàm khởi tạoObjectcóprototypechứa phương thứctoString.
`obj = {}` `obj = new Object()` `Object` `Object` `prototype` `toString` Khinew Object()được gọi, thuộc tính[[Prototype]]của đối tượng mới tạo ra được gán bằngObject.prototype.
`new Object()` `[[Prototype]]` `Object.prototype` Khi gọiobj.toString(), đầu tiên JavaScript sẽ tìm kiếm trongobj, nhưng không tồn tạitoStringnên JavaScript tự động tìm kiếm trong prototype củaobj.
`obj.toString()` `obj` `toString` `obj` Bạn có thể kiểm tra lại bằng cách sau:

```js
let obj = {};

console.log(obj.__proto__ === Object.prototype); // true
console.log(obj.toString === obj.__proto__.toString); // true
console.log(obj.toString === Object.prototype.toString); // true
```
`let obj = {};

console.log(obj.__proto__ === Object.prototype); // true
console.log(obj.toString === obj.__proto__.toString); // true
console.log(obj.toString === Object.prototype.toString); // true` Chú ý:không tồn tại prototype củaObject.prototype:
`Object.prototype` 
```js
console.log(Object.prototype.__proto__); // null
```
`console.log(Object.prototype.__proto__); // null`"
397,Native Prototype trong JavaScript,Native prototypes của các kiểu dữ liệu khác,"Các kiểu dữ liệu khác nhưArray,Date,Function,... cũng có các phương thức ở native prototypes.
`Array` `Date` `Function` Ví dụ, khi tạo mảng[1, 2, 3]thì JavaScript sẽ gọi hàm khởi tạonew Array(). Vì vậy,Array.prototypecũng trở thành prototype của mảng được tạo ra.
`[1, 2, 3]` `new Array()` `Array.prototype` Nhờ đó mà bạn có thể sử dụng các phương thức với mảng nhưforEach,map,filter,...
`forEach` `map` `filter` Lưu ý
Các kiểu dữ liệu sẵn có trong JavaScript đều cóObject.prototypeởtop của chuỗi prototype. Nói cách khác, tất cả cáckiểu dữ liệu tham chiếuđều kế thừa từ object
`Object.prototype` Ví dụ:

```js
let arr = [1, 2, 3];

// mảng arr kế thừa prototype từ Array.prototype
console.log(arr.__proto__ === Array.prototype); // true

// sau đó prototype trên lại kế thừa từ Object.prototype
console.log(arr.__proto__.__proto__ === Object.prototype); // true

// cuối cùng là null
console.log(arr.__proto__.__proto__.__proto__); // null
```
`let arr = [1, 2, 3];

// mảng arr kế thừa prototype từ Array.prototype
console.log(arr.__proto__ === Array.prototype); // true

// sau đó prototype trên lại kế thừa từ Object.prototype
console.log(arr.__proto__.__proto__ === Object.prototype); // true

// cuối cùng là null
console.log(arr.__proto__.__proto__.__proto__); // null` Một vài phương thức trong chuỗi prototypecó thể trùng tên nhau.
Ví dụObject.prototypecó phương thứctoStringvàArray.prototypecũng có phương thứctoStringriêng. Tuy nhiên, prototype nào gần hơn thì sẽ được sử dụng.
`Object.prototype` `toString` `Array.prototype` `toString` 
```js
let arr = [1, 2, 3];
alert(arr); // 1,2,3 <-- kết quả từ Array.prototype.toString
```
`let arr = [1, 2, 3];
alert(arr); // 1,2,3 <-- kết quả từ Array.prototype.toString` Trong ví dụ trên, kết quả1, 2, 3được tạo ra từArray.prototype.toString.
`1, 2, 3` `Array.prototype.toString`"
398,Native Prototype trong JavaScript,Kiểu dữ liệu nguyên thủy,"Trong các ví dụ trên, mình mới chỉ đề cập tớikiểu dữ liệu tham chiếu, vớikiểu dữ liệu nguyên thủythì sao?
Rõ ràng, kiểu dữ liệu nguyên thủykhông phải object. Nhưng khi bạn truy cập vào các thuộc tính, phương thức của kiểu dữ liệu nguyên thủy thì JavaScript sẽ tự động tạo ra mộtwrapper objecttừ các hàm khởi tạoString,NumbervàBoolean.
`String` `Number` `Boolean` Đây làobject tạmdùng để đóng gói lấy kiểu dữ liệu nguyên thủy. Và sau khi JavaScript sử dụng xong thì wrapper object sẽ được giải phóng.
Phương thức của cácđối tượng tạmtrên cũng nằm trong prototype, cụ thể là:String.prototype,Number.prototypevàBoolean.prototype.
`String.prototype` `Number.prototype` `Boolean.prototype` Lưu ý
Hai kiểu dữ liệunullvàundefinedkhông cówrapper object. Do đó, hai kiểu dữ liệu này không có phương thức nào đi cùng.
`null` `undefined`"
399,Native Prototype trong JavaScript,Thay đổi native prototypes,"Native prototypescó thể thay đổi được. Giả sử bạn thêm một phương thức choString.prototypethì phương thức này có thể được dùng ở mọi string:
`String.prototype` 
```js
String.prototype.show = function () {
  console.log(this);
};

""AHA"".show(); // AHA!
```
`String.prototype.show = function () {
  console.log(this);
};

""AHA"".show(); // AHA!` Trong quá trình phát triển phần mềm, bạn có thể sẽ muốnthêm phương thứccho các kiểu dữ liệu. Và giả sử, bạn thêm chúng vào native prototypes.
Cách này đúng nhưng không phải là một ý tưởng tốt. Bởi vì prototypes làglobal.
Nếu hai thư viện cùng thêm phương thứcString.prototype.showthì một trong hai sẽ bị ghi đè, dẫn đến xung đột code.
`String.prototype.show` Lưu ý
Chỉ có một trường hợp bạn nên thêm phương thức vào native prototypes, đó làpolyfilling.
Polyfilling nghĩa là bạn thêm một phương thức vào kiểu dữ liệu sẵn có trong JavaScript. Phương thức này tồn tại trongmô tả của ngôn ngữ JavaScriptnhưng lại chưa được hỗ trợ ở một JavaScript engine hoặc một phiên bản trình duyệt cũ, ví dụ:

```js
// Nếu như String chưa có phương thức `String.prototype.repeat`
if (!String.prototype.repeat) {
  // Triển khai phương thức repeat
  String.prototype.repeat = function (n) {
    // phương thức repeat lặp lại string với số lần là n
    return new Array(n + 1).join(this);
  };
}

console.log(""Ha"".repeat(3)); // HaHaHa
```
`// Nếu như String chưa có phương thức `String.prototype.repeat`
if (!String.prototype.repeat) {
  // Triển khai phương thức repeat
  String.prototype.repeat = function (n) {
    // phương thức repeat lặp lại string với số lần là n
    return new Array(n + 1).join(this);
  };
}

console.log(""Ha"".repeat(3)); // HaHaHa`"
400,Native Prototype trong JavaScript,Mượn các phương thức từ prototypes,"Trong bài viết vềdecorator và forwarding của hàm trong JavaScript, mình đã nói về vấn đềmượn phương thức.
Đó là khi mình muốn mượn phương thức từ một object và sao chép sang object khác.
Ví dụ, để tạo ra một array-object, bạn có thể sao chép các phương thức củaArray.prototypesang object như sau:
`Array.prototype` 
```js
let obj = {
  0: ""Hello"",
  1: ""world!"",
  length: 2,
};

obj.join = Array.prototype.join;
console.log(obj.join("","")); // Hello,world!
```
`let obj = {
  0: ""Hello"",
  1: ""world!"",
  length: 2,
};

obj.join = Array.prototype.join;
console.log(obj.join("","")); // Hello,world!` Cách trên hoạt động chính xác vì phương thứcArray.prototype.joinchỉ quan tâm tớichỉ sốvà thuộc tínhlength.
`Array.prototype.join` `length` Ngoài ra, để sao chép tất cả các phương thức củaArray.prototypesang object, bạn có thể làm như sau:
`Array.prototype` 
```js
let obj = {
  0: ""Hello"",
  1: ""world!"",
  length: 2,
};

obj.__proto__ = Array.prototype;
console.log(obj.join("","")); // Hello,world!
```
`let obj = {
  0: ""Hello"",
  1: ""world!"",
  length: 2,
};

obj.__proto__ = Array.prototype;
console.log(obj.join("","")); // Hello,world!` Lưu ý
Cách làm như trên không chính xác nếu object đã kế thừa prototype từ một object khác. Thực tế là chỉ kế thừa đượcmột object tại một thời điểm."
401,Native Prototype trong JavaScript,Tổng kết,"Tất cảđối tượng sẵn có trong JavaScriptđều có dạng như sau:
`Array.prototype` `Date.prototype` `Function.prototype` Các kiểu dữ liệu nguyên thủy cũng có các phương thức ởwrapper objectlà:String.prototype,Number.prototypevàBoolean.prototype.
`String.prototype` `Number.prototype` `Boolean.prototype` Prototype có thể thay đổi hoặc thêm mới các phương thức. Tuy nhiên, việc này không được khuyến khích.
Chỉ cómột trường hợpbạn nên thêm phương thức vào prototype. Đó là khi phương thức được định nghĩa trong mô tả của ngôn ngữ JavaScript nhưngchưa được hỗ trợở một số JavaScript Engine hoặc trình duyệt nhất định."
402,Native Prototype trong JavaScript,Thực hành,"Thêm vào prototype của tất cả các hàm phương thứcdefer(ms)- thực thi hàm saumsmili giây, ví dụ:
`defer(ms)` `ms` 
```js
function f() {
  console.log(""Hello!"");
}

f.defer(1000); // hiển thị ""Hello!"" sau 1 giây
```
`function f() {
  console.log(""Hello!"");
}

f.defer(1000); // hiển thị ""Hello!"" sau 1 giây` Xem đáp án

```js
Function.prototype.defer = function (ms) {
  setTimeout(this, ms);
};
function f() {
  console.log(""Hello!"");
}

f.defer(1000); // hiển thị ""Hello!"" sau 1 giây
```
`Function.prototype.defer = function (ms) {
  setTimeout(this, ms);
};
function f() {
  console.log(""Hello!"");
}

f.defer(1000); // hiển thị ""Hello!"" sau 1 giây` Thêm vào prototype của tất cả các hàm phương thứcdefer(ms)- trả về một hàm wrapper giúp trì hoãn việc thực thi hàm saumsmili giây, ví dụ:
`defer(ms)` `ms` 
```js
function f(a, b) {
  console.log(a + b);
}

f.defer(1000)(1, 2); // hiển thị 3 sau 1 giây
```
`function f(a, b) {
  console.log(a + b);
}

f.defer(1000)(1, 2); // hiển thị 3 sau 1 giây` Xem đáp án

```js
Function.prototype.defer = function (ms) {
  // lưu lại hàm
  let f = this;
  return function () {
    setTimeout(() => f.apply(this, [...arguments]), ms);
  };
};
function f(a, b) {
  console.log(a + b);
}

f.defer(1000)(1, 2); // hiển thị 3 sau 1 giây
```
`Function.prototype.defer = function (ms) {
  // lưu lại hàm
  let f = this;
  return function () {
    setTimeout(() => f.apply(this, [...arguments]), ms);
  };
};
function f(a, b) {
  console.log(a + b);
}

f.defer(1000)(1, 2); // hiển thị 3 sau 1 giây` Tham khảo:Native prototypes"
403,Tạo HTTP request đến server trong JavaScript qua XMLHttpRequest,Giới thiệu,"Có bao giờ bạn thắc mắc, chuyện gì thực sự diễn ra khi chúng ta gõ một địa chỉ trang web (ví dụ:kungfutech.edu.vn) lên trình duyệt và nhấnEnter?
Đầu tiên, trình duyệt sẽ tìm kiếm địa chỉ IP của server ứng với tên miền, sau đó là mở kết nối TCP đến server thông qua cổng 80 - cổng mặc định của giao thức HTTP. Nếu server tồn tại và chấp nhận kết nối, trình duyệt sẽ gửi yêu cầu dạng GET đến server để lấy thông tin trang web. Tiếp theo, server phản hồi lại trình duyệt theo đúng kết nối đó. Và cuối cùng, trình duyệt xử lý thông tin phản hồi và hiển thị nó lên trang web.
Quá trình này được thực hiện hoàn toàn dựa trên trình duyệt. Tuy nhiên, bài viết này sẽ hướng dẫn bạn gửi yêu cầu HTTP đến server bằng JavaScript thông quađối tượngXMLHttpRequest. Nhưng trước khi đi vào tìm hiểu cách sử dụng XMLHttpRequest, chúng ta hãy lướt qua một chút về giao thức HTTP để biết nó là cái gì trước đã. OK?"
404,Tạo HTTP request đến server trong JavaScript qua XMLHttpRequest,HTTP là gì?,"Theowikipedia: HTTP - viết tắt của HyperText Transfer Protocol - giao thức truyền tải siêu văn bản, là một trong năm chuẩn về mạng Internet, được dùng để liên hệ thông tin giữa máy cung cấp dịch vụ (Web server) và máy sử dụng dịch vụ (Web client). HTTP là một giao thức sử dụng bộ giao thức TCP/IP.
HTTP hỗ trợ các phương thức request sau:
Status-code là một số nguyên gồm 3 chữ số, dùng để phân loại phản hồi được gửi về từ server. Có 5 loại status-code là:
Cụ thể về từng status-code, bạn có thể tìm hiểu thêm tạiđây."
405,Tạo HTTP request đến server trong JavaScript qua XMLHttpRequest,Gửi HTTP request sử dụng XMLHttpRequest,"Thông thường, vì lý do an toàn nên server sẽ chặn các request từ các tên miền khác với ""tên miền của server"". Do đó, bạn sẽ không thể thực hiện gửi HTTP request đến server sử dụng XMLHttpRequest từ localhost. Sau đây, mình sẽ sử dụng server chuyên dùng để test HTTP request tại:https://httpbin.org/
Ví dụ sau gửi phương thức request dạng GET đếnhttps://httpbin.org/get:

```js
const req = new XMLHttpRequest();
req.open(""GET"", ""https://httpbin.org/get"", false);
req.send(null);
console.log(req.status);
console.log(req.responseText);
```
`const req = new XMLHttpRequest();
req.open(""GET"", ""https://httpbin.org/get"", false);
req.send(null);
console.log(req.status);
console.log(req.responseText);` Kết quả trả về là:

```js
200
    {
      ""args"": {},
      ""headers"": {
        ""Accept"": ""*/*"",
        ""Accept-Encoding"": ""gzip, deflate, br"",
        ""Accept-Language"": ""en-US,en;q=0.8,vi;q=0.6"",
        ""Connection"": ""close"",
        ""Host"": ""httpbin.org"",
        ""Origin"": ""null"",
        ""User-Agent"": ""Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1""
      },
      ""origin"": ""183.81.50.73"",
      ""url"": ""https://httpbin.org/get""
    }
```
`200
    {
      ""args"": {},
      ""headers"": {
        ""Accept"": ""*/*"",
        ""Accept-Encoding"": ""gzip, deflate, br"",
        ""Accept-Language"": ""en-US,en;q=0.8,vi;q=0.6"",
        ""Connection"": ""close"",
        ""Host"": ""httpbin.org"",
        ""Origin"": ""null"",
        ""User-Agent"": ""Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1""
      },
      ""origin"": ""183.81.50.73"",
      ""url"": ""https://httpbin.org/get""
    }` Trong JavaScript, câu lệnh để tạo mới một đối tượng XMLHttpRequest:var req = new XMLHttpRequest();.
Sau khi đã có đối tượng req, mình sử dụng phương thứcopenđể cấu hình cho request. Trong đó:
Lúc này, request mới được cấu hình. Để gửi request này đến server, mình sẽ sử dụng phương thứcsendvới đối số làbodycủa request. Trong ví dụ này, mình gửi request kiểuGETnên body chỉ cần lànull.
Kết quả trả về có nhiều thuộc tính, nhưng quan trọng nhất là 2 thuộc tính:
Ngoài ra, nhiều trường hợp bạn phải chèn thêm header cho request thì server mới chấp nhận. Để làm được việc này, bạn có thể sử dụng phương thứcsetRequestHeaderđơn giản như sau:

```js
XMLHttpRequest.setRequestHeader(header, value);
```
`XMLHttpRequest.setRequestHeader(header, value);` Ví dụ, để cấu hình request sử dụng body kiểu JSON, bạn có thể set header ""Content-Type"":

```js
req.setRequestHeader(""Content-Type"", ""application/json;charset=UTF-8"");
```
`req.setRequestHeader(""Content-Type"", ""application/json;charset=UTF-8"");` Ví dụ sau gửi phương thức request dạng POST:

```js
const req = new XMLHttpRequest();
req.open(""POST"", ""https://httpbin.org/post"", false);
req.setRequestHeader(""Content-Type"", ""application/json; charset=UTF-8"");

const jsonBody = {
  name: ""Thaycacac"",
  url: ""kungfutech.edu.vn"",
};
req.send(jsonBody);

console.log(req.status);
console.log(req.responseText);
```
`const req = new XMLHttpRequest();
req.open(""POST"", ""https://httpbin.org/post"", false);
req.setRequestHeader(""Content-Type"", ""application/json; charset=UTF-8"");

const jsonBody = {
  name: ""Thaycacac"",
  url: ""kungfutech.edu.vn"",
};
req.send(jsonBody);

console.log(req.status);
console.log(req.responseText);` Kết quả:

```js
200
    {
      ""args"": {},
      ""data"": ""[object Object]"",
      ""files"": {},
      ""form"": {},
      ""headers"": {
        ""Accept"": ""*/*"",
        ""Accept-Encoding"": ""gzip, deflate, br"",
        ""Accept-Language"": ""en-US,en;q=0.8,vi;q=0.6"",
        ""Connection"": ""close"",
        ""Content-Length"": ""15"",
        ""Content-Type"": ""application/json; charset=UTF-8"",
        ""Host"": ""httpbin.org"",
        ""Origin"": ""null"",
        ""User-Agent"": ""Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1""
      },
      ""json"": null,
      ""origin"": ""183.81.50.73"",
      ""url"": ""https://httpbin.org/post""
    }
```
`200
    {
      ""args"": {},
      ""data"": ""[object Object]"",
      ""files"": {},
      ""form"": {},
      ""headers"": {
        ""Accept"": ""*/*"",
        ""Accept-Encoding"": ""gzip, deflate, br"",
        ""Accept-Language"": ""en-US,en;q=0.8,vi;q=0.6"",
        ""Connection"": ""close"",
        ""Content-Length"": ""15"",
        ""Content-Type"": ""application/json; charset=UTF-8"",
        ""Host"": ""httpbin.org"",
        ""Origin"": ""null"",
        ""User-Agent"": ""Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1""
      },
      ""json"": null,
      ""origin"": ""183.81.50.73"",
      ""url"": ""https://httpbin.org/post""
    }` Phần này cũng tương tự như phần sử dụng phương thức GET. Chỉ khác là ở đây, mình sử dụng phương thứcsetRequestHeaderđể cấu hìnhcontent-typelà JSON. Khi gửi request, thay vì gửinullthì ở đây mình gửi đi một đối tượng JSON.
Đối với các phương thức request còn lại như PUT, DELETE, HEAD,... bạn có thể làm tương tự như hai ví dụ trên.
Trong các ví dụ trên, mình mới chỉ sử dụng request đồng bộ. Việc sử dụng request đồng bộ dẫn đến chương trình bị dừng lại để chờ cho đến khi có thông tin phản hồi từ server.
Nếu như server bị lỗi, hoặc việc xử lý request mất nhiều thời gian, điều này dẫn đến chương trình sẽ bị dừng hoạt động, trang web sẽ bịđơ.
Do đó, chỉ nên sử dụng request đồng bộ với những yêu cầu có thể xử lý nhanh. Nhìn chung, bạn nên sử dụng request bất đồng bộ.
Như mình đã nói ở trên, để cấu hình request là bất đồng bộ, bạn chỉ cần truyền vàotrueở thuộc tính thứ 3 của phương thứcopen. Ngoài ra, bạn cần phảiđăng ký sự kiệnloadvà truyền vào hàm callback - hàm này được thực hiện khi có thông tin phản hồi từ server.

```js
const req = new XMLHttpRequest();
req.open(""GET"", ""https://httpbin.org/get"", true);
req.addEventListener(""load"", function () {
  console.log(req.status);
  console.log(req.responseText);
});
req.send(null);
console.log(""Sent"");
```
`const req = new XMLHttpRequest();
req.open(""GET"", ""https://httpbin.org/get"", true);
req.addEventListener(""load"", function () {
  console.log(req.status);
  console.log(req.responseText);
});
req.send(null);
console.log(""Sent"");` Kết quả:

```js
Sent
    200
    {
      ""args"": {},
      ""headers"": {
        ""Accept"": ""*/*"",
        ""Accept-Encoding"": ""gzip, deflate, br"",
        ""Accept-Language"": ""en-US,en;q=0.8,vi;q=0.6"",
        ""Connection"": ""close"",
        ""Host"": ""httpbin.org"",
        ""Origin"": ""null"",
        ""User-Agent"": ""Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1""
      },
      ""origin"": ""183.81.50.73"",
      ""url"": ""https://httpbin.org/get""
    }
```
`Sent
    200
    {
      ""args"": {},
      ""headers"": {
        ""Accept"": ""*/*"",
        ""Accept-Encoding"": ""gzip, deflate, br"",
        ""Accept-Language"": ""en-US,en;q=0.8,vi;q=0.6"",
        ""Connection"": ""close"",
        ""Host"": ""httpbin.org"",
        ""Origin"": ""null"",
        ""User-Agent"": ""Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1""
      },
      ""origin"": ""183.81.50.73"",
      ""url"": ""https://httpbin.org/get""
    }` Kết quả cho thấy, dòng lệnhconsole.log('Sent')được thực hiện ngay sau lệnhreq.send(null). Và 2 câu lệnhconsole.log(req.status); console.log(req.responseText);chỉ được thực hiện khi có thông tin phản hồi về từ server. Đó chính là cách thức hoạt động của XMLHttpRequest bất đồng bộ.
Ngoài ra, bạn có thể đăng ký sự kiệnerrorđể xử lý trường hợp request bị lỗi:

```js
const req = new XMLHttpRequest();
req.open(""GET"", ""https://httpbin.org/get"", true);
req.addEventListener(""load"", function () {
  console.log(req.status);
  console.log(req.responseText);
});
req.addEventListener(""error"", function () {
  console.log(""Error occurred!"");
});
req.send(null);
console.log(""Sent"");
```
`const req = new XMLHttpRequest();
req.open(""GET"", ""https://httpbin.org/get"", true);
req.addEventListener(""load"", function () {
  console.log(req.status);
  console.log(req.responseText);
});
req.addEventListener(""error"", function () {
  console.log(""Error occurred!"");
});
req.send(null);
console.log(""Sent"");`"
406,Tạo HTTP request đến server trong JavaScript qua XMLHttpRequest,Tổng kết,"Trên đây là một số kiến thức cơ bản về HTTP và cách sử dụng XMLHttpRequest trong JavaScript để gửi HTTP request. Mình có thể tóm tắt như sau:
Về HTTP và XMLHttpRequest còn rất nhiều thứ, bài viết này chỉ đưa ra những kiến thức cơ bản nhất. Bạn có thể tự tìm hiểu thêm trên Internet.
Xin chào và hẹn gặp lại bạn ở bài viết tiếp theo, thân ái!"
407,Object là gì? Object trong Javascript,Giới thiệu,"Như mình đã nói trong bàicác kiểu dữ liệu trong JavaScript, JavaScript có7 kiểu dữ liệu nguyên thủyvà1 kiểu dữ liệu dạng tham chiếu. Đó là object trong JavaScript.
Để hiểu object (đối tượng) là gì, mình sẽ đưa ra một ví dụ về máy tính. Cụ thể, máy tính của mình có những đặc điểm sau:
Ở đây,máy tính của mình: chính là mộtJavaScript object. Đối tượng này có cácthuộc tính(properties):loại, hãng, hệ điều hành, card đồ hoạvới các giá trị tương ứng làlaptop, Sony, Windows 7, NVIDIA."
408,Object là gì? Object trong Javascript,Vậy object trong JavaScript là gì?,"Object trong JavaScriptlà một khái niệm trừu tượng dùng để biểu diễn một vật thể (cụ thể). Trong đó, các thuộc tính dùng để miêu tả đặc điểm, tính chất của đối tượng.
Về bản chất, object là tập hợp của cáckeyvàvalue. Vớikeygọi là thuộc tính, cònvaluelà giá trị tương ứng của thuộc tính.
Lưu ý"
409,Object là gì? Object trong Javascript,Biểu diễn object trong JavaScript,"JavaScript object sử dụng cặp dấu ngoặc{}để biểu diễn:
`{}` 
```js
{
  key1: value1,
  key2: value2,
  key3: value3,
  ...
}
```
`{
  key1: value1,
  key2: value2,
  key3: value3,
  ...
}` Trong đó:
`,` Áp dụng cho ví dụ trên:

```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  os: ""Windows 7"",
  graphicCard: ""NVIDIA"",
};
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  os: ""Windows 7"",
  graphicCard: ""NVIDIA"",
};` 💡Chú ý: Cặpkey-valuecuối cùng không nhất thiết phải có dấu phẩy,. Nhưng để đảm bảo tính đồng nhất thì bạn nên thêm vào dấu phẩygraphicCard: ""NVIDIA"",.
`,` `graphicCard: ""NVIDIA"",` Đặc điểm này được gọi làtrailing commahay ""dấu phẩy đuôi"".
Ngoài ra, để khai báoobject rỗngbạn có thể sử dụng một trong hai cách sau:

```js
// Objec rỗng không có thuộc tính nào
let myComputer = {};

// Hoặc sử dụng hàm khởi tạo object
let yourComputer = new Object();
```
`// Objec rỗng không có thuộc tính nào
let myComputer = {};

// Hoặc sử dụng hàm khởi tạo object
let yourComputer = new Object();` Trong đó,new Object()là cú pháphàmkhởi tạo củaobject. Cách này ít sử dụng hơn cách đầu tiên.
`new Object()`"
410,Object là gì? Object trong Javascript,Cách sử dụng object trong JavaScript,"Khi đã khởi tạo được object rồi thì vấn đề tiếp theo là làm sao sử dụng được object. Cụ thể là cách thức để truy cập vào thuộc tính của object.
Có 2 cách để lấy ra giá trị của một thuộc tính trong object:
`.` `[]` Ví dụ mô tả cách truy cập thuộc tính object:

```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  os: ""Windows 7"",
  graphicCard: ""NVIDIA"",
};

console.log(myComputer.type); // laptop
console.log(myComputer.brand); // Sony
console.log(myComputer.os); // Windows 7
console.log(myComputer.graphicCard); // NVIDIA

console.log(myComputer[""type""]); // => laptop
console.log(myComputer[""brand""]); // => Sony
console.log(myComputer[""os""]); // => Windows 7
console.log(myComputer[""graphicCard""]); // => NVIDIA
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  os: ""Windows 7"",
  graphicCard: ""NVIDIA"",
};

console.log(myComputer.type); // laptop
console.log(myComputer.brand); // Sony
console.log(myComputer.os); // Windows 7
console.log(myComputer.graphicCard); // NVIDIA

console.log(myComputer[""type""]); // => laptop
console.log(myComputer[""brand""]); // => Sony
console.log(myComputer[""os""]); // => Windows 7
console.log(myComputer[""graphicCard""]); // => NVIDIA` Đặc biệt, toán tử.chỉ dùng được trong trường hợp tên thuộc tính không có kí tự đặc biệt (ngoại trừ kí tự_và$).
`.` `_` `$` Khikeychứa dấu cách, hoặc các ký tự đặc biệt khác thì bạn bắt buộc phải sử dụng toán tử[].
`[]` Ví dụ:

```js
let myComputer = {
  _type: ""laptop"",
  $brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

console.log(myComputer._type); // laptop
console.log(myComputer.$brand); // Sony
console.log(myComputer[""operating system""]); // Windows 7
console.log(myComputer.operating system); // ERROR -> lỗi cú pháp
```
`let myComputer = {
  _type: ""laptop"",
  $brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

console.log(myComputer._type); // laptop
console.log(myComputer.$brand); // Sony
console.log(myComputer[""operating system""]); // Windows 7
console.log(myComputer.operating system); // ERROR -> lỗi cú pháp` 📝 Khikeychứa dấu cách hoặc các ký tự đặc biệt (khác_và$), bạn cần phải đểkeybên trong cặp dấu nháy kép""""hoặc nháy đơn''.
`_` `$` `""""` `''` `console.log` 
```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  os: ""Windows 7"",
  graphicCard: ""NVIDIA"",
};

console.log(myComputer);
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  os: ""Windows 7"",
  graphicCard: ""NVIDIA"",
};

console.log(myComputer);` Kiểm tra trênDev Tools, bạn sẽ thấy toàn bộ object được in ra."
411,Object là gì? Object trong Javascript,Cập nhật JavaScript object,"Đểthay đổi giá trị thuộc tínhcủa object, bạn chỉ cần sử dụng cách truy cập ở trên và gán giá trị mới cho thuộc tính đó.

```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

myComputer.type = ""desktop"";
myComputer[""operating system""] = ""Ubuntu"";
console.log(myComputer.type); // => desktop
console.log(myComputer[""operating system""]); // => Ubuntu
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

myComputer.type = ""desktop"";
myComputer[""operating system""] = ""Ubuntu"";
console.log(myComputer.type); // => desktop
console.log(myComputer[""operating system""]); // => Ubuntu` Bạn cũng có thểthêm thuộc tính cho objectnhư sau:

```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

myComputer.status = ""sleep"";
myComputer[""it is good""] = true;
console.log(myComputer.status); // sleep
console.log(myComputer[""it is good""]); // => true
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

myComputer.status = ""sleep"";
myComputer[""it is good""] = true;
console.log(myComputer.status); // sleep
console.log(myComputer[""it is good""]); // => true` Đểxóa một thuộc tính của objecttrong JavaScript, bạn sử dụng toán tửdelete:
`delete` 
```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

delete myComputer.brand;
delete myComputer[""graphic card""];
console.log(myComputer.brand); // undefined
console.log(myComputer[""graphic card""]); // undefined
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

delete myComputer.brand;
delete myComputer[""graphic card""];
console.log(myComputer.brand); // undefined
console.log(myComputer[""graphic card""]); // undefined` Khi bạn đã xóa thuộc tínhbrandvà""graphic card""thì các thuộc tính này không tồn tại trong object nữa, hay giá trị của chúng trở thànhundefined.
`brand` `""graphic card""` `undefined` Nói cách khác, giá trị của một thuộc tính không tồn tại trong object làundefined, ví dụ:
`undefined` 
```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

console.log(myComputer.status); // undefinedconsole.log(myComputer[""it is good""]); // undefined
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

console.log(myComputer.status); // undefinedconsole.log(myComputer[""it is good""]); // undefined`"
412,Object là gì? Object trong Javascript,Toán tử ngoặc vuông[]trong object JS,"`[]` JavaScript cho phép bạn truy cập vào thuộc tính với giá trị củakeylàbiếnhoặc biểu thức.
Khi đó, giá trị củakeysẽ được tính toán trong thời gian chạy (runtime), ví dụ:

```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

// sử dụng biến
let operatingSystem = ""operating system"";
console.log(myComputer[operatingSystem]); // Windows 7
// sử dụng biểu thức
console.log(myComputer[""graphic"" + "" "" + ""card""]); // NVIDIA
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

// sử dụng biến
let operatingSystem = ""operating system"";
console.log(myComputer[operatingSystem]); // Windows 7
// sử dụng biểu thức
console.log(myComputer[""graphic"" + "" "" + ""card""]); // NVIDIA` `.` 
```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

const operatingSystem = ""operating system"";
console.log(myComputer.operatingSystem); // undefined
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

const operatingSystem = ""operating system"";
console.log(myComputer.operatingSystem); // undefined` Trong trường hợpmyComputer.operatingSystem, JavaScript hiểu là bạn đang muốn truy cập vào thuộc tínhoperatingSystemmà trong objectmyComputerlại không có thuộc tính nào như vậy.
`myComputer.operatingSystem` `operatingSystem` `myComputer` Không chỉ dừng lại ở việc truy cập thuộc tính runtime, bạn cũng có thể dùng toán tử[]để khởi tạo object trong JavaScript như sau:
`[]` 
```js
let t = ""type"";
const operatingSystem = ""operating system"";

let myComputer = {
  [t]: ""laptop"",
  brand: ""Sony"",
  [operatingSystem]: ""Windows 7"",
  [""graphic"" + "" "" + ""card""]: ""NVIDIA"",
};

console.log(myComputer.type); // ""laptop""
console.log(myComputer[""operating system""]); // Windows 7
console.log(myComputer[""graphic card""]); // NVIDIA
```
`let t = ""type"";
const operatingSystem = ""operating system"";

let myComputer = {
  [t]: ""laptop"",
  brand: ""Sony"",
  [operatingSystem]: ""Windows 7"",
  [""graphic"" + "" "" + ""card""]: ""NVIDIA"",
};

console.log(myComputer.type); // ""laptop""
console.log(myComputer[""operating system""]); // Windows 7
console.log(myComputer[""graphic card""]); // NVIDIA`"
413,Object là gì? Object trong Javascript,Cú pháp rút gọn thuộc tính khi khởi tạo object,"Khi lập trình, bạn sẽ gặp trường hợp là: bạn muốn sử dụng tên biến làm thuộc tính cho object, ví dụ:

```js
function makeComputer(type, brand, os, graphicCard) {
  return {
    type: type,
    brand: brand,
    os: os,
    graphicCard: graphicCard,
  };
}

// Ví dụ
let myComputer = makeComputer(""laptop"", ""Sony"", ""Windows 7"", ""NVIDIA"");
console.log(myComputer.type); // laptop
console.log(myComputer.brand); // Sony
console.log(myComputer.os); // Windows 7
console.log(myComputer.graphicCard); // NVIDIA
```
`function makeComputer(type, brand, os, graphicCard) {
  return {
    type: type,
    brand: brand,
    os: os,
    graphicCard: graphicCard,
  };
}

// Ví dụ
let myComputer = makeComputer(""laptop"", ""Sony"", ""Windows 7"", ""NVIDIA"");
console.log(myComputer.type); // laptop
console.log(myComputer.brand); // Sony
console.log(myComputer.os); // Windows 7
console.log(myComputer.graphicCard); // NVIDIA` Trong ví dụ trên, bạn thấy rằng các thuộc tính trùng với tên của tham số truyền vào hàm:type: type,brand: brand,os: osvàgraphicCard: graphicCard.
`type: type` `brand: brand` `os: os` `graphicCard: graphicCard` Để tránh phải viết lặp lại như vậy, JavaScript cung cấp cú pháp rút gọn như sau:

```js
function makeComputer(type, brand, os, graphicCard) {
  return {
    type,
    brand,
    os,
    graphicCard,
  };
}

// Ví dụ
let myComputer = makeComputer(""laptop"", ""Sony"", ""Windows 7"", ""NVIDIA"");
console.log(myComputer.type); // laptop
console.log(myComputer.brand); // Sony
console.log(myComputer.os); // Windows 7
console.log(myComputer.graphicCard); // NVIDIA
```
`function makeComputer(type, brand, os, graphicCard) {
  return {
    type,
    brand,
    os,
    graphicCard,
  };
}

// Ví dụ
let myComputer = makeComputer(""laptop"", ""Sony"", ""Windows 7"", ""NVIDIA"");
console.log(myComputer.type); // laptop
console.log(myComputer.brand); // Sony
console.log(myComputer.os); // Windows 7
console.log(myComputer.graphicCard); // NVIDIA`"
414,Object là gì? Object trong Javascript,Giới hạn về tên thuộc tính của object trong JS,"Như bạn đã biết, bạn không được phép sử dụngtừ khóa và từ dữ trữđể đặt tên biến trong JavaScript, ví dụ như:var,const,let,for,while,...
`var` `const` `let` `for` `while` Nhưng với thuộc tính trong object khác, bạn không bị giới hạn này:

```js
let obj = {
  var: 1,
  let: ""a"",
  for: null,
  while: NaN,
};

console.log(obj.var); // 1
console.log(obj.let); // a
console.log(obj.for); // null
console.log(obj.while); // NaN
```
`let obj = {
  var: 1,
  let: ""a"",
  for: null,
  while: NaN,
};

console.log(obj.var); // 1
console.log(obj.let); // a
console.log(obj.for); // null
console.log(obj.while); // NaN` Tên của thuộc tính có thể là bất kỳ string nào (hoặc symbol). Với những giá trị không phải string thì JavaScript sẽ tựchuyển đổi kiểu dữ liệusang string.
Ví dụ số0được chuyển về string""0"":
`0` `""0""` 
```js
let obj = {
  0: ""Zero"",
};

// Hai cách truy cập sau đây tương đương nhau
console.log(obj[0]); // Zero
console.log(obj[""0""]); // Zero
```
`let obj = {
  0: ""Zero"",
};

// Hai cách truy cập sau đây tương đương nhau
console.log(obj[0]); // Zero
console.log(obj[""0""]); // Zero` `__proto__` 
```js
let obj = {
  x: 1,
};

console.log(obj.__proto__); // [object Object]

obj.__proto__ = ""string"";
console.log(obj.__proto__); // [object Object] - giống như cũ
```
`let obj = {
  x: 1,
};

console.log(obj.__proto__); // [object Object]

obj.__proto__ = ""string"";
console.log(obj.__proto__); // [object Object] - giống như cũ` Đây là thuộc tính đặc biệt trong JavaScript mà mình sẽ giới thiệu sau."
415,Object là gì? Object trong Javascript,Cách kiểm tra tính tồn tại của thuộc tính,"Như mình đã nói ở trên, nếu một thuộc tính không tồn tại trong object thì giá trị của nó làundefined.
`undefined` Nhưng bạn không thể dùng cách này để kiểm tra tính tồn tại của thuộc tính trong object được. Vì rất có thể, giá trị của thuộc tính được chủ động gán choundefined.
`undefined` 
```js
let user = {
  name: undefined,
};

console.log(user.name); // undefined
console.log(user.age); // undefined
```
`let user = {
  name: undefined,
};

console.log(user.name); // undefined
console.log(user.age); // undefined` Cả hai trường hợp trên đều cho kết quả làundefined. Nhưng rõ ràng là thuộc tínhnamecó tồn tại trong object, còn thuộc tínhagethì không tồn tại.
`undefined` `name` `age` Để giải quyết vấn đề này, bạn có thể dùng toán tửinvới cú pháp là:
`in` ""key"" in object;
`""key"" in object;` Ví dụ sử dụngin:
`in` 
```js
let user = {
  name: undefined,
};

console.log(""name"" in user); // true
console.log(""age"" in user); // false
```
`let user = {
  name: undefined,
};

console.log(""name"" in user); // true
console.log(""age"" in user); // false` `in` `""""` `''` `true` `false`"
416,Object là gì? Object trong Javascript,Cách duyệt tất cả các thuộc tính của object,"Để duyệt tất cả các thuộc tính của object, bạn có thể sử dụng vòng lặpfor...in- khác với vòng lặpfor(;;)đã tìm hiểu ở bàivòng lặp trong JavaScript.
`for...in` `for(;;)` 
```js
let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

for (let prop in myComputer) {
  console.log(prop, "":"", myComputer[prop]);
}

// type : laptop
// brand : Sony
// operating system : Windows 7
// graphic card : NVIDIA
```
`let myComputer = {
  type: ""laptop"",
  brand: ""Sony"",
  ""operating system"": ""Windows 7"",
  ""graphic card"": ""NVIDIA"",
};

for (let prop in myComputer) {
  console.log(prop, "":"", myComputer[prop]);
}

// type : laptop
// brand : Sony
// operating system : Windows 7
// graphic card : NVIDIA` Khi đó biếnpropsẽ chạy hết tất cả các thuộc tính của objectmyComputer.
`prop` `myComputer`"
417,Object là gì? Object trong Javascript,Thứ tự các thuộc tính của object trong JavaScript,"Khi duyệt tất cả các thuộc tính của object trong JavaScript thì có hai trường hợp xảy ra:
Ví dụ:

```js
let numbers = {
  ""-21"": ""minus two"",
  ""-1"": ""minus one"",
  0: ""zero"",
  10: ""ten"",
  2: ""two"",
  a: ""abc"",
  ""-3"": ""minus three"",
  4: ""four"",
  3: ""three"",
  6: ""six"",
};

for (let n in numbers) {
  console.log(n);
}

// 0
// 2
// 3
// 4
// 6
// 10
// -21
// -1
// a
// -3
```
`let numbers = {
  ""-21"": ""minus two"",
  ""-1"": ""minus one"",
  0: ""zero"",
  10: ""ten"",
  2: ""two"",
  a: ""abc"",
  ""-3"": ""minus three"",
  4: ""four"",
  3: ""three"",
  6: ""six"",
};

for (let n in numbers) {
  console.log(n);
}

// 0
// 2
// 3
// 4
// 6
// 10
// -21
// -1
// a
// -3` Trong ví dụ trên, các thuộc tính với số không dấu được đưa lên đầu và sắp xếp theo tứ tự từ số nhỏ đến số lớn. Các thuộc tính còn lại được xếp sau và giống với thứ tự thêm vào object."
418,Object là gì? Object trong Javascript,Một số đối tượng sẵn có trong JavaScript,"JavaScript cung cấp sẵn một số đối tượng giúp công việc lập trình trở nên dễ dàng hơn.
Mỗi khi hàm được gọi, có một biến số đặc biệt tên làargumentsđược thêm vào bên trong phạm vi của function. Biến số này chứa một thuộc tính làlength, để xác định số lượng tham số truyền vào.
`arguments` `length` Bởi vì, bạn có thể truyền vào nhiều hơn, hay ít hơn số lượng tham số của hàm. Nên việc biết số lượng tham số truyền vào là vô cùng cần thiết trong lập trình JavaScript.
Ví dụ sau miêu tả cách sử dụngargumentsđể xác định số lớn nhất trong tất cả các số truyền vào:
`arguments` 
```js
function maxOf() {
  let max = -1;

  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > max) max = arguments[i];
  }

  return max;
}

console.log(maxOf(1, 2));
// 2

console.log(maxOf(1, 2, 6, 4, 7, 3, 5));
// 7
```
`function maxOf() {
  let max = -1;

  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > max) max = arguments[i];
  }

  return max;
}

console.log(maxOf(1, 2));
// 2

console.log(maxOf(1, 2, 6, 4, 7, 3, 5));
// 7` Rõ ràng, hàmmaxOfở trên không chứa một tham số nào. Nhưng khi sử dụng, mình lại truyền vào tham số với số lượng tuỳ ý.
`maxOf` Cái tên đã nói lên tất cả. Đúng vậy, đối tượngMathchứa các hàm phục vụ cho tính toán số học như:
`Math` `Math.min` `Math.max` `Math.sqrt` `Math.abs` Sử dụngMathgiúp giảm thiểu đáng kể thời gian viết code, vì bạn không phải viết lại những hàm cực kì cơ bản.
`Math` Bạn có thể tham khảo thêm vềMath.
Trên với trình duyệt, object lớn nhất chính làwindow. Mọi biến global đều thuộc đối tượng này.
`window` 
```js
var x = 6; // khai báo biến sử dụng var như này thì x thuộc window
console.log(""x"" in window);
// true

console.log(window.x);
// 6
```
`var x = 6; // khai báo biến sử dụng var như này thì x thuộc window
console.log(""x"" in window);
// true

console.log(window.x);
// 6`"
419,Object là gì? Object trong Javascript,Tổng kết,"Bản chất object trong JavaScript là tập hợp của cáckey-value, trong đó:
Có hai cách để truy cập vào thuộc tính của object:
`.` `object.property` `[]` `object[""property""]` `[]` `key` Một số toán tử liên quan:
`delete` `delete object.property` `in` `""key"" in object` Để duyệt tất cả các thuộc tính trong object, bạn dùng vòng lặpfor...indạng như:for(let key in obj).
`for...in` `for(let key in obj)`"
420,Object là gì? Object trong Javascript,Thực hành,"Viết code theo các yêu cầu sau:
`point` `x` `2` `y` `3` `z index` `1000` `1005` `x` `1` `y` `point` Xem đáp án

```js
// 1. Tạo object rỗng `point`.
let point = {};

// 2. Thêm thuộc tính `x` với giá trị `2`.
point.x = 2;

// 3. Thêm thuộc tính `y` với giá trị `3`.
point.y = 3;

// 4. Thêm thuộc tính `z index` với giá trị `1000`.
point[""z-index""] = 1000;

// 5. Tính tổng giá trị các thuộc tính.
let sum = 0;
for (let key in point) {
  sum += point[key];
}
console.log(sum); // 1005

// 6. Thay đổi giá trị ứng với thuộc tính `x` thành `1`.
point.x = 1;

// 7. Xóa thuộc tính `y` khỏi `point`.
delete point.y;
```
`// 1. Tạo object rỗng `point`.
let point = {};

// 2. Thêm thuộc tính `x` với giá trị `2`.
point.x = 2;

// 3. Thêm thuộc tính `y` với giá trị `3`.
point.y = 3;

// 4. Thêm thuộc tính `z index` với giá trị `1000`.
point[""z-index""] = 1000;

// 5. Tính tổng giá trị các thuộc tính.
let sum = 0;
for (let key in point) {
  sum += point[key];
}
console.log(sum); // 1005

// 6. Thay đổi giá trị ứng với thuộc tính `x` thành `1`.
point.x = 1;

// 7. Xóa thuộc tính `y` khỏi `point`.
delete point.y;`"
421,Optional chaining trong Javascript,Giới thiệu,"Optional chaining trong JavaScript?.là cách an toàn để truy cập vào thuộc tính của object lồng nhau, thậm chí thuộc tính không tồn tại.
`?.`"
422,Optional chaining trong Javascript,Vấn đề với thuộc tính không tồn tại,"Giả sử mình có đối tượnguser. Trong đối tượnguserlại có thuộc tínhaddress(cũng là mộtobject). Nhưng thuộc tínhaddresslàkhông bắt buộc.
`user` `user` `address` `address` Nghĩa là không phải đối tượng nào cũng cung cấpaddresshay giá trị củauser.addresscó thể bằngundefined.
`address` `user.address` `undefined` Tiếp theo, trongaddresslại có các thuộc tính nhưstreet,city,... Nếu mình muốn truy cập vàoaddressthì sẽ làm như sau:
`address` `street` `city` `address` 
```js
// user có thuộc tính address
let user1 = {
  address: { street: ""Hai Ba Trung"" },
};
console.log(user1.address.street); // Hai Ba Trung
// user không có thuộc tính address
let user2 = {};
console.log(user2.address.street); // Uncaught TypeError: Cannot read properties of undefined (reading 'street')
```
`// user có thuộc tính address
let user1 = {
  address: { street: ""Hai Ba Trung"" },
};
console.log(user1.address.street); // Hai Ba Trung
// user không có thuộc tính address
let user2 = {};
console.log(user2.address.street); // Uncaught TypeError: Cannot read properties of undefined (reading 'street')` Trường hợpuser2không cóaddressmà mình truy cậpuser2.address.streetthì sẽ bị lỗiUncaught TypeError: Cannot read properties of undefined (reading 'street').
`user2` `address` `user2.address.street` Tạm dịch: không thể đọc giá trị thuộc tính củaundefined.
`undefined` Kết quả mong muốnthường là: nếuuser2.addressbằngundefinedthìuser2.address.streetcũng trả vềundefined.
`user2.address` `undefined` `user2.address.street` `undefined` Có một số cách để giải quyết vấn đề này. Bạn có thể sử dụngcâu lệnhifhoặc toán tử?:hoặc dùngtoán tử AND&&như sau:
`if` `?:` `&&` 
```js
let user2 = {};

// sử dụng if
let street1;
if (user2.address) {
  street1 = user2.address.street;
}

// sử dụng ?:
let street2 = user2.address ? user2.address.street : undefined;

// sử dụng toán tử &&
let street3 = user2.address && user2.address.street;
```
`let user2 = {};

// sử dụng if
let street1;
if (user2.address) {
  street1 = user2.address.street;
}

// sử dụng ?:
let street2 = user2.address ? user2.address.street : undefined;

// sử dụng toán tử &&
let street3 = user2.address && user2.address.street;` Rõ ràng, cả ba cách trên đều quá dài dòng. Vàuser2.addressbịlặp lại hai lần. Và nếu object cónhiều lớp lồng nhauthì việc lặp lại còn xảy ra nhiều hơn.
`user2.address` Đó là lý dooptional chaining trong JavaScriptxuất hiện để giải quyết vấn đề trên."
423,Optional chaining trong Javascript,Optional chaining trong JavaScript là gì?,"Optional chaining trong Javascript kí hiệu là?., dùng để dừng lại quá trình xử lý nếu giá trị trước?.cókiểu dữ liệulàundefinedhoặcnull.
`?.` `?.` `undefined` `null` Nói cách khác,value?.prop:
`value?.prop` `value.prop` `value` `undefined` `null` `value` `undefined` `null` `undefined` Ví dụ sử dụng optional chaining trong JavaScript:

```js
// user có thuộc tính address
let user1 = {
  address: {
    street: ""Hai Ba Trung"",
  },
};
console.log(user1?.address?.street); // Hai Ba Trung
// user không có thuộc tính address
let user2 = {};
console.log(user2?.address?.street); // undefined
```
`// user có thuộc tính address
let user1 = {
  address: {
    street: ""Hai Ba Trung"",
  },
};
console.log(user1?.address?.street); // Hai Ba Trung
// user không có thuộc tính address
let user2 = {};
console.log(user2?.address?.street); // undefined` Cách viết trên rõ ràng làgọn gàng hơn. Và kết quả trả về đúng như mong đợi.
Ngoài ra, cách viết trên vẫn hoạt động đúng trong trường hợpuserbằngnullhoặcundefined.
`user` `null` `undefined` 
```js
let user = null;

console.log(user?.address); // undefined
console.log(user?.address?.street); // undefined
```
`let user = null;

console.log(user?.address); // undefined
console.log(user?.address?.street); // undefined` Lưu ý
Optional chaining trong JavaScript?.chỉ kiểm tra điều kiện củamột giá trịđứng trước nó.
`?.` Ví dụ đoạn code sau bị lỗi:

```js
let user = null;

console.log(user.address?.street); // Uncaught TypeError: Cannot read properties of null (reading 'address')
```
`let user = null;

console.log(user.address?.street); // Uncaught TypeError: Cannot read properties of null (reading 'address')` Đoạn code trên bị lỗi vì?.đặt sauaddressnên chỉ dùng để kiểm tra giá trị củaaddress.
`?.` `address` `address` Nhưng vấn đề ở đây là, giá trịuserbằngnull. Nên bước truy cậpuser.addressđã bị lỗicannot read properties of null (reading 'address').
`user` `null` `user.address`"
424,Optional chaining trong Javascript,Một số chú ý về optional chaining,"Bên trên là nhữngưu điểmcủa Optional Chaining trong JavaScript. Nhưng không phải trường hợp nào cũng nên sử dụng optional chaining.
Sau đây là một số chú ý:
►Không nên lạm dụng optional chaining
Bạn chỉ nên sử dụng?.nếu giá trị trước?.bằngnullhoặcundefinedlàcó thể chấp nhận được.
`?.` `?.` `null` `undefined` Trong ví dụ trên, giá trị củaaddresstronguserlàkhông bắt buộc. Nên việc sử dụngaddress?.streetlà hoàn toàn hợp lý.
`address` `user` `address?.street` Về phíauser, nếu giá trị củausercũng không bắt buộc thì bạn nên sử dụnguser?.address.
`user` `user` `user?.address` Nhưng nếu giá trị củauserlàbắt buộc phải có(không có sẽ là sai logic code) thì bạn chỉ nên viếtuser.address.
`user` `user.address` Với cách viết này, nếuuserbằngnullhoặcundefinedthì bạn sẽ thấy lỗi hiển thị raconsole. Nhờ vậy, bạnbiết lỗi để sửa lại logiccho đúng (thay vì phải rất khó khăn để tìm ra lỗi sai).
`user` `null` `undefined` ►Biến trước?.phải được khai báo trước
`?.` Trường hợp biến đứng trước?.chưa được khai báo, bạn sẽ bị lỗi:
`?.` 
```js
console.log(user?.address);
// Uncaught ReferenceError: user is not defined
```
`console.log(user?.address);
// Uncaught ReferenceError: user is not defined` Nghĩa là giá trị trước?.phải được khai báo biến vớilet/const/varhoặc là một hàm (sử dụngfunction).
`?.` `let` `const` `var` `function`"
425,Optional chaining trong Javascript,"Optional chaining có thể làm ""short-circuiting""","Như mình đã nói ở trên,?.sẽ dừng lại quá trình xử lý nếu giá trị trước?.lànullhoặcundefined. Khi đó, những phần phía sau?.không được thực hiện.
`?.` `?.` `null` `undefined` `?.` Ví dụ:

```js
let user = null;
let x = 0;

user?.sayHi(x++); // sayHi không được thực thi vì user là null

console.log(x); // 0, giá trị của x không tăng lên
```
`let user = null;
let x = 0;

user?.sayHi(x++); // sayHi không được thực thi vì user là null

console.log(x); // 0, giá trị của x không tăng lên`"
426,Optional chaining trong Javascript,Các biến thể của optional chaining?.()và?.[],"`?.()` `?.[]` Optional chaining trong JavaScriptkhông phải là toán tửnhưng có thể sử dụng vớihàmvàtoán tử[].
`[]` ►Ví dụ?.với hàm:
`?.` 
```js
let userAdmin = {
  admin() {
    console.log(""I am admin"");
  },
};

let userGuest = {};
userAdmin.admin?.(); // I am admin
userGuest.admin?.(); // không có gì hiển thị
```
`let userAdmin = {
  admin() {
    console.log(""I am admin"");
  },
};

let userGuest = {};
userAdmin.admin?.(); // I am admin
userGuest.admin?.(); // không có gì hiển thị` Trong ví dụ trên,?.dùng để kiểm tra xemphương thứcadmincó tồn tại hay không. Nếu tồn tại thì phương thứcadminđược gọi.
`?.` `admin` `admin` Đối tượnguserAdmincó phương thứcadminnênuserAdmin.adminkhácnullvàundefined. Vì vậy,userAdmin.admin()được gọi.
`userAdmin` `admin` `userAdmin.admin` `null` `undefined` `userAdmin.admin()` Đối tượnguserGuestkhông có phương thứcadminnênuserGuest.adminbằngundefined. Do đó,userGuest.admin()không được gọi.
`userGuest` `admin` `userGuest.admin` `undefined` `userGuest.admin()` ►Ví dụ?.với toán tử[]:
`?.` `[]` 
```js
let user1 = {
  name: ""Alex"",
};

let user2 = null;

console.log(user1?.[""name""]); // Alex
console.log(user2?.[""name""]); // undefined
```
`let user1 = {
  name: ""Alex"",
};

let user2 = null;

console.log(user1?.[""name""]); // Alex
console.log(user2?.[""name""]); // undefined` Trong ví dụ trên,?.dùng để kiểm tra xemuser1vàuser2có tồn tại hay không. Nếu tồn tại thì dùng[""name""]để truy cập giá trị thuộc tính""name""trong các đối tượng.
`?.` `user1` `user2` `[""name""]` `""name""` Đối tượnguser1khácnullvàundefinednênuser1?.[""name""]tương đương vớiuser1.[""name""](bằngAlex).
`user1` `null` `undefined` `user1?.[""name""]` `user1.[""name""]` Đối tượnguser2bằngnullnênuser2?.[""name""]trả vềundefined.
`user2` `null` `user2?.[""name""]` `undefined` ► Ngoài ra, bạn có thể dùng?.vớidelete:
`?.` `delete` 
```js
delete user?.name; // xóa thuộc tính user.name nếu user tồn tại.
```
`delete user?.name; // xóa thuộc tính user.name nếu user tồn tại.` Lưu ý
Bạn có thể dùng?.đểđọc và xóathuộc tính trong object, nhưng không thểthay đổi giá trịcủa thuộc tính.
`?.` Ví dụ:

```js
let user = null;

user?.name = ""Alex"";
// Uncaught SyntaxError: Invalid left-hand side in assignment
```
`let user = null;

user?.name = ""Alex"";
// Uncaught SyntaxError: Invalid left-hand side in assignment` Bởi vìuserlànull, nênuser?.nametrả vềundefined. Bạn tưởng tượng câu lệnh trên trở thànhundefined = ""Alex""-hoàn toàn vô nghĩa.
`user` `null` `user?.name` `undefined` `undefined = ""Alex""`"
427,Optional chaining trong Javascript,Tổng kết,"Optional chaining trong JavaScript có ba dạng:
`obj?.prop` `obj.prop` `obj` `null` `undefined` `undefined` `obj?.[prop]` `obj[prop]` `obj` `null` `undefined` `undefined` `obj.method?.()` `obj.method()` `obj.method` `null` `undefined` `undefined` Về cơ bản, optional chaining kiểm tra giá trị phía trước?.khácnullvàundefinedthì thực hiện tiếp, nếu không thì dừng lại.
`?.` `null` `undefined` Vì vậy, optional chaining cho phép truy cập một cách an toàn vào các thuộc tính củaobject lồng nhau.
Mặc dù, optional chaining có nhiều lợi ích, nhưng bạn cũng cần chú ý tránh lạm dụng?..
`?.` Chỉ nên sử dụng optional chaining khi giá trị phía trước?.bằngnullhoặcundefinedlàcó thể chấp nhận được.
`?.` `null` `undefined`"
428,Các phương thức của kiểu dữ liệu nguyên thủy trong Javascript,Giới thiệu,"JavaScript cho phép bạn sử dụng kiểu nguyên thủy giống như object. Nghĩa là bạn có thểgọi các phương thức của kiểu nguyên thủygiống như gọi với object.
Nghe có vẻ vô lý nhưng đúng là như vậy. Trước khi đi vào chi tiết, bạn cần phân biệt rõ kiểu nguyên thủy và object."
429,Các phương thức của kiểu dữ liệu nguyên thủy trong Javascript,Phân biệt kiểu nguyên thủy và object,"►Kiểu nguyên thủy:
►Object:
`{}` `{ x: 1, y: 2 }` `function` `Date` `Set` `Map` Điều đặc biệt nhất của object là bạn có thểlưu hàm thành một thuộc tínhtrong object. Hàm đó gọi làphương thứccủa object, ví dụ:

```js
let p = {
  x: 1,
  y: 2,
  displayLog() {
    console.log(`{x: ${this.x}, y: ${this.y}}`);
  },
};

p.displayLog(); // {x: 1, y: 2}
```
`let p = {
  x: 1,
  y: 2,
  displayLog() {
    console.log(`{x: ${this.x}, y: ${this.y}}`);
  },
};

p.displayLog(); // {x: 1, y: 2}` Có nhiều object mặc định của JavaScript giúp bạn thao tác với ngày tháng, trình duyệt, xử lý lỗi,... Mỗi đối tượng có những thuộc tính và phương thức khác nhau.
Điều này giúp việc lập trình trở nên dễ dàng hơn. Nhưng ngược lại,object tốn nhiều tài nguyên để lưu trữ hơn.
Trên đây là sự khác nhau giữa kiểu nguyên thủy và object. Vậysử dụng các phương thức của kiểu nguyên thủynghĩa là thế nào?"
430,Các phương thức của kiểu dữ liệu nguyên thủy trong Javascript,Các phương thức của kiểu nguyên thủy,"Một nghịch lý khi tạo ra JavaScript là:
Để giải quyết vấn đề này, JavaScript thực hiện như sau:
Những ""wrapper object"" ứng với các kiểu dữ liệu nguyên thủy là:Number,String,BigInt,Boolean,Symbol. Những đối tượng này cung cấp các phương thức khác nhau để bạn làm việc với kiểu nguyên thủy.
`Number` `String` `BigInt` `Boolean` `Symbol` Lưu ý
Kiểu dữ liệunullvàundefinedkhông có ""wrapper object
`null` `undefined` Ví dụ một phương thức của string làstr.toUpperCase(). Phương thức này trả về giá trị string vớicác kí tự đều viết hoa.
`str.toUpperCase()` 
```js
let name = ""Alex"";
console.log(name.toUpperCase()); // ALEX
```
`let name = ""Alex"";
console.log(name.toUpperCase()); // ALEX` Quá trình xử lý hiểu đơn giản là:
`name` `name.toUpperCase()` `name` `toUpperCase` `toUpperCase()` `name` Đó là cách gọi phương thức của kiểu nguyên thủy mà vẫn đảm bảo kiểu nguyên thủy đơn giản và nhẹ nhất có thể."
431,Các phương thức của kiểu dữ liệu nguyên thủy trong Javascript,"Một số chú ý về các ""wrapper object""","Các hàm khởi tạoNumber,StringvàBooleanđược JavaScript Engine sử dụng nội bộ.
`Number` `String` `Boolean` Bạn có thể chủ động sử dụng các hàm khởi tạo này vớitoán tửnewđể tạo ra ""wrapper object"". Nhưng thực tế là bạnkhông nên, vì có nhiều trường hợp gây khó hiểu.
`new` 
```js
let zero = 0;
console.log(typeof zero); // number

let objZero = new Number(0);
console.log(typeof objZero); // object
```
`let zero = 0;
console.log(typeof zero); // number

let objZero = new Number(0);
console.log(typeof objZero); // object` Bạn thấy rằng,0là kiểunumbernhưngnew Number(0)lại là kiểuobject. Mà object thì luôn làtruthy.
`0` `new Number(0)` Ví dụ sử dụngnew Number(0)vớicâu lệnhif:
`new Number(0)` `if` 
```js
let objZero = new Number(0);

if (objZero) {
  console.log(""zero là truthy!""); // zero là truthy!
}
```
`let objZero = new Number(0);

if (objZero) {
  console.log(""zero là truthy!""); // zero là truthy!
}` Điều này đôi khi khá khó hiểu và dễ gây nhầm lẫn.
Vì vậy, lời khuyên là bạn không nên dùngNumber(),String()hayBoolean()với toánnewđể khởi tạo.
`Number()` `String()` `Boolean()` `new` Nhưng nếu sử dụng các hàm này mà không dùng toán tửnewthì sao?
`new` Việc không sử dụng toán tửnewvới các hàm trên lại khá hữu ích. Chúng sẽchuyển đổi kiểu dữ liệuvề kiểu nguyên thủy tương ứng.
`new` Ví dụ sử dụng hàmNumber()để chuyển đổi kiểu dữ liệu về number:
`Number()` 
```js
let num = Number(""123"");
console.log(num); // 123
console.log(typeof num); // number
```
`let num = Number(""123"");
console.log(num); // 123
console.log(typeof num); // number` Lưu ý
Không gọi được phương thức ứng với kiểunullvàundefined.
`null` `undefined` Gọi phương thức củanullvàundefinedđều bị lỗi như sau:
`null` `undefined` 
```js
console.log(null.toUpperCase());
// Uncaught TypeError:
// Cannot read properties of null (reading 'toUpperCase')

console.log(undefined.toUpperCase());
// Uncaught TypeError:
// Cannot read properties of undefined (reading 'toUpperCase')
```
`console.log(null.toUpperCase());
// Uncaught TypeError:
// Cannot read properties of null (reading 'toUpperCase')

console.log(undefined.toUpperCase());
// Uncaught TypeError:
// Cannot read properties of undefined (reading 'toUpperCase')`"
432,Các phương thức của kiểu dữ liệu nguyên thủy trong Javascript,Tổng kết,"Có thể gọi phương thức của kiểu nguyên thủy (trừnullvàundefined).
`null` `undefined` Cơ chế hoạt động là: JavaScript tạo ra một ""wrapper object"" chứa giá trị nguyên thủy và phương thức sử dụng. Sau khi phương thức gọi xong thì ""wrapper object"" được giải phóng.
Các bài viết sau mình sẽ đi vào chi tiết các phương thức hữu ích của:Number()vàString().
`Number()` `String()`"
433,Các phương thức của kiểu dữ liệu nguyên thủy trong Javascript,Thực hành,"Cho đoạn code sau:

```js
let str = ""Hello"";
str.prop = 1;
console.log(str.prop);
```
`let str = ""Hello"";
str.prop = 1;
console.log(str.prop);` Kết quả hiển thị là gì?
Xem đáp án
Kết quả là:undefined.
`undefined` Giải thích:
`str.prop = 1` `str` `prop` `str` `undefined` Chú ý:
Nếu sử dụngstrict modethì bạn sẽ bị lỗiUncaught TypeError: Cannot create property 'prop' on string 'Hello'
Tham khảo:Methods of primitives."
434,Phương thức trong Javascript,Giới thiệu,"Như mình đã đề cập trong bài viết đầu tiên vềobject, object trong JavaScript dùng để biểu diễn một đối tượng cụ thể. Mà đối tượng không chỉ có các thuộc tính, đối tượng còn cóhành động.
Sau đây, mình sẽ tìm hiểu vềphương thức của objectvà một từ khóa quan trọng, đó làthistrong JavaScript.
`this`"
435,Phương thức trong Javascript,Phương thức của Object,"Trong JavaScript, hành động của object được biểu diễn bởihàm. Ví dụ đối tượnguservới hành độngsayHello()như sau:
`user` `sayHello()` 
```js
let user = {
  name: ""Alex"",
  age: ""28"",
};

user.sayHello = function () {
  console.log(""Hello!"");
};
user.sayHello(); // Hello!
```
`let user = {
  name: ""Alex"",
  age: ""28"",
};

user.sayHello = function () {
  console.log(""Hello!"");
};
user.sayHello(); // Hello!` Trong ví dụ trên, mình sử dụngfunction expressionđể tạo một hàm, rồi gán hàm đó cho thuộc tínhsayHellocủauser.
`sayHello` `user` Tiếp theo, mình gọiuser.sayHello(). Và kết quả làHello!được hiển thị ra console.
`user.sayHello()` `Hello!` Có thể bạn chưa biết
📝 Một hàm là thuộc tính của object thì nó được gọi làphương thức.
Vì vậy,sayHellochính là một phương thức của objectuser.
`sayHello` `user` Ngoài cách sử dụng function expression như trên, bạn có thể dùngfunction declarationđể khai báo hàm như sau:

```js
let user = {
  name: ""Alex"",
  age: ""28"",
};

function sayHello() {
  console.log(""Hello!"");
}
user.sayHello = sayHello;
user.sayHello(); // Hello!
```
`let user = {
  name: ""Alex"",
  age: ""28"",
};

function sayHello() {
  console.log(""Hello!"");
}
user.sayHello = sayHello;
user.sayHello(); // Hello!` 💡 Cách sử dụng object để biểu diễn đối tượng với các thuộc tính và hành động như trên gọi làlập trình hướng đối tượnghayOOP."
436,Phương thức trong Javascript,Cú pháp ngắn gọn khai báo phương thức,"Trong các ví dụ trên, mình khởi tạo object xong rồi mới định nghĩa thêm phương thức. Bạn cũng có thểđịnh nghĩa phương thứctừ khi khởi tạo object.
Ví dụ khởi tạo object với phương thức:

```js
let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello: function () {
    console.log(""Hello!"");
  },
};

user.sayHello(); // Hello!
```
`let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello: function () {
    console.log(""Hello!"");
  },
};

user.sayHello(); // Hello!` Ngoài ra, bạn cũng có thểbỏ qua từ khóafunctionnhư sau:
`function` 
```js
let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    console.log(""Hello!"");
  },
};

user.sayHello(); // Hello!
```
`let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    console.log(""Hello!"");
  },
};

user.sayHello(); // Hello!` Trên đây là một số kiến thức cơ bản về phương thức của object. Sau đây, mình tiếp tục tìm hiểu về từ khóathistrong JavaScript.
`this`"
437,Phương thức trong Javascript,Từ khóa this trong JavaScript,"Một trường hợp khá phổ biến đối với object là việctruy cập vào thuộc tính của objectngay bên trong phương thức.
Ví dụ phương thứcsayHellotrên muốn truy cập và hiển thị giá trị của thuộc tínhname. Để làm được điều này, bạn có thể sử dụng từ khóathis.
`sayHello` `name` `this` Giá trị củathistrong JavaScript chính làobject gọi phương thức- đối tượng trước dấu chấm (.), ví dụ:
`this` `.` 
```js
let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    console.log(this.name + "" says Hello!"");
  },
};

user.sayHello(); // Alex says Hello!
```
`let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    console.log(this.name + "" says Hello!"");
  },
};

user.sayHello(); // Alex says Hello!` Khi chương trình thực thi, giá trị củathischính làuser. Hay nói cách khácthis.namechính làuser.name.
`this` `user` `this.name` `user.name` Vậy tại sao không sử dụng trực tiếpuserbên trong phương thứcsayHello?
`user` `sayHello` Ví dụ sử dụng trực tiếpuser:
`user` 
```js
let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    console.log(user.name + "" says Hello!"");
  },
};

user.sayHello(); // Alex says Hello!
```
`let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    console.log(user.name + "" says Hello!"");
  },
};

user.sayHello(); // Alex says Hello!` Kết quả vẫnđúng. Nhưng liệu vấn đề gì có thể xảy ra?
Giả sử, bạn muốncopy object dạng tham chiếutừusersangadminrồi ghi đè giá trị củauser:
`user` `admin` `user` 
```js
let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    console.log(user.name + "" says Hello!"");
  },
};

let admin = user;
user = null;
admin.sayHello(); // Uncaught TypeError: Cannot read properties of null (reading 'name')
```
`let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    console.log(user.name + "" says Hello!"");
  },
};

let admin = user;
user = null;
admin.sayHello(); // Uncaught TypeError: Cannot read properties of null (reading 'name')` Câu lệnh cuối cùng bị lỗi.
Vì khi bạn gọiadmin.sayHello(), bên trong phương thứcsayHellođang gọiuser.name. Mà giá trịuserđã bị gán bằngnull.
`admin.sayHello()` `sayHello` `user.name` `user` `null` Kết quả, bạn bị lỗiUncaught TypeError: Cannot read properties of null (reading 'name').
Nếu bạn dùngthis.namethì sẽ không bị lỗi trên. Vìthislúc này được hiểu làadmin.
`this.name` `this` `admin`"
438,Phương thức trong Javascript,"This trong JavaScript không được ""bind""","Khác với các ngôn ngữ lập trình khác, từ khóathiscó thể dùng ở bất kỳ hàm nào (không chỉ là phương thức của object),.
`this` Ví dụ sau đây không bị lỗi cú pháp:

```js
function sayHello() {
  console.log(this.name);
}
```
`function sayHello() {
  console.log(this.name);
}` Giá trị củathisđượcxác định trong thời gian chạy, phụ thuộc vào đối tượng gọi hàm, ví dụ:
`this` 
```js
let user1 = { name: ""Alex"" };
let user2 = { name: ""John"" };

function sayHello() {
  console.log(this.name);
}

// Sử dụng cùng 1 hàm cho 2 objects
user1.sayHi = sayHello;
user2.sayHi = sayHello;
user1.sayHi(); // Alex (this tương ứng với user1)
user2.sayHi(); // John (this tương ứng với user2)
```
`let user1 = { name: ""Alex"" };
let user2 = { name: ""John"" };

function sayHello() {
  console.log(this.name);
}

// Sử dụng cùng 1 hàm cho 2 objects
user1.sayHi = sayHello;
user2.sayHi = sayHello;
user1.sayHi(); // Alex (this tương ứng với user1)
user2.sayHi(); // John (this tương ứng với user2)` Bạn thấy rằng, tùy thuộc vào đối tượng gọi hàm làuser1hayuser2mà giá trị củathisđược xác định tương ứng.
`user1` `user2` `this` Điều này giải thích lý do tại saothis trong JavaScriptkhông được ""bind"".
Nếu hàmsayHellotrên được gọi trực tiếp không qua object nào thì sao?
`sayHello` Ví dụ gọi trực tiếpsayHello():
`sayHello()` 
```js
""use strict"";

function sayHello() {
  console.log(this);
}

sayHello(); // undefined
```
`""use strict"";

function sayHello() {
  console.log(this);
}

sayHello(); // undefined` Trong trường hợp này, giá trị củathislàundefinedởstrict mode. Nếu bạn truy cậpthis.namethì sẽ bị lỗiUncaught TypeError: Cannot read properties of undefined (reading 'name').
`this` `undefined` `this.name` 
```js
""use strict"";

function sayHello() {
  console.log(this.name);
}

sayHello();
// Uncaught TypeError: Cannot read properties of undefined (reading 'name')
```
`""use strict"";

function sayHello() {
  console.log(this.name);
}

sayHello();
// Uncaught TypeError: Cannot read properties of undefined (reading 'name')` Nếukhông sử dụng strict modethì giá trị củathissẽ làđối tượng global(đối tượngwindowtrên trình duyệt).
`this` `window` Khi đó,this.nametương đương vớiwindow.name(thường làundefined).
`this.name` `window.name` `undefined`"
439,Phương thức trong Javascript,Arrow function không có this,"Arrow functionlà một hàm đặc biệt, vì nó không cóthis.
`this` Nếu bạn truy cậpthisbên trong arrow function thì JavaScript sẽ hiểuthislà đối tượng ứng vớingữ cảnh gần nhất bên ngoài cóthislúc gọi hàm.
`this` `this` `this` Ví dụ dùng arrow function:

```js
let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    let arrowFunc = () => console.log(this.name);
    arrowFunc();
  },
};

user.sayHello(); // Alex
```
`let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello() {
    let arrowFunc = () => console.log(this.name);
    arrowFunc();
  },
};

user.sayHello(); // Alex` Trong ví dụ trên, ngữ cảnh gần nhất bên ngoài cóthislà phương thứcsayHello. Mà trong phương thứcsayHello, giá trị củathisđược xác định lúc gọiuser.sayHello().
`this` `sayHello` `sayHello` `this` `user.sayHello()` Do đó,thischính làuser. Và kết quả làthis.namebằnguser.name.
`this` `user` `this.name` `user.name` Nếu phương thứcsayHellođược gán trực tiếp bằng arrow function thì sao?
`sayHello` Ví dụ:

```js
let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello: () => console.log(this.name),
};

user.sayHello(); // undefined
```
`let user = {
  name: ""Alex"",
  age: ""28"",
  sayHello: () => console.log(this.name),
};

user.sayHello(); // undefined` Lúc này, ngữ cảnh gần nhất cóthislúc gọi hàm làglobal. Trong trường hợp không dùngstrict modethìthischính làwindow. Vì vậy,this.namebằngundefined.
`this` `this` `window` `this.name` `undefined`"
440,Phương thức trong Javascript,Tổng kết,"Sau đây là một số kiến thức cần nhớ về phương thức của object và từ khóathistrong JavaScript:
`this` `this` Từ khóathistrong JavaScript được xác định khi chạy chương trình:
`this` `this` `this` `object.method()` `this` `object` Đặc biệt,arrow function không cóthis. Giá trị củathistrong arrow function được lấy từ ngữ cảnh gần nhất bên ngoài lúc gọi hàm.
`this` `this`"
441,Phương thức trong Javascript,Thực hành,"Cho đoạn code sau:

```js
""use strict"";

function createUser(name) {
  return {
    name,
    ref: this,
  };
}

let alex = createUser(""Alex"");
console.log(alex.ref.name);
```
`""use strict"";

function createUser(name) {
  return {
    name,
    ref: this,
  };
}

let alex = createUser(""Alex"");
console.log(alex.ref.name);` Kết quả củaconsole.loglà gì?
`console.log` Xem đáp án
Kết quả:Uncaught TypeError: Cannot read properties of undefined (reading 'name').
Giải thích:
`this` `createUser` `this` `undefined` `user.ref` `undefined` `undefined` Triển khai objectcalculatorvới ba phương thức:
`calculator` `read()` `prompt` `add()` `mul()` 
```js
let calculator = {
  // viết code trong đây
};

calculator.read();
console.log(calculator.sum());
console.log(calculator.mul());
```
`let calculator = {
  // viết code trong đây
};

calculator.read();
console.log(calculator.sum());
console.log(calculator.mul());` Xem đáp án

```js
let calculator = {
  // Phương thức read()
  read() {
    this.a = +prompt(""Nhập vào số a:"", 0);
    this.b = +prompt(""Nhập vào số b:"", 0);
  },

  // Phương thức add()
  add() {
    return this.a + this.b;
  },

  // Phương thức mul()
  mul() {
    return this.a * this.b;
  },
};

calculator.read();
console.log(calculator.add());
console.log(calculator.mul());
```
`let calculator = {
  // Phương thức read()
  read() {
    this.a = +prompt(""Nhập vào số a:"", 0);
    this.b = +prompt(""Nhập vào số b:"", 0);
  },

  // Phương thức add()
  add() {
    return this.a + this.b;
  },

  // Phương thức mul()
  mul() {
    return this.a * this.b;
  },
};

calculator.read();
console.log(calculator.add());
console.log(calculator.mul());` Chú ý:hàmprompttrả về kết quả là string. Vì vậy, mình thêm toán tử+đằng trước đểchuyển đổi kiểu dữ liệuvề number, trước khi gán chothis.avàthis.b.
`prompt` `+` `this.a` `this.b` Cho đoạn code sau:

```js
// Khởi tạo obj
let obj = {
  count: 0,
  increase() {
    this.count++;
  },
  decrease() {
    this.count--;
  },
  showCount() {
    console.log(this.count);
  },
};

// Sử dụng obj
obj.increase();
obj.increase();
obj.decrease();
obj.showCount(); // 1
```
`// Khởi tạo obj
let obj = {
  count: 0,
  increase() {
    this.count++;
  },
  decrease() {
    this.count--;
  },
  showCount() {
    console.log(this.count);
  },
};

// Sử dụng obj
obj.increase();
obj.increase();
obj.decrease();
obj.showCount(); // 1` Hãy sửa lại các phương thức củaobjđể có thể gọi code theo kiểu:
`obj` 
```js
obj.increase().increase().decrease().showCount(); // 1
```
`obj.increase().increase().decrease().showCount(); // 1` Xem đáp án
Kĩ thuật này gọi làMethod chaining.
Ý tưởng là: trong mỗi phương thức, bạn sẽreturnvềthis(đối tượng hiện tại).
`return` `this` 
```js
// Khởi tạo obj
let obj = {
  count: 0,
  increase() {
    this.count++;
    return this;
  },
  decrease() {
    this.count--;
    return this;
  },
  showCount() {
    console.log(this.count);
    return this;
  },
};

// Sử dụng obj
obj.increase().increase().decrease().showCount(); // 1
```
`// Khởi tạo obj
let obj = {
  count: 0,
  increase() {
    this.count++;
    return this;
  },
  decrease() {
    this.count--;
    return this;
  },
  showCount() {
    console.log(this.count);
    return this;
  },
};

// Sử dụng obj
obj.increase().increase().decrease().showCount(); // 1` Bạn hiểu làincrease(),decrease()hayshowCount()đều trả vềthis- chính làobj.
`increase()` `decrease()` `showCount()` `this` `obj`"
442,Prototype trong JavaScript,Giới thiệu,"Khi lập trình, mọi người thường mong muốn có thểtái sử dụng code và mở rộng thêm các tính năng.
Ví dụ, bạn có một đối tượnguservới các thuộc tính và phương thức. Sau đó, bạn muốn tạo đối tượng mới làadminvàguestdựa trên đối tượnguser, nhưng không phảicopy-pastelại code mà chỉ sử dụng lại những thứ màusercó, rồi tạo thêm thuộc tính hoặc phương thức mới.
`user` `admin` `guest` `user` `user` Để làm được điều đó, bạn có thể sử dụngprototype trong JavaScriptđể kế thừa lại objectuser. Vậyprototype là gìvà cách sử dụng prototype như thế nào?
`user`"
443,Prototype trong JavaScript,Prototype trong JavaScript,"JavaScript object có một thuộc tính đặc biệt là[[Prototype]]với giá trị có thể lànullhoặc mộtobject. Và object đó gọi là mộtprototype.
`[[Prototype]]` `null` Khi bạn truy cập vào một thuộc tính từ object, nếu thuộc tính đó không tồn tại thì JavaScript sẽtự động tìm kiếm trong prototype. Trong lập trình, điều này gọi làkế thừa prototype.
[[Prototype]]là mộtthuộc tính ẩn, nhưng có nhiều cách đểcài đặt thuộc tính này. Và một trong những cách phổ biến nhất là sử dụng__proto__như sau:
`[[Prototype]]` `__proto__` 
```js
let animal = {
  eats: true,
};
let rabbit = {
  jumps: true,
};

rabbit.__proto__ = animal; // gán rabbit.[[Prototype]] = animal
```
`let animal = {
  eats: true,
};
let rabbit = {
  jumps: true,
};

rabbit.__proto__ = animal; // gán rabbit.[[Prototype]] = animal` Nếu bạn đọc một thuộc tính trongrabbitvà thuộc tính đó không tồn tại thì JavaScript sẽ tìm kiếm tronganimal.
`rabbit` `animal` 
```js
let animal = {
  eats: true,
};
let rabbit = {
  jumps: true,
};

rabbit.__proto__ = animal; // (*)
console.log(rabbit.eats); // true (**)console.log(rabbit.jumps); // true
```
`let animal = {
  eats: true,
};
let rabbit = {
  jumps: true,
};

rabbit.__proto__ = animal; // (*)
console.log(rabbit.eats); // true (**)console.log(rabbit.jumps); // true` Tại dòng(*), đối tượnganimalđược gán làm prototype cho đối tượngrabbit.
`(*)` `animal` `rabbit` Khi đọc thuộc tínhrabbit.eatstại(**), thuộc tínheatskhông tồn tại trongrabbitnên JavaScript tìm kiếm tronganimal. Dẫn đến kết quả làtruenhư trên.
`rabbit.eats` `(**)` `eats` `rabbit` `animal` `true` Bạn có thể gọianimallà một prototype củarabbithoặcrabbitkế thừa prototype từanimal.
`animal` `rabbit` `rabbit` `animal` Khi đó, nếuanimalcó nhiềuthuộc tính và phương thức hữu íchthì chúng cũng truy cập được từrabbit. Đó chính là lợi ích của kế thừa trong lập trình.
`animal` `rabbit` Ví dụ một phương thức tronganimalcó thể gọi từrabbit:
`animal` `rabbit` 
```js
let animal = {
  eats: true,
  walk() {
    console.log(""Animal walk"");
  },
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

// phương thức walk() được lấy thông qua prototype
rabbit.walk(); // Animal walk
```
`let animal = {
  eats: true,
  walk() {
    console.log(""Animal walk"");
  },
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

// phương thức walk() được lấy thông qua prototype
rabbit.walk(); // Animal walk` Ngoài ra, prototype có thểkế thừa móc nối nhauqua nhiều object như sau:

```js
let animal = {
  eats: true,
  walk() {
    console.log(""Animal walk"");
  },
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

let longEar = {
  earLength: 10,
  __proto__: rabbit,
};

// walk() được lấy thông qua các prototype móc nối nhau
longEar.walk(); // Animal walk
console.log(longEar.jumps); // true (lấy từ rabbit)
```
`let animal = {
  eats: true,
  walk() {
    console.log(""Animal walk"");
  },
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

let longEar = {
  earLength: 10,
  __proto__: rabbit,
};

// walk() được lấy thông qua các prototype móc nối nhau
longEar.walk(); // Animal walk
console.log(longEar.jumps); // true (lấy từ rabbit)` Trong ví dụ trên,animallà prototype củarabbitvàrabbitlà prototype củalongEar.
`animal` `rabbit` `rabbit` `longEar` Nếu bạn truy cập vào một thuộc tính hoặc phương thức tronglongEarvà chúng không tồn tại thì JavaScript sẽ tự động tìm kiếm ởrabbit, rồi đếnanimal.
`longEar` `rabbit` `animal`"
444,Prototype trong JavaScript,Giới hạn của prototype trong JavaScript,"Prototype trong JavaScript có một số giới hạn là:
►Không được phép kế thừa prototype vòng tròn.

```js
let animal = {
  eats: true,
};
let rabbit = {
  jumps: true,
};

// gán animal là prototype của rabbitrabbit.__proto__ = animal;// gán rabbit là prototype của animalanimal.__proto__ = rabbit;
// Lỗi: Cyclic __proto__ value
```
`let animal = {
  eats: true,
};
let rabbit = {
  jumps: true,
};

// gán animal là prototype của rabbitrabbit.__proto__ = animal;// gán rabbit là prototype của animalanimal.__proto__ = rabbit;
// Lỗi: Cyclic __proto__ value` ►Giá trị của__proto__có thể lànullhoặc là một object, nhưngcác kiểu dữ liệu khácđều bị bỏ qua.
`__proto__` `null` 
```js
let rabbit = {
  jumps: true,
  __proto__: 1, // bị bỏ qua};
};
```
`let rabbit = {
  jumps: true,
  __proto__: 1, // bị bỏ qua};
};` ►Prototype không hỗ trợ thay đổi giá trị thuộc tính.
Prototype chỉhỗ trợ việc đọc dữ liệu, còn việcthay đổi giá trị của thuộc tínhhayxóa thuộc tínhkhông được thực hiện trực tiếp prototype, ví dụ:

```js
let animal = {
  eats: true,
  walk() {
    console.log(""Animal walk"");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal, // gán animal là prototype của rabbit};

  // định nghĩa giá trị mới cho rabbit.walkrabbit.walk = function () {  console.log(""Rabbit walk"");};
  rabbit.walk(); // Rabbit walk - giá trị mớianimal.walk(); // Animal walk - giá trị cũ
}
```
`let animal = {
  eats: true,
  walk() {
    console.log(""Animal walk"");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal, // gán animal là prototype của rabbit};

  // định nghĩa giá trị mới cho rabbit.walkrabbit.walk = function () {  console.log(""Rabbit walk"");};
  rabbit.walk(); // Rabbit walk - giá trị mớianimal.walk(); // Animal walk - giá trị cũ
}` Trong ví dụ trên,rabbitkế thừa prototype củaanimal. Nhưng khi bạn gánrabbit.walkbằng một hàm mới thìanimal.walkvẫn không thay đổi.
`rabbit` `animal` `rabbit.walk` `animal.walk` thuộc tính__proto__không hoàn toàn giống như[[Prototype]]mà đây chỉ là mộtgetter/settercho[[Prototype]].
`__proto__` `[[Prototype]]` `getter/setter` `[[Prototype]]` Hiện tại,__proto__đã lỗi thời và bạn nên dùng các phương thứcObject.getPrototypeOfvàObject.setPrototypeOfđể thay thế.
`__proto__` `Object.getPrototypeOf` `Object.setPrototypeOf` Tuy nhiên, để đơn giản thì mình vẫn dùng__proto__làm minh họa cho các ví dụ.
`__proto__`"
445,Prototype trong JavaScript,Giá trịthiskhi kế thừa prototype,"`this` Giá trịthislà một giá trị đặc biệt trong object.
`this` Câu hỏi đặt ra là:khi kế thừa prototype, giá trị củathisbị ảnh hưởng như thế nào?
`this` Sau đây là một ví dụ:

```js
// đối tượng animal với các phương thức
let animal = {
  walk() {
    if (!this.isSleeping) {
      console.log(`I walk`);
    }
  },
  sleep() {
    this.isSleeping = true;
  },
};

// đối tượng rabbit kế thừa prototype của animal
let rabbit = {
  name: ""White Rabbit"",
  __proto__: animal,
};

// thay đổi giá trị rabbit.isSleeping
rabbit.sleep();

// kết quả
console.log(rabbit.isSleeping); // true
console.log(animal.isSleeping); // undefined
```
`// đối tượng animal với các phương thức
let animal = {
  walk() {
    if (!this.isSleeping) {
      console.log(`I walk`);
    }
  },
  sleep() {
    this.isSleeping = true;
  },
};

// đối tượng rabbit kế thừa prototype của animal
let rabbit = {
  name: ""White Rabbit"",
  __proto__: animal,
};

// thay đổi giá trị rabbit.isSleeping
rabbit.sleep();

// kết quả
console.log(rabbit.isSleeping); // true
console.log(animal.isSleeping); // undefined` Trong ví dụ trên, đối tượngrabbitkế thừa prototype củaanimal. Khi gọirabbit.sleep(), JavaScript tìm phương thứcsleep()trongrabbitnhưng không có, nên tự động tìm kiếm ởanimal.
`rabbit` `animal` `rabbit.sleep()` `sleep()` `rabbit` `animal` Khi câu lệnhthis.isSleeping = truexảy ra,đối tượng đang gọi phương thứcsleep()làrabbitnên giá trị củathistham chiếu đếnrabbit. Nghĩa làrabbit.isSleepingbằngtrue.
`this.isSleeping = true` `sleep()` `rabbit` `this` `rabbit` `rabbit.isSleeping` `true` Còn đối vớianimal, do chưa gọianimal.sleep()nên thuộc tínhisSleepingcũng chưa tồn tại tronganimal. Dẫn đến kết quả làanimal.isSleepingbằngundefined.
`animal` `animal.sleep()` `isSleeping` `animal` `animal.isSleeping` `undefined` Lưu ý
Việc kế thừa prototype không ảnh hưởng tớithis. Giá trị củathisluôn đượcxác định lúc chạyvà bằng đối tượng gọi phương thức - đối tượng đứng trước toán tử..
`this` `this` `.`"
446,Prototype trong JavaScript,Vòng lặpfor...inkhi kế thừa prototype,"`for...in` Vòng lặpfor...inlặp qua tất cả các thuộc tính có trong object cũng như thuộc tính kế thừa qua prototype, ví dụ:
`for...in` 
```js
let animal = {
  eats: true,
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

for (let prop in rabbit) console.log(prop);
// jumps
// eats
```
`let animal = {
  eats: true,
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

for (let prop in rabbit) console.log(prop);
// jumps
// eats` Nếu bạn chỉ muốn duyệt qua các thuộc tính trong object vàbỏ qua các thuộc tính kế thừathì có thể dùng một trong hai cách sau:
►Sử dụng phương thứcObject.keys()
`Object.keys()` Phương thứcObject.keys()trả về mảng chứa tất cả các key của object, bỏ qua các thuộc tính kế thừa.
`Object.keys()` 
```js
let animal = {
  eats: true,
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

console.log(Object.keys(rabbit)); // ['jumps']
```
`let animal = {
  eats: true,
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

console.log(Object.keys(rabbit)); // ['jumps']` ►Sử dụngobj.hasOwnProperty(key)để kiểm tra
`obj.hasOwnProperty(key)` Phương thứcobj.hasOwnProperty(key)trả vềtruenếukeyđúng là thuộc tính củaobj(không phải qua kế thừa), ngược lại thì trả vềfalse.
`obj.hasOwnProperty(key)` `true` `key` `obj` `false` 
```js
let animal = {
  eats: true,
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

for (let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);
  if (isOwn) {
    console.log(`Our: ${prop}`); // Our: jumps
  } else {
    console.log(`Inherited: ${prop}`); // Inherited: eats
  }
}
```
`let animal = {
  eats: true,
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

for (let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);
  if (isOwn) {
    console.log(`Our: ${prop}`); // Our: jumps
  } else {
    console.log(`Inherited: ${prop}`); // Inherited: eats
  }
}` Có thể bạn đang thắc là:phương thứchasOwnPropertyở đâu ra?
`hasOwnProperty` Thực tế, phương thứchasOwnPropertyđược kế thừa thông qua prototype củaObject, cụ thể làObject.prototype.hasOwnProperty. Nói cách khác, mọi object đều có thể truy cập được đến phương thứchasOwnProperty.
`hasOwnProperty` `Object` `Object.prototype.hasOwnProperty` `hasOwnProperty` Nhưng tại sao phương thứchasOwnPropertylại không xuất hiện trong vòng lặpfor...in?
`hasOwnProperty` `for...in` Bởi vì phương thứchasOwnPropertycó cờenumerable:false, tức là không xuất hiện trong vòng lặp.
`hasOwnProperty` `enumerable:false`"
447,Prototype trong JavaScript,Tổng kết,"Sau đây là những kiến thức cơ bản cần nhớ về prototype trong JavaScript:
`[[Prototype]]` `null` `obj.__proto__` `[[Prototype]]` `[[Prototype]]` `obj.method()` `method()` `this` `obj` `for...in`"
448,Prototype trong JavaScript,Thực hành,"Cho đoạn code sau:

```js
let animal = {
  jumps: null,
};
let rabbit = {
  __proto__: animal,
  jumps: true,
};

console.log(rabbit.jumps); // ? (1)

delete rabbit.jumps;
console.log(rabbit.jumps); // ? (2)

delete animal.jumps;
console.log(rabbit.jumps); // ? (3)
```
`let animal = {
  jumps: null,
};
let rabbit = {
  __proto__: animal,
  jumps: true,
};

console.log(rabbit.jumps); // ? (1)

delete rabbit.jumps;
console.log(rabbit.jumps); // ? (2)

delete animal.jumps;
console.log(rabbit.jumps); // ? (3)` Hỏi kết quả tại(1),(2)và(3)là gì?
`(1)` `(2)` `(3)` Xem đáp án
Kết quả:
`(1)` `true` `rabbit` `jumps` `(2)` `null` `delete rabbit.jumps` `jumps` `rabbit` `jumps` `animal` `null` `(3)` `undefined` `(2)` `jumps` `animal` `delete animal.jumps` `undefined` Cho các object sau:

```js
let head = {
  glasses: 1,
};

let table = {
  pen: 3,
};

let bed = {
  sheet: 1,
  pillow: 2,
};

let pockets = {
  money: 2000,
};
```
`let head = {
  glasses: 1,
};

let table = {
  pen: 3,
};

let bed = {
  sheet: 1,
  pillow: 2,
};

let pockets = {
  money: 2000,
};` Sử dụng__proto__để gán prototype cho các object sao cho việc tìm kiếm thuộc tính luôn được thực hiện theo thứ tự:pockets->bed->table->head.
`__proto__` `pockets` `bed` `table` `head` Ví dụpockets.pencó kết quả là3(tìm thấy ởtable) vàbed.glassesbằng1(tìm thấy ởhead).
`pockets.pen` `3` `table` `bed.glasses` `1` `head` Xem đáp án

```js
let head = {
  glasses: 1,
};

let table = {
  pen: 3,
  __proto__: head,
};

let bed = {
  sheet: 1,
  pillow: 2,
  __proto__: table,
};

let pockets = {
  money: 2000,
  __proto__: bed,
};
```
`let head = {
  glasses: 1,
};

let table = {
  pen: 3,
  __proto__: head,
};

let bed = {
  sheet: 1,
  pillow: 2,
  __proto__: table,
};

let pockets = {
  money: 2000,
  __proto__: bed,
};` Ví dụrabbitkế thừa từanimalnhư sau:
`rabbit` `animal` 
```js
let animal = {
  eat() {
    this.full = true;
  },
};

let rabbit = {
  __proto__: animal,
};

rabbit.eat();
```
`let animal = {
  eat() {
    this.full = true;
  },
};

let rabbit = {
  __proto__: animal,
};

rabbit.eat();` Nếu gọirabbit.eat()thì object nào nhận thuộc tínhfull?
`rabbit.eat()` `full` Xem đáp án
Đáp án làrabbit.
`rabbit` Vì khi kế thừa prototype, giá trị củathisvẫn tham chiếu đến đối tượng gọi phương thức, tức làrabbit.
`this` `rabbit` Tham khảo:Prototypal inheritance"
449,PubSub pattern trong Javascaript,Giới thiệu,"JavaScript PubSub Pattern, hay Publish / Subscribe Pattern, hay Events Pattern, là một loại JavaScript Design Pattern rất hữu dụng và khá phổ biến, được sử dụng trong rất nhiều thư viện JavaScript. Sau đây là một cách triển khai Pubsub Pattern cực kỳ ngắn gọn và dễ hiểu."
450,PubSub pattern trong Javascaript,Triển khai PubSub Pattern,"```js
let Events = (() => {
  let events = {};
  function on(eventName, fn) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(fn);
  }
  function off(eventName, fn) {
    if (events[eventName]) {
      for (let i = 0; i < events[eventName].length; i++) {
        if (events[eventName][i] === fn) {
          events[eventName].splice(i, 1);
          break;
        }
      }
    }
  }
  function emit(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach((fn) => fn(data));
    }
  }
  return {
    on: on,
    off: off,
    emit: emit,
  };
})();
```
`let Events = (() => {
  let events = {};
  function on(eventName, fn) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(fn);
  }
  function off(eventName, fn) {
    if (events[eventName]) {
      for (let i = 0; i < events[eventName].length; i++) {
        if (events[eventName][i] === fn) {
          events[eventName].splice(i, 1);
          break;
        }
      }
    }
  }
  function emit(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach((fn) => fn(data));
    }
  }
  return {
    on: on,
    off: off,
    emit: emit,
  };
})();` Trước tiên, bạn thấy rằng cách triển khai pattern này sử dụngRevealing Module Pattern, với 3functionđược public là:on,offvàemit.
Hàmoncó 2 tham số đầu vào:
Ví dụ:

```js
Events.on(""addItem"", onItemAdded);
```
`Events.on(""addItem"", onItemAdded);` Câu lệnh trên hiểu đơn giản là: khi có sự kiệnaddItemxảy ra thì sẽ gọi hàmonItemAdded.

```js
let events = {};
function on(eventName, fn) {
  events[eventName] = events[eventName] || [];
  events[eventName].push(fn);
}
```
`let events = {};
function on(eventName, fn) {
  events[eventName] = events[eventName] || [];
  events[eventName].push(fn);
}` Bạn có thể thấy rằng,eventslà mộtobjectrỗng. Sau này, mỗi thuộc tính (key) của events sẽ là tên của event được đăng ký. Giá trị của thuộc tính (value) là mộtmảngcủa các function.
Ban đầu events[eventName] sẽ làundefined, nên ta sẽ khởi tạoevents[eventName] = [] - là một mảng rỗng. Ngược lại, khi thành phần này đã tồn tại thì chỉ cầnpushhàm số mới vào mảng.
Đối với ví dụ trên, events[""addItem""] = [onItemAdded].
Giả sử, có 2 module khác cũng đăng ký sự kiện addItem:

```js
Events.on(""addItem"", updateItem1);
Events.on(""addItem"", updateItem2);
```
`Events.on(""addItem"", updateItem1);
Events.on(""addItem"", updateItem2);` Lúc này, events[""addItem""] = [onItemAdded, updateItem1, updateItem2].
Hàmoffcó 2 tham số đầu vào:
Ví dụ:

```js
Events.off(""addItem"", onItemAdded);
```
`Events.off(""addItem"", onItemAdded);` Câu lệnh trên sẽ bỏ đăng ký sự kiệnaddItemvới hàmonItemAdded. Hay nói cách khác, khi có sự kiện này xảy ra thì sẽ không gọi hàm onItemAdded nữa.

```js
function off(eventName, fn) {
  if (events[eventName]) {
    for (let i = 0; i < events[eventName].length; i++) {
      if (events[eventName][i] === fn) {
        events[eventName].splice(i, 1);
        break;
      }
    }
  }
}
```
`function off(eventName, fn) {
  if (events[eventName]) {
    for (let i = 0; i < events[eventName].length; i++) {
      if (events[eventName][i] === fn) {
        events[eventName].splice(i, 1);
        break;
      }
    }
  }
}` Hàm số này sẽ duyệt mảng ứng vớieventNamevà kiểm tra tất cả các hàm số thành phần trong mảng đó. Nếu gặp hàm số nào trùng với hàm số cần bỏ đăng ký thì sẽ bỏ hàm số đó ra khỏi mảng thông qua hàmsplice.
Đối với ví dụ trên, hàm số onItemAdded sẽ bị loại bỏ khỏi mảng events[""addItem""]. Do đó, kết quả là events[""addItem""] = [updateItem1, updateItem2].
Hàmemitcó 2 tham số:
Ví dụ:

```js
Events.emit(""addItem"", {
  name: ""apple"",
  quantity: 2,
});
```
`Events.emit(""addItem"", {
  name: ""apple"",
  quantity: 2,
});` Câu lệnh trên kích hoạt sự kiện addItem. Khi đó, tất cả những hàm số nào đã được đăng ký sự kiện với hàmEvents.onở trên, sẽ được gọi, với đối số là object{name: ""apple"", quantity: 2};

```js
function emit(eventName, data) {
  if (events[eventName]) {
    events[eventName].forEach((fn) => fn(data));
  }
}
```
`function emit(eventName, data) {
  if (events[eventName]) {
    events[eventName].forEach((fn) => fn(data));
  }
}` Hàm này sẽ duyệt toàn bộ mảng ứng vớieventNamesử dụng phương thứcforEach. Sau đó, mỗi hàm số trong mảng sẽ được gọi và truyền vào đối số là data.
Trong ví dụ trên,events\[""addItem""\] = \[updateItem1, updateItem2\]. Do đó, khi event addItem được kích hoạt, hàm sốupdateItem1({ name : ""apple"", quantity: 2 })vàupdateItem2({ name : ""apple"", quantity: 2 })sẽ được thực hiện.
`events\[""addItem""\] = \[updateItem1, updateItem2\]` `updateItem1({ name : ""apple"", quantity: 2 })` `updateItem2({ name : ""apple"", quantity: 2 })`"
451,PubSub pattern trong Javascaript,Ví dụ sử dụng Pubsub Pattern,"Trong đó, module A sẽ thực hiệnaddItemvà kích hoạt sự kiện. Và module B, module C sẽ đăng kí sự kiện addItem và với hàm số thực thi làonAddingItem.
Chú ý:"
452,PubSub pattern trong Javascaript,Kết luận,"Trên đây là cách triển khai PubSub Pattern và ví dụ đơn giản mô tả cách áp dụng pattern này. Nếu có phần nào mình giải thích chưa được rõ thì các bạn cứ đặt câu hỏi thoải mái nhé.
Xin chào và hẹn gặp lại bạn ở bài viết tiếp theo, thân ái!"
453,Sắp xếp mảng tiếng việt trong Javascript,Giới thiệu,"Sắp xếp là một bài toán không thể thiếu trong lập trình. Tuy nhiên, nhiều bạn vẫn đang gặp khó khăn với việcsắp xếp Tiếng việt trong JavaScript.
Vì vậy, mình sẽ giới thiệu với bạn về cách mình giải quyết bài toán sắp xếp Tiếng Việt này."
454,Sắp xếp mảng tiếng việt trong Javascript,Nhắc lại hàmsort()trong JavaScript,"`sort()` Trong bài viết vềsắp xếp mảng, mình đã giới thiệu với bạn khá chi tiết về hàmsort()và cách triển khai một số thuật toán sắp xếp cơ bản.
Bây giờ, mình sẽ nhắc lại hàmsort()một chút cho bạn tiện theo dõi. Vì phần sau đây sử dụng hàm này để sắp xếp Tiếng Việt trong JavaScript.
`sort()` Cú pháp cơ bản của hàmsort(compareFunction)là:
`sort(compareFunction)` 
```js
arr.sort(compareFunction);
```
`arr.sort(compareFunction);` ► Tham sốcompareFunction:
`compareFunction` `compareFunction(a, b)` `0` `a` `b` `compareFunction(a, b)` `0` `a` `b` `compareFunction(a, b)` `0` `a` `b` ► Giá trị trả về:
Ví dụ:

```js
const a = [""c"", ""g"", ""w"", ""a""];
const b = a.sort();

console.log(a); // [""a"", ""c"", ""g"", ""w""]
console.log(b); // [""a"", ""c"", ""g"", ""w""]
```
`const a = [""c"", ""g"", ""w"", ""a""];
const b = a.sort();

console.log(a); // [""a"", ""c"", ""g"", ""w""]
console.log(b); // [""a"", ""c"", ""g"", ""w""]` Trên đây là những kiến thức cơ bản về cách sử dụng hàmsort()trong JavaScript. Tiếp theo, mình bắt đầu áp dụng hàmsort()để sắp xếp Tiếng Việt trong JavaScript.
`sort()` `sort()`"
455,Sắp xếp mảng tiếng việt trong Javascript,Sắp xếp Tiếng Việt trong JavaScript,"Giả sử mình có một mảng string Tiếng Việt là tên một số tỉnh thành tại Việt Nam:

```js
const provinces = [
  ""Hà Giang"",
  ""Hà Nam"",
  ""Hà Nội"",
  ""Hà Tĩnh"",
  ""Hòa Bình"",
  ""Hưng Yên"",
  ""Hải Dương"",
  ""Hải Phòng"",
  ""Hậu Giang"",
];
```
`const provinces = [
  ""Hà Giang"",
  ""Hà Nam"",
  ""Hà Nội"",
  ""Hà Tĩnh"",
  ""Hòa Bình"",
  ""Hưng Yên"",
  ""Hải Dương"",
  ""Hải Phòng"",
  ""Hậu Giang"",
];` Mình cần sắp xếp các tên này theo thứ tự tăng dần của bảng chữ cái Tiếng Việt. Kết quả mong muốn thu được là:

```js
const sorted = [
  ""Hà Giang"",
  ""Hà Nam"",
  ""Hà Nội"",
  ""Hà Tĩnh"",
  ""Hải Dương"",
  ""Hải Phòng"",
  ""Hậu Giang"",
  ""Hòa Bình"",
  ""Hưng Yên"",
];
```
`const sorted = [
  ""Hà Giang"",
  ""Hà Nam"",
  ""Hà Nội"",
  ""Hà Tĩnh"",
  ""Hải Dương"",
  ""Hải Phòng"",
  ""Hậu Giang"",
  ""Hòa Bình"",
  ""Hưng Yên"",
];` Trước tiên, mình thử sắp xếp mảng trên bằng hàmsort()thông thường.
`sort()` Vì mặc định hàmsort()sẽ sắp xếp string theo thứ tự tăng dần nên mình không cần truyền vàocompareFunction.
`sort()` Do đó, kết quả thu được như sau:

```js
const result = provinces.sort();
console.log(result);

/*
    [
      ""Hà Giang"",
      ""Hà Nam"",
      ""Hà Nội"",
      ""Hà Tĩnh"",
      ""Hòa Bình"",
      ""Hưng Yên"",
      ""Hải Dương"",
      ""Hải Phòng"",
      ""Hậu Giang""
    ]
    */
```
`const result = provinces.sort();
console.log(result);

/*
    [
      ""Hà Giang"",
      ""Hà Nam"",
      ""Hà Nội"",
      ""Hà Tĩnh"",
      ""Hòa Bình"",
      ""Hưng Yên"",
      ""Hải Dương"",
      ""Hải Phòng"",
      ""Hậu Giang""
    ]
    */` Kết quả trên làsai so với mong muốn ban đầu. Vậy mình phải làm sao đây?
Nguyên nhân hàmsort()trên thực hiện sai là vì nó đang so sánh string với Tiếng Anh. Vì vậy, mấu chốt của vấn đề là: làm sao có thể so sánh string với Tiếng Việt để đưa vào hàmsort()?
`sort()` `sort()` Câu trả lời là: sử dụng phương thứclocaleCompare()với cú pháp cơ bản là:
`localeCompare()` 
```js
a.localeCompare(b);
```
`a.localeCompare(b);` Có 3 trường hợp xảy ra với kết quả trả về:
`0` `a` `b` `0` `a` `b` `0` `a` `b` Thật là trùng hợp, cách hoạt động của phương thứclocaleCompare()lại hoàn toàn giống vớicompareFunctionbên trên. Vì vậy, mình có thể áp dụng ngay để sắp xếp Tiếng Việt như sau:
`localeCompare()` `compareFunction` 
```js
const result = provinces.sort((a, b) => a.localeCompare(b));
console.log(result);

/*
    [
      ""Hà Giang"",
      ""Hà Nam"",
      ""Hà Nội"",
      ""Hà Tĩnh"",
      ""Hải Dương"",
      ""Hải Phòng"",
      ""Hậu Giang"",
      ""Hòa Bình"",
      ""Hưng Yên""
    ]
    */
```
`const result = provinces.sort((a, b) => a.localeCompare(b));
console.log(result);

/*
    [
      ""Hà Giang"",
      ""Hà Nam"",
      ""Hà Nội"",
      ""Hà Tĩnh"",
      ""Hải Dương"",
      ""Hải Phòng"",
      ""Hậu Giang"",
      ""Hòa Bình"",
      ""Hưng Yên""
    ]
    */` Kết quả thu được bây giờ hoàn toàn đúng với mong đợi."
456,Sắp xếp mảng tiếng việt trong Javascript,Tổng kết,"Như vậy là mình đã sắp xếp Tiếng Việt trong JavaScript một cách đơn giản rồi phải không?
Ngoài cách làm trên ra, bạn còn biết phương pháp nào khác để sắp xếp Tiếng Việt trong JavaScript không?
Nếu có thì bạn hãy chia sẻ dưới phần bình luận nhé!"
457,Sắp xếp mảng trong Javascript,Giới thiệu,"Bài viết sau đây tập trung tìm hiểu vềphương thức sắp xếp mảng trong JavaScript. Và cách triển khai một sốthuật toán sắp xếp mảng cơ bản.
Nói về sắp xếp mảng thì đây là một vấn đề vô cùng phổ biến trong các chương trình. Nhiều ứng dụng (từ điển, danh bạ, quản lý tài khoản,...) thường có chức năng sắp xếp theo thứ tự từ điển (a-z). Việc sắp xếp giúp người quản lý và người dùng dễ dàng tìm kiếm nội dung hơn.
Hiện tại có rất nhiều thuật toán sắp xếp với độ phức tạp khác nhau. Ví dụ các thuật toán sắp xếp mảng là: selection sort, insertion sort, binary insertion sort, interchange sort, bubble sort, shaker sort, quick sort, merge sort, heap sort,...
Bạn không cần thiết phải viết lại lại những thuật toán sắp xếp này. Vì JavaScript hỗ trợ sẵn mộtfunctionđể sắp xếp."
458,Sắp xếp mảng trong Javascript,Cú pháp hàm sắp xếp mảng trong JavaScript,"Hàm sắp xếp mảng trong JavaScript làsort():
`sort()` 
```js
arr.sort();
arr.sort(compareFunction);
```
`arr.sort();
arr.sort(compareFunction);` ► Tham sốcompareFunction:
`compareFunction` ► Giá trị trả về:

```js
let a = [""c"", ""g"", ""w"", ""a""];
let b = a.sort();

console.log(a); // [""a"", ""c"", ""g"", ""w""]
console.log(b); // [""a"", ""c"", ""g"", ""w""]
```
`let a = [""c"", ""g"", ""w"", ""a""];
let b = a.sort();

console.log(a); // [""a"", ""c"", ""g"", ""w""]
console.log(b); // [""a"", ""c"", ""g"", ""w""]`"
459,Sắp xếp mảng trong Javascript,Tìm hiểu compareFunction,"HàmcompareFunctiondùng để xác địnhthứ tự sắp xếp mảng.
`compareFunction` Giả sử,avàblà hai phần tử dùng để so sánh:
`a` `b` `compareFunction(a, b)` `0` `a` `b` `compareFunction(a, b)` `0` `a` `b` `compareFunction(a, b)` `0` `a` `b`"
460,Sắp xếp mảng trong Javascript,Sắp xếp mảng number,"JavaScript hỗ trợsắp xếp nhiều kiểu dữ liệu. Tuy nhiên, phổ biến nhất vẫn lànumbers.
Và như mình đã nói ở trên, mặc định hàmsort()sẽ so sánh theo kiểu string để sắp xếp. Do đó, kết quả sẽ như sau:
`sort()` 
```js
let a = [9, 100, 45, 33];

console.log(a.sort());
// [100, 33, 45, 9]
```
`let a = [9, 100, 45, 33];

console.log(a.sort());
// [100, 33, 45, 9]` Kết quả trên làhoàn toàn chính xác. Vì khi so sánh theo kiểu string thì thứ tự là:'1' < '3' < '4' < '9'.
`'1' < '3' < '4' < '9'` Vì vậy, để sắp xếp chúng theo kiểunumbersthì bạn cần phải sử dụng hàmcompareFunction.
`compareFunction` `compareNumbers` 
```js
function compareNumbers(a, b) {
  return a - b;
}

let a = [9, 100, 45, 33];
console.log(a.sort(compareNumbers));
// [9, 33, 45, 100]
```
`function compareNumbers(a, b) {
  return a - b;
}

let a = [9, 100, 45, 33];
console.log(a.sort(compareNumbers));
// [9, 33, 45, 100]` Khianhỏ hơnbthìa - b < 0làtrue. Theo đúng mô tả của hàmcompareFunctionthì suy raasẽ đứng trướcb.
`a` `b` `a - b < 0` `true` `compareFunction` `a` `b` Nghĩa là số nhỏ hơn sẽ đứng trước. Áp dụng quy tắc này, ta được mảng các sốsắp xếp theo thứ tự tăng dần.
Ngoài cách viếthàm độc lậpnhư trên, bạn có thể áp dụngarrow functioncho ngắn gọn:

```js
let a = [9, 100, 45, 33];

a.sort((a, b) => a - b);

console.log(a);
// [9, 33, 45, 100]
```
`let a = [9, 100, 45, 33];

a.sort((a, b) => a - b);

console.log(a);
// [9, 33, 45, 100]` Để sắp xếp mảng numberstheo thứ tự giảm dần, bạn chỉ cần thay đổi nội dung hàmcompareNumbers. Thay vì trả vềa - bthì bây giờ trả vềb - a.
`compareNumbers` `a - b` `b - a` 
```js
let a = [9, 100, 45, 33];

a.sort((a, b) => b - a);
console.log(a);
// [100, 45, 33, 9]
```
`let a = [9, 100, 45, 33];

a.sort((a, b) => b - a);
console.log(a);
// [100, 45, 33, 9]` Bây giờ, khianhỏ hơnbthìb - a > 0. Suy ra,asẽ đứng saub. Nói cách khác, số nhỏ hơn sẽ đứng sau. Do đó, kết quả thu được làdãy số giảm dầnnhư trên.
`a` `b` `b - a > 0` `a` `b` Trên đây là cách sử dụng hàmsort()để sắp xếp mảng trong JavaScript.
`sort()` Nhưng nếu bạn không muốn sử dụng hàm mặc định này, bạn vẫn có thể tự viết lại hàm sắp xếp sử dụng một số thuật toán sắp xếp cơ bản."
461,Sắp xếp mảng trong Javascript,Sắp xếp mảng trong JavaScript sử dụng thuật toán,"Nếu bạn từng học ít nhất một ngôn ngữ lập trình như C/C++, Java,... thì mình dám chắc là bạn đãtừng triển khai thuật toán sắp xếprồi.
Một số thuật toán cơ bản như:
Sau đây, mình chia sẻ cách triển khai các thuật toán sắp xếp mảng trong JavaScript.

```js
function selectionSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    let idmin = i;
    for (let j = i + 1; j < array.length; j++) {
      if (array[j] < array[idmin]) idmin = j;
    }

    // swap
    let t = array[i];
    array[i] = array[idmin];
    array[idmin] = t;
  }
}
```
`function selectionSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    let idmin = i;
    for (let j = i + 1; j < array.length; j++) {
      if (array[j] < array[idmin]) idmin = j;
    }

    // swap
    let t = array[i];
    array[i] = array[idmin];
    array[idmin] = t;
  }
}` 
```js
function insertionSort(array) {
  let pos, x;
  for (let i = 1; i < array.length; i++) {
    pos = i - 1;
    x = array[i];
    while (pos >= 0 && array[pos] > x) {
      array[pos + 1] = array[pos];
      pos--;
    }
    array[pos + 1] = x;
  }
}
```
`function insertionSort(array) {
  let pos, x;
  for (let i = 1; i < array.length; i++) {
    pos = i - 1;
    x = array[i];
    while (pos >= 0 && array[pos] > x) {
      array[pos + 1] = array[pos];
      pos--;
    }
    array[pos + 1] = x;
  }
}` 
```js
function binaryInsertionSort(array) {
  let l, r, m, x;
  for (let i = 1; i < array.length; i++) {
    l = 0;
    r = i - 1;
    x = array[i];

    while (l <= r) {
      m = Math.floor((l + r) / 2);
      if (array[m] > x) r = m - 1;
      else l = m + 1;
    }

    for (let j = i; j > l; j--) array[j] = array[j - 1];
    array[l] = x;
  }
}
```
`function binaryInsertionSort(array) {
  let l, r, m, x;
  for (let i = 1; i < array.length; i++) {
    l = 0;
    r = i - 1;
    x = array[i];

    while (l <= r) {
      m = Math.floor((l + r) / 2);
      if (array[m] > x) r = m - 1;
      else l = m + 1;
    }

    for (let j = i; j > l; j--) array[j] = array[j - 1];
    array[l] = x;
  }
}` 
```js
function interChangeSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    for (let j = i + 1; j < array.length; j++) {
      if (array[j] < array[i]) {
        let t = array[i];
        array[i] = array[j];
        array[j] = t;
      }
    }
  }
}
```
`function interChangeSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    for (let j = i + 1; j < array.length; j++) {
      if (array[j] < array[i]) {
        let t = array[i];
        array[i] = array[j];
        array[j] = t;
      }
    }
  }
}` 
```js
function bubbleSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    for (let j = array.length - 1; j > i; j--) {
      if (array[j] < array[j - 1]) {
        let t = array[j];
        array[j] = array[j - 1];
        array[j - 1] = t;
      }
    }
  }
}
```
`function bubbleSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    for (let j = array.length - 1; j > i; j--) {
      if (array[j] < array[j - 1]) {
        let t = array[j];
        array[j] = array[j - 1];
        array[j - 1] = t;
      }
    }
  }
}` 
```js
function shakerSort(array) {
  let left, right, k;

  left = 0;
  right = array.length - 1;
  k = array.length - 1;

  while (left < right) {
    for (let j = right; j > left; j--) {
      if (array[j] < array[j - 1]) {
        let t = array[j];
        array[j] = array[j - 1];
        array[j - 1] = t;
        k = j;
      }
    }
    left = k;

    for (let j = left; j < right; j++) {
      if (array[j] > array[j + 1]) {
        let t = array[j];
        array[j] = array[j + 1];
        array[j + 1] = t;
        k = j;
      }
    }
    right = k;
  }
}
```
`function shakerSort(array) {
  let left, right, k;

  left = 0;
  right = array.length - 1;
  k = array.length - 1;

  while (left < right) {
    for (let j = right; j > left; j--) {
      if (array[j] < array[j - 1]) {
        let t = array[j];
        array[j] = array[j - 1];
        array[j - 1] = t;
        k = j;
      }
    }
    left = k;

    for (let j = left; j < right; j++) {
      if (array[j] > array[j + 1]) {
        let t = array[j];
        array[j] = array[j + 1];
        array[j + 1] = t;
        k = j;
      }
    }
    right = k;
  }
}` 
```js
function quickSort(array, left, right) {
  let l = left,
    r = right;
  let m = Math.floor((l + r) / 2);
  let pivot = array[m];

  while (l <= r) {
    while (array[l] < pivot) l++;
    while (array[r] > pivot) r--;
    if (l <= r) {
      let t = array[l];
      array[l] = array[r];
      array[r] = t;
      l++;
      r--;
    }
  }

  if (l < right) quickSort(array, l, right);
  if (r > left) quickSort(array, left, r);
}
```
`function quickSort(array, left, right) {
  let l = left,
    r = right;
  let m = Math.floor((l + r) / 2);
  let pivot = array[m];

  while (l <= r) {
    while (array[l] < pivot) l++;
    while (array[r] > pivot) r--;
    if (l <= r) {
      let t = array[l];
      array[l] = array[r];
      array[r] = t;
      l++;
      r--;
    }
  }

  if (l < right) quickSort(array, l, right);
  if (r > left) quickSort(array, left, r);
}` 
```js
function merge(array, left, m, right) {
  let l = left,
    r = m + 1;
  let tmp = [];

  while (l <= m && r <= right) {
    if (array[l] < array[r]) tmp.push(array[l++]);
    else tmp.push(array[r++]);
  }

  while (l <= m) tmp.push(array[l++]);
  while (r <= right) tmp.push(array[r++]);

  for (let i = 0; i < tmp.length; i++) array[i + left] = tmp[i];
}

function mergeSort(array, left, right) {
  if (left < right) {
    let m = Math.floor((left + right) / 2);
    mergeSort(array, left, m);
    mergeSort(array, m + 1, right);
    merge(array, left, m, right);
  }
}
```
`function merge(array, left, m, right) {
  let l = left,
    r = m + 1;
  let tmp = [];

  while (l <= m && r <= right) {
    if (array[l] < array[r]) tmp.push(array[l++]);
    else tmp.push(array[r++]);
  }

  while (l <= m) tmp.push(array[l++]);
  while (r <= right) tmp.push(array[r++]);

  for (let i = 0; i < tmp.length; i++) array[i + left] = tmp[i];
}

function mergeSort(array, left, right) {
  if (left < right) {
    let m = Math.floor((left + right) / 2);
    mergeSort(array, left, m);
    mergeSort(array, m + 1, right);
    merge(array, left, m, right);
  }
}` 
```js
function heapify(array, N, i) {
  let left = 2 * i + 1,
    right = 2 * i + 2,
    largest;

  if (left < N && array[left] > array[i]) largest = left;
  else largest = i;

  if (right < N && array[right] > array[largest]) largest = right;

  if (largest != i) {
    let t = array[i];
    array[i] = array[largest];
    array[largest] = t;
    heapify(array, N, largest);
  }
}

function buildHeap(array) {
  let m = Math.floor(array.length / 2 - 1);
  for (let i = m; i >= 0; i--) heapify(array, array.length, i);
}

function heapSort(array) {
  buildHeap(array);

  for (let i = array.length - 1; i >= 0; i--) {
    let t = array[0];
    array[0] = array[i];
    array[i] = t;

    heapify(array, i, 0);
  }
}
```
`function heapify(array, N, i) {
  let left = 2 * i + 1,
    right = 2 * i + 2,
    largest;

  if (left < N && array[left] > array[i]) largest = left;
  else largest = i;

  if (right < N && array[right] > array[largest]) largest = right;

  if (largest != i) {
    let t = array[i];
    array[i] = array[largest];
    array[largest] = t;
    heapify(array, N, largest);
  }
}

function buildHeap(array) {
  let m = Math.floor(array.length / 2 - 1);
  for (let i = m; i >= 0; i--) heapify(array, array.length, i);
}

function heapSort(array) {
  buildHeap(array);

  for (let i = array.length - 1; i >= 0; i--) {
    let t = array[0];
    array[0] = array[i];
    array[i] = t;

    heapify(array, i, 0);
  }
}` Trên đây là những vấn đề cơ bản về sắp xếp mảng trong JavaScript, cùng với một số thuật toán sắp xếp mảng 1 chiều. Theo mình, đây là những kiến thức cơ bản và có thể được áp dụng rất nhiều."
462,Javascript Service Worker là gì,Giới thiệu,"Xin chào bạn! Không biết bạn đã từng nghe vềOffline Web Appchưa? Có thể bạn đã biết hoặc chưa. Hiểu một cách đơn giản, Offline Web App là một ứng dụng web có thể chạy ngay cả khi không có kết nối internet. Bây giờ, mình phân tích chút xíu nhé. Có 2 thứ cần thiết để web app có thể chạy được là: resources (html, js, css, ảnh,...) và định tuyến. Thì thằng mà chúng ta sẽ tìm hiểu sau đây làJavaScript Service Workercó thể đáp ứng được cả hai việc đó. Vậy..."
463,Javascript Service Worker là gì,JavaScript Service Worker là gì?,"Service Worker là một script mà trình duyệt chạy ở dưới background, tách khỏi trang web và giúp thực hiện các tính năng không cần đến trang web, hay tương tác người dùng.
Service Worker có một số đặc điểm quan trọng là:
Với Service Worker chúng ta có thể:
Có lẽ đến đây thì bạn đã hiểu phần nào về JavaScript Service Worker rồi. Tiếp theo, chúng ta sẽ tìm hiểu về cách sử dụng nó."
464,Javascript Service Worker là gì,Đăng ký JavaScript Service Worker,"Giả sử, mình có một trang web đơn giản và cấu trúc các tệp tin như sau:

```js
index.html;
service_worker.js;
main.js;
style.css;
```
`index.html;
service_worker.js;
main.js;
style.css;` Lúc này, mình sẽ đăng ký Service Worker trong filemain.js:

```js
if (""serviceWorker"" in navigator) {
  navigator.serviceWorker
    .register(""service_worker.js"")
    .then((reg) => {
      console.log(""Registered service worker"");
    })
    .catch((err) => {
      console.log(""Register service worker failed"", err);
    });
}
```
`if (""serviceWorker"" in navigator) {
  navigator.serviceWorker
    .register(""service_worker.js"")
    .then((reg) => {
      console.log(""Registered service worker"");
    })
    .catch((err) => {
      console.log(""Register service worker failed"", err);
    });
}` Có một số lưu ý quan trọng khi đăng ký Service Worker là:
Mình có tham khảo được một ví dụ mẫu về cách triển khai JavaScript Service Worker như sau (mình không nhớ mình tham khảo được ở đâu, chỉ nhớ là của Google, nên mong tác giả của script thông cảm):

```js
/*
 * Names of the two caches used in this version of the service worker.
 * Change to v2, etc. when you update any of the local resources, which will
 * in turn trigger the install event again.
 */
const PRECACHE = ""my-precache-v1"";
const RUNTIME = ""my-runtime"";

// A list of local resources we always want to be cached.
const PRECACHE_URLS = [
  ""index.html"",
  ""./"", // Alias for index.html
  ""style.css"",
  ""main.js"",
];

// The install handler takes care of precaching the resources we always need.
self.addEventListener(""install"", (event) => {
  event.waitUntil(
    caches
      .open(PRECACHE)
      .then((cache) => cache.addAll(PRECACHE_URLS))
      .then(self.skipWaiting())
  );
});

// The activate handler takes care of cleaning up old caches.
self.addEventListener(""activate"", (event) => {
  const currentCaches = [PRECACHE, RUNTIME];
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return cacheNames.filter(
          (cacheName) => !currentCaches.includes(cacheName)
        );
      })
      .then((cachesToDelete) => {
        return Promise.all(
          cachesToDelete.map((cacheToDelete) => {
            return caches.delete(cacheToDelete);
          })
        );
      })
      .then(() => self.clients.claim())
  );
});

/*
 * The fetch handler serves responses for same-origin resources from a cache.
 * If no response is found, it populates the runtime cache with the response
 * from the network before returning it to the page.
 */
self.addEventListener(""fetch"", (event) => {
  // Skip cross-origin requests, like those for Google Analytics.
  if (event.request.url.startsWith(self.location.origin)) {
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }

        return caches.open(RUNTIME).then((cache) => {
          return fetch(event.request).then((response) => {
            // Put a copy of the response in the runtime cache.
            return cache.put(event.request, response.clone()).then(() => {
              return response;
            });
          });
        });
      })
    );
  }
});
```
`/*
 * Names of the two caches used in this version of the service worker.
 * Change to v2, etc. when you update any of the local resources, which will
 * in turn trigger the install event again.
 */
const PRECACHE = ""my-precache-v1"";
const RUNTIME = ""my-runtime"";

// A list of local resources we always want to be cached.
const PRECACHE_URLS = [
  ""index.html"",
  ""./"", // Alias for index.html
  ""style.css"",
  ""main.js"",
];

// The install handler takes care of precaching the resources we always need.
self.addEventListener(""install"", (event) => {
  event.waitUntil(
    caches
      .open(PRECACHE)
      .then((cache) => cache.addAll(PRECACHE_URLS))
      .then(self.skipWaiting())
  );
});

// The activate handler takes care of cleaning up old caches.
self.addEventListener(""activate"", (event) => {
  const currentCaches = [PRECACHE, RUNTIME];
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return cacheNames.filter(
          (cacheName) => !currentCaches.includes(cacheName)
        );
      })
      .then((cachesToDelete) => {
        return Promise.all(
          cachesToDelete.map((cacheToDelete) => {
            return caches.delete(cacheToDelete);
          })
        );
      })
      .then(() => self.clients.claim())
  );
});

/*
 * The fetch handler serves responses for same-origin resources from a cache.
 * If no response is found, it populates the runtime cache with the response
 * from the network before returning it to the page.
 */
self.addEventListener(""fetch"", (event) => {
  // Skip cross-origin requests, like those for Google Analytics.
  if (event.request.url.startsWith(self.location.origin)) {
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }

        return caches.open(RUNTIME).then((cache) => {
          return fetch(event.request).then((response) => {
            // Put a copy of the response in the runtime cache.
            return cache.put(event.request, response.clone()).then(() => {
              return response;
            });
          });
        });
      })
    );
  }
});` Sau khi đăng ký thành công, Service Worker sẽ được download về phía client và thực hiện những việc sau đây."
465,Javascript Service Worker là gì,JavaScript Service Worker - Install,"Đoạn code dùng để install Service Worker:

```js
const PRECACHE = ""my-precache-v1"";
const RUNTIME = ""my-runtime""; // A list of local resources want to be cached.
const PRECACHE_URLS = [
  ""index.html"",
  ""./"", // Alias for index.html
  ""style.css"",
  ""main.js"",
];

// The install handler takes care of precaching the resources we always need.
self.addEventListener(""install"", (event) => {
  event.waitUntil(
    caches
      .open(PRECACHE)
      .then((cache) => cache.addAll(PRECACHE_URLS))
      .then(self.skipWaiting())
  );
});
```
`const PRECACHE = ""my-precache-v1"";
const RUNTIME = ""my-runtime""; // A list of local resources want to be cached.
const PRECACHE_URLS = [
  ""index.html"",
  ""./"", // Alias for index.html
  ""style.css"",
  ""main.js"",
];

// The install handler takes care of precaching the resources we always need.
self.addEventListener(""install"", (event) => {
  event.waitUntil(
    caches
      .open(PRECACHE)
      .then((cache) => cache.addAll(PRECACHE_URLS))
      .then(self.skipWaiting())
  );
});` Mục đích của của việcinstalllà để lưu một số resources được định nghĩa ởarrayPRECACHE_URLSvào bộ nhớ đệmcachevới tên định nghĩa bởiPRECACHE.
Sau khi lưu xong hết tất cả các resources cần thiết, hàmself.skipWaiting()dùng để dừng công việc hiện tại lại và chuyển ngay sang công việc tiếp theo."
466,Javascript Service Worker là gì,JavaScript Service Worker - activate,"Đoạn code dùng để active Service Worker là:

```js
// The activate handler takes care of cleaning up old caches.
self.addEventListener(""activate"", (event) => {
  const currentCaches = [PRECACHE, RUNTIME];
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return cacheNames.filter(
          (cacheName) => !currentCaches.includes(cacheName)
        );
      })
      .then((cachesToDelete) => {
        return Promise.all(
          cachesToDelete.map((cacheToDelete) => {
            return caches.delete(cacheToDelete);
          })
        );
      })
      .then(() => self.clients.claim())
  );
});
```
`// The activate handler takes care of cleaning up old caches.
self.addEventListener(""activate"", (event) => {
  const currentCaches = [PRECACHE, RUNTIME];
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return cacheNames.filter(
          (cacheName) => !currentCaches.includes(cacheName)
        );
      })
      .then((cachesToDelete) => {
        return Promise.all(
          cachesToDelete.map((cacheToDelete) => {
            return caches.delete(cacheToDelete);
          })
        );
      })
      .then(() => self.clients.claim())
  );
});` Mục đích của công việcactivatenày là để xóa đi bộ nhớ đệmcachecũ, và giữ lạicachemới nhất, cuối cùng là kích hoạt Service Worker.
Giả sử ban đầu bạn có hai cache là:PRECACHE = my-precache-v1vàRUNTIME. Bây giờ, bạn muốn thay đổi resources.
Làm sao để cập nhật được những resources mới này vào cache?
Bạn cần thay đổi tên củaPRECACHE, ví dụ là:my-precache-v2. Lúc nàycurrentCaches = ['my-precache-v2', RUNTIME]. Bây giờ chỉ cần dùngfilterđể lọc ra tên của cache không có trongcurrentCaches:

```js
cacheNames.filter((cacheName) => !currentCaches.includes(cacheName));
```
`cacheNames.filter((cacheName) => !currentCaches.includes(cacheName));` Đó chính làmy-precache-v1. Tiếp theo, xóa cache này đi:

```js
.then(cachesToDelete => {
  return Promise.all(cachesToDelete.map(cacheToDelete => {
    return caches.delete(cacheToDelete);
  }));
}
```
`.then(cachesToDelete => {
  return Promise.all(cachesToDelete.map(cacheToDelete => {
    return caches.delete(cacheToDelete);
  }));
}` Cuối cùng là kích hoạt Service Worker sử dụngself.clients.claim().
Bạn có thể kiểm tra lại bằng cách nhấnCtrl Shift IhoặcF12(tùy thuộc trình duyệt) để vào phần Công cụ dành cho nhà phát triển.
Bạn có thể thấy là Service Worker đã được kích hoạt (activated) và đang chạy (running)."
467,Javascript Service Worker là gì,JavaScript Service Worker - fetch,"Đoạn code xử lý lệnh fetch:

```js
/*
 * The fetch handler serves responses for same-origin resources from a cache.
 * If no response is found, it populates the runtime cache with the response
 * from the network before returning it to the page.
 */
self.addEventListener(""fetch"", (event) => {
  // Skip cross-origin requests, like those for Google Analytics.
  if (event.request.url.startsWith(self.location.origin)) {
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }

        return caches.open(RUNTIME).then((cache) => {
          return fetch(event.request).then((response) => {
            // Put a copy of the response in the runtime cache.
            return cache.put(event.request, response.clone()).then(() => {
              return response;
            });
          });
        });
      })
    );
  }
});
```
`/*
 * The fetch handler serves responses for same-origin resources from a cache.
 * If no response is found, it populates the runtime cache with the response
 * from the network before returning it to the page.
 */
self.addEventListener(""fetch"", (event) => {
  // Skip cross-origin requests, like those for Google Analytics.
  if (event.request.url.startsWith(self.location.origin)) {
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }

        return caches.open(RUNTIME).then((cache) => {
          return fetch(event.request).then((response) => {
            // Put a copy of the response in the runtime cache.
            return cache.put(event.request, response.clone()).then(() => {
              return response;
            });
          });
        });
      })
    );
  }
});` Đoạn code trên có thể mô tả thành lời như sau:
Bước 1:Khi có request từ phía client (trình duyệt): Nếu url không thuộc cùng origin (không cùng trang web) thì bỏ qua.
Bước 2:Ngược lại, kiểm tra trong bộ nhớ đệm cache xem đã có response tương ứng với request chưa. Nếu tồn tại, thì trả về response đó cho trình duyệt.
Bước 3:Ngược lại, gửi request đó lên server, rồi lấy response trả về.
Bước 4:Clone response đó và lưu vàoRUNTIMEcache để phục vụ cho lần request tiếp theo, rồi sau đó trả về response đó cho trình duyệt."
468,Javascript Service Worker là gì,Kết luận,"Trên đây là những kiến thức cơ bản về JavaScript Service Worker mà mình tìm hiểu được, và còn rất nhiều vấn đề liên quan khác cần nghiên cứu thêm.
Đến đây có thể đã giải đáp được cho vấn đề đưa ra ở đầu bài viết: có 2 thứ cần thiết để web app có thể chạy được là: resources (html, js, css, ảnh,...) và định tuyến.
Nếu bạn cóthắc mắcgì, vui lòng để lại bình luận để mọi người có thể cùng trao đổi. Mình không hứa là sẽ giải đáp ngay cho bạn. Nhưng mình hứa sẽ tìm hiểu để giải quyết cùng bạn."
469,Set trong Javascript,Giới thiệu,Mình đã tìm hiểu vềMaptrong JavaScript rồi. Bài viết này mình tiếp tục tìm hiểu về một loạiobject đặc biệtnữa. Đó là Set trong Javascript
470,Set trong Javascript,Set trong JavaScript là gì?,"Set trong Javascriptlà một loạiobjectcho phép bạn lưu trữ dữ liệu một cách duy nhất, không trùng lặp.
Có 2 điều bạn cần chú ý ở đây.
Vì vậy màtypeof setsẽ trả về stringobject.
`typeof set` `object` 
```js
const set1 = new Set();
console.log(typeof set1);
// object
```
`const set1 = new Set();
console.log(typeof set1);
// object` Hiểu thế nào làduy nhất, không trùng lặp?
Đơn giản là ""giá trị"" của các phần tử không được giống nhau. Thực chất, Set sử dụng thuật toánSameValueZerođể so sánh giá trị của các phần tử.
Thuật toánSameValueZerotương tự như việc sử dụng toán tử so sánh bằng nghiêm ngặt===để so sánh giá trị. Chỉ khác ở chỗ thuật toán này coiNaNlà giống nhau (mặc dùNaN !== NaNlàtrue).
`===` `NaN` `NaN !== NaN` `true` Vì vậy, điều mình nói ở trên chỉ đúng vớinumber và string, còn đối với object thì khác. Bởi 2 object nhìn giống nhau nhưng rõ ràng chúng không bằng nhau:

```js
const obj1 = { x: 1, y: 2 };
const obj2 = { x: 1, y: 2 };

console.log(obj1 === obj2);
// false

const set1 = new Set([obj1, obj2]);
console.log(set1.size);
// 2
```
`const obj1 = { x: 1, y: 2 };
const obj2 = { x: 1, y: 2 };

console.log(obj1 === obj2);
// false

const set1 = new Set([obj1, obj2]);
console.log(set1.size);
// 2` Ngoài ra, bạn cũng có thể lưuNaNvàundefinedvào Set trong JavaScript.
`NaN` `undefined` 
```js
const set2 = new Set([NaN, undefined, NaN]);
console.log(set2);
// Set(2) {NaN, undefined}
```
`const set2 = new Set([NaN, undefined, NaN]);
console.log(set2);
// Set(2) {NaN, undefined}` Đọc đến đây chắc bạn đã hiểu cơ bản về Set rồi phải không?
Sau đây là những thứ bạn có thể làm với Set trong JavaScript."
471,Set trong Javascript,Khởi tạo Set trong JavaScript,"Khởi tạo Set là điều đầu tiên bạn cần làm nếu muốn sử dụng Set. Cú pháp khởi tạo Set trong Javascript là:

```js
new Set([iterable]);
```
`new Set([iterable]);` Trong đó:
Chú ý:bạn có thể truyền vàoiterable object, chứ không chỉ có array (vì array chỉ là một loại iterable object).
Sau đây là các ví dụ khởi tạo Set trong JavaScript.
Khởi tạo Set rỗng bằng cách không truyền tham số vào hàm khởi tạo.

```js
const set1 = new Set();
console.log(set1);
// Set(0) {}
```
`const set1 = new Set();
console.log(set1);
// Set(0) {}` Array là một loại iterable object.

```js
const set2 = new Set([1, 2, ""a"", ""b"", 1]);
console.log(set2);
// Set(4) {1, 2, ""a"", ""b""}
```
`const set2 = new Set([1, 2, ""a"", ""b"", 1]);
console.log(set2);
// Set(4) {1, 2, ""a"", ""b""}` String cũng là một loại iterable object.

```js
const set3 = new Set(""abcba"");
console.log(set3);
// Set(3) {""a"", ""b"", ""c""}
```
`const set3 = new Set(""abcba"");
console.log(set3);
// Set(3) {""a"", ""b"", ""c""}` Đối tượngargumentslà đối tượng có sẵn trong hàm, dùng để lưu trữ mảng các tham số truyền vào.
`arguments` 
```js
function func4() {
  const set4 = new Set(arguments);
  console.log(set4);
}

func4(""a"", ""b"", ""c"", ""b"", 0, 1);
// Set(5) {""a"", ""b"", ""c"", 0, 1}
```
`function func4() {
  const set4 = new Set(arguments);
  console.log(set4);
}

func4(""a"", ""b"", ""c"", ""b"", 0, 1);
// Set(5) {""a"", ""b"", ""c"", 0, 1}` Kết quả của các phương thức liên quan đếnDOMkhi thao tác với trình duyệt như:document.querySelectorAll(),document.getElementsByClassName(),... đều trả vềNodeList.
`DOM` `NodeList` Ví dụ:

```js
// tìm tất cả các phần tử với thẻ head
const head = document.querySelectorAll(""head"");
const set1 = new Set(head);
console.log(set1);
// Set(1) {head}
```
`// tìm tất cả các phần tử với thẻ head
const head = document.querySelectorAll(""head"");
const set1 = new Set(head);
console.log(set1);
// Set(1) {head}` TypedArraylà một kiểu object tương tự như Array. Và bạn cũng có thể sử dụngTypedArrayđể khởi tạo Set như sau:

```js
const typedArray1 = new Int8Array(2);
typedArray1[0] = 12;
typedArray1[1] = 34;

const set1 = new Set(typedArray1);
console.log(set1);
// Set(2) {12, 34}
```
`const typedArray1 = new Int8Array(2);
typedArray1[0] = 12;
typedArray1[1] = 34;

const set1 = new Set(typedArray1);
console.log(set1);
// Set(2) {12, 34}` Bạn có thể khởi tạo Set từ Map như sau:

```js
const map1 = new Map();
map1.set(""one"", 1);
map1.set(""two"", 2);

const set1 = new Set(map1);
console.log(set1);
// Set(2) {Array(2), Array(2)}

for (const x of set1) {
  console.log(x);
}
/*
 * [""one"", 1]
 * [""two"", 2]
 */
```
`const map1 = new Map();
map1.set(""one"", 1);
map1.set(""two"", 2);

const set1 = new Set(map1);
console.log(set1);
// Set(2) {Array(2), Array(2)}

for (const x of set1) {
  console.log(x);
}
/*
 * [""one"", 1]
 * [""two"", 2]
 */` Bạn cũng có thể khởi tạo Set từ một Set khác.

```js
const set1 = new Set([1, 2]);
const set2 = new Set(set1);
console.log(set2);
// Set(2) {1, 2}
```
`const set1 = new Set([1, 2]);
const set2 = new Set(set1);
console.log(set2);
// Set(2) {1, 2}` Trên đây là một số cách để khởi tạo Set trong JavaScript. Tiếp theo đây là cách để thêm phần tử vào Set."
472,Set trong Javascript,Thêm phần tử vào Set,"Để thêm phần tử vào Set trong JavaScript, bạn có thể sử dụng phương thứcaddnhư sau:
`add` 
```js
set.add(value);
```
`set.add(value);` Trong đó:
`value` `set.add(value)` `value` `value` `set.add(value)` Ví dụ thêm phần tử vào Set:

```js
// khởi tạo set rỗng
const set1 = new Set();

// thêm phần tử 1
set1.add(1);
console.log(set1);
// Set(1) {1}

// thêm phần tử 2 (khác 1)
set1.add(2);
console.log(set1);
// Set(2) {1, 2}

// thêm phần tử 3 (khác 1 và 2)
set1.add(1).add(2).add(3);
console.log(set1);
// Set(3) {1, 2, 3}
```
`// khởi tạo set rỗng
const set1 = new Set();

// thêm phần tử 1
set1.add(1);
console.log(set1);
// Set(1) {1}

// thêm phần tử 2 (khác 1)
set1.add(2);
console.log(set1);
// Set(2) {1, 2}

// thêm phần tử 3 (khác 1 và 2)
set1.add(1).add(2).add(3);
console.log(set1);
// Set(3) {1, 2, 3}` Việc trả về chính đối tượng Set sau khiaddgiúp code trở trên ngắn gọn hơn nhiều.
`add`"
473,Set trong Javascript,Lấy số lượng phần tử trong Set,"Để lấy được số lượng phần tử của Set trong JavaScript, bạn có thể sử dụng thuộc tínhset.size.
`set.size` 
```js
const set1 = new Set([""a"", ""b"", ""a""]);
console.log(set1.size);
// 2 - vì set chỉ có hai phần tử [""a"", ""b""]
```
`const set1 = new Set([""a"", ""b"", ""a""]);
console.log(set1.size);
// 2 - vì set chỉ có hai phần tử [""a"", ""b""]`"
474,Set trong Javascript,Kiểm tra phần tử tồn tại trong Set,"Để kiểm tra một phần tử có tồn tại trong Set hay không, bạn có thể sử dụng phương thứcset.has().
`set.has()` 
```js
const set1 = new Set([1, ""a"", [1, 2]]);

console.log(set1.has(1)); // true
console.log(set1.has(""1"")); // false
console.log(set1.has(""a"")); // true
console.log(set1.has(""b"")); // false
console.log(set1.has([1, 2])); // false - vì [1, 2] !== [1, 2]
```
`const set1 = new Set([1, ""a"", [1, 2]]);

console.log(set1.has(1)); // true
console.log(set1.has(""1"")); // false
console.log(set1.has(""a"")); // true
console.log(set1.has(""b"")); // false
console.log(set1.has([1, 2])); // false - vì [1, 2] !== [1, 2]` Kết quả trên là hoàn toàn dễ hiểu phải không?
Mình chỉ muốn nhắc lại là Set sẽ sử dụngtoán tử so sánh bằng nghiêm ngặt===để so sánh các giá trị, do đó:
`===` 
```js
console.log(1 === 1); // true
console.log(1 === ""1""); // false
console.log(""a"" === ""a""); // true
console.log([1, 2] === [1, 2]); // false
```
`console.log(1 === 1); // true
console.log(1 === ""1""); // false
console.log(""a"" === ""a""); // true
console.log([1, 2] === [1, 2]); // false`"
475,Set trong Javascript,Xoá một phần tử trong Set,"Để xóa một phần tử của Set trong JavaScript, bạn sử dụng phương thứcset.delete(value):
`set.delete(value)` 
```js
const set1 = new Set(""abcdcba"");
console.log(set1); // Set(4) {a, b, c, d}

set1.delete(""a"");
console.log(set1); // Set(4) {b, c, d}

set1.delete(""d"");
console.log(set1); // Set(2) {b, c}
```
`const set1 = new Set(""abcdcba"");
console.log(set1); // Set(4) {a, b, c, d}

set1.delete(""a"");
console.log(set1); // Set(4) {b, c, d}

set1.delete(""d"");
console.log(set1); // Set(2) {b, c}`"
476,Set trong Javascript,Xoá tất cả phần tử trong Set,"Để xóa tất cả các phần tử trong Set, bạn sử dụng phương thứcset.clear(). Sau đó, Set sẽ trở thành rỗng.
`set.clear()` 
```js
const set1 = new Set([1, 2, 3]);
console.log(set1); // Set(3) {1, 2, 3}

set1.clear();
console.log(set1); // Set(0) {}
```
`const set1 = new Set([1, 2, 3]);
console.log(set1); // Set(3) {1, 2, 3}

set1.clear();
console.log(set1); // Set(0) {}`"
477,Set trong Javascript,Duyệt qua các phần tử trong Set,"Set hỗ trợ một số cách để duyệt qua các phần tử như sau.
`for...of` Ví dụ sử dụngfor...ofđể duyệt qua các phần tử:
`for...of` 
```js
const set1 = new Set([""a"", { x: 1 }, 1]);

for (const x of set1) {
  console.log(x);
}
/*
 * a
 * { x : 1}
 * 1
 */
```
`const set1 = new Set([""a"", { x: 1 }, 1]);

for (const x of set1) {
  console.log(x);
}
/*
 * a
 * { x : 1}
 * 1
 */` `forEach` Sử dụngset.forEach()cũng tương tự nhưforEach trong Array.
`set.forEach()` 
```js
const set1 = new Set([""a"", ""b"", ""c""]);
console.log(set1);
// Set(3) {""a"", ""b"", ""c""}

set1.forEach(function (value) {
  console.log(value);
});
/*
 * a
 * b
 * c
 */
```
`const set1 = new Set([""a"", ""b"", ""c""]);
console.log(set1);
// Set(3) {""a"", ""b"", ""c""}

set1.forEach(function (value) {
  console.log(value);
});
/*
 * a
 * b
 * c
 */` Ba phương thứcset.keys(),set.values()vàset.entries()đều trả về iterable object, với mỗi phần tử tương ứng với một phần tử trong Set (theo thứ tự mà mình chèn vào).
`set.keys()` `set.values()` `set.entries()` 
```js
// khởi tạo set
const set1 = new Set([""a"", { x: 1 }, 1]);

// duyệt qua các keys trong set
for (const x of set1.keys()) {
  console.log(x);
}
/*
 * a
 * { x : 1}
 * 1
 */

// duyệt qua các values trong set
for (const x of set1.values()) {
  console.log(x);
}
/*
 * a
 * { x : 1}
 * 1
 */

// duyệt qua các cặp [key, value] trong set
for (const x of set1.entries()) {
  console.log(x);
}

/*
 * [""a"", ""a""]
 * [{ x : 1}, { x : 1}]
 * [1, 1]
 */
```
`// khởi tạo set
const set1 = new Set([""a"", { x: 1 }, 1]);

// duyệt qua các keys trong set
for (const x of set1.keys()) {
  console.log(x);
}
/*
 * a
 * { x : 1}
 * 1
 */

// duyệt qua các values trong set
for (const x of set1.values()) {
  console.log(x);
}
/*
 * a
 * { x : 1}
 * 1
 */

// duyệt qua các cặp [key, value] trong set
for (const x of set1.entries()) {
  console.log(x);
}

/*
 * [""a"", ""a""]
 * [{ x : 1}, { x : 1}]
 * [1, 1]
 */` Bạn thấy rằng, các phương thức trên đều có đặc điểm là:keyvàvaluegiống nhau. Việc đểkeyvàvaluebằng nhau để tương đồng với kiểu dữ liệu Map.
`key` `value` `key` `value`"
478,Set trong Javascript,Chuyển Set thành Array và ngược lại,"Mình có thể sử dụng phương thứcforEachcủa Set trong JavaScript, tương tự như Array. Nhưng còn các phương thức khác như:map,filter,... thì sao?
`forEach` `map` `filter` Thực tế, Set không hỗ trợ những phương thức này.
Nhưng bạn hoàn toàn có thểchuyển Set thành Arrayđể sử dụng các phương thức của Array. Rồi sau đó, bạn chuyển Array ngược lại thành Set.
Để chuyển Set thành Array, bạn có thể sử dụngArray.fromhoặc sử dụngtoán tử spread, ví dụ:

```js
// khởi tạo set
const set1 = new Set([1, 2, 3, 4, 5]);

// chuyển set thành array sử dụng Array.from
const arr1 = Array.from(set1);
console.log(arr1);
// [1, 2, 3, 4, 5]

// chuyển set thành array sử dụng cú pháp spread (...)
const arr2 = [...set1];
console.log(arr2);
// [1, 2, 3, 4, 5]
```
`// khởi tạo set
const set1 = new Set([1, 2, 3, 4, 5]);

// chuyển set thành array sử dụng Array.from
const arr1 = Array.from(set1);
console.log(arr1);
// [1, 2, 3, 4, 5]

// chuyển set thành array sử dụng cú pháp spread (...)
const arr2 = [...set1];
console.log(arr2);
// [1, 2, 3, 4, 5]` Giả sử, mình sử dụng phương thứcfilterđể lọc lấy những phần tử là số chẵn.
`filter` 
```js
const arr3 = arr1.filter((x) => x % 2 === 0);
console.log(arr3);
// (2) [2, 4]
```
`const arr3 = arr1.filter((x) => x % 2 === 0);
console.log(arr3);
// (2) [2, 4]` Bây giờ, mình chuyển Array ngược lại thành Set - sử dụng công thức phần khởi tạo Set:

```js
const set2 = new Set(arr3);
console.log(set2);
// Set(2) {2, 4}
```
`const set2 = new Set(arr3);
console.log(set2);
// Set(2) {2, 4}` Toàn bộ quá trình trên có thể viết gọn lại thành:

```js
const set1 = new Set([1, 2, 3, 4, 5]);
console.log(set1);
// Set(5) {1, 2, 3, 4, 5}

const filteredArray = [...set1].filter((x) => x % 2 == 0);
const set2 = new Set(filteredArray);
console.log(set2);
// Set(2) {2, 4}
```
`const set1 = new Set([1, 2, 3, 4, 5]);
console.log(set1);
// Set(5) {1, 2, 3, 4, 5}

const filteredArray = [...set1].filter((x) => x % 2 == 0);
const set2 = new Set(filteredArray);
console.log(set2);
// Set(2) {2, 4}` Khi đã chuyển Set thành Array rồi, bạn có thể sử dụng bất kỳphương thứcnào mà Array hỗ trợ."
479,Set trong Javascript,Một ví dụ thực tế sử dụng Set,"Vì mình cần phải lưu lại danh sách các thẻ, chuyên mục với các phần tử là duy nhất, rồi sau đóhiển thị danh sáchnày lên sidebar.
Ví dụ mỗi bài viết có một mảng lưu các thẻ tag:

```js
const post1 = [""tag1"", ""tag2"", ""tag4""];
const post2 = [""tag3"", ""tag4""];
```
`const post1 = [""tag1"", ""tag2"", ""tag4""];
const post2 = [""tag3"", ""tag4""];` Sau đó, tạo ra mảng các thẻ tag duy nhất bằng Set như sau:

```js
let arrTag = [];

arrTag = Array.from(new Set([...arrTag, ...post1]));
arrTag = Array.from(new Set([...arrTag, ...post2]));

console.log(arrTag);
// (4) [""tag1"", ""tag2"", ""tag4"", ""tag3""]
```
`let arrTag = [];

arrTag = Array.from(new Set([...arrTag, ...post1]));
arrTag = Array.from(new Set([...arrTag, ...post2]));

console.log(arrTag);
// (4) [""tag1"", ""tag2"", ""tag4"", ""tag3""]` Giả sử tạo thêm một bài viết mới với mảng các thẻ tag là:

```js
const post3 = [""tag1"", ""tag3"", ""tag5""];
```
`const post3 = [""tag1"", ""tag3"", ""tag5""];` Để cập nhật danh sách thẻ tag, mình có thể làm như sau:

```js
arrTag = Array.from(new Set([...arrTag, ...post3]));
// (5) [""tag1"", ""tag2"", ""tag4"", ""tag3"", ""tag5""]
```
`arrTag = Array.from(new Set([...arrTag, ...post3]));
// (5) [""tag1"", ""tag2"", ""tag4"", ""tag3"", ""tag5""]` Mỗi khi thêm một bài viết mới, mình chỉ cần làm theo cách trên là cập nhật được danh sách các thẻ mà không bị trùng lặp."
480,Set trong Javascript,Tổng kết,"Set trong JavaScript là một loại object dùng để lưu trữ dữ liệu mà không trùng lặp.
Các phương thức của Set là:
`new Set(iterable)` `set.add(value)` `value` `set.delete(value)` `true` `value` `false` `set.has(value)` `true` `value` `false` `set.clear()` `set.size` Tham khảo:"
481,Singleton pattern trong JavaScript,Giới thiệu,"Có thể bạn đã nghe quen về Singleton. Singleton Pattern giới hạn số lượng instance của một class làmột. Trong JavaScript, bạn có thể triển khai Singleton Pattern theo cách sau."
482,Singleton pattern trong JavaScript,Singleton Pattern cơ bản,"```js
var mySingleton = (function () {
  var instance;
  function init() {
    var number = 0;
    return {
      setNumber: function (x) {
        number = x;
      },
      getNumber: function () {
        return number;
      },
    };
  }

  return {
    getInstance: function () {
      if (!instance) instance = init();
      return instance;
    },
  };
})();

var instA = mySingleton.getInstance();
console.log(""instance A: "", instA.getNumber()); // instance A: 0
instA.setNumber(10);
console.log(""instance A: "", instA.getNumber()); // instance A: 10

var instB = mySingleton.getInstance();
console.log(""instance B: "", instB.getNumber()); // instance B: 10

console.log(instA === instB); // true
```
`var mySingleton = (function () {
  var instance;
  function init() {
    var number = 0;
    return {
      setNumber: function (x) {
        number = x;
      },
      getNumber: function () {
        return number;
      },
    };
  }

  return {
    getInstance: function () {
      if (!instance) instance = init();
      return instance;
    },
  };
})();

var instA = mySingleton.getInstance();
console.log(""instance A: "", instA.getNumber()); // instance A: 0
instA.setNumber(10);
console.log(""instance A: "", instA.getNumber()); // instance A: 10

var instB = mySingleton.getInstance();
console.log(""instance B: "", instB.getNumber()); // instance B: 10

console.log(instA === instB); // true` Các bạn có thể thấy, cách triển khai Singleton trên rất giống vớiModule Pattern. Chỉ có một chú ý là, mySingleton chỉ có một access point duy nhất là getInstance. Vậy tại sao khi sử dụngfunctionnày thì ta chỉ thu được một instance duy nhất?
Đúng vậy, ban đầu khi chưa gọi getInstance lần nào thì biến instance sẽ là undefined. Lúc này, instance sẽ được khởi tạo bằng cách sử dụng hàm số init. Cuối cùng, hàm số trả về biến instance. Đối với các lần gọi getInstance tiếp theo, vì instance đã khác undefined nên nó sẽ không được tạo mới mà sẽ return ngay lập tức.
Như ví dụ trên, instA khi mới tạo ra thì getNumber sẽ trả về 0. Trong khi, instB khi mới tạo ra thì getNumber trả về 10 - giá trị này được set ở instA trước đó. Và quan trọng hơn,instA === instBtrả về giá trị true. Như vậy, thực chất instB cũng chính là instA."
483,Singleton pattern trong JavaScript,Singleton with a cached static property,"```js
function User() {
  // do we have an existing instance?
  if (typeof User.instance === ""object"") {
    return User.instance;
  }

  // proceed as normal
  this.firstName = ""John"";
  this.lastName = ""Doe"";

  // cache
  User.instance = this;

  /**
   * // implicit return
   * return this;
   */
}

// Usage:
var curUser = new User();
console.log(curUser.firstName, curUser.lastName); // John Doe

var other = new User();
console.log(other.firstName, other.lastName); // John Doe
console.log(other === curUser); // true
```
`function User() {
  // do we have an existing instance?
  if (typeof User.instance === ""object"") {
    return User.instance;
  }

  // proceed as normal
  this.firstName = ""John"";
  this.lastName = ""Doe"";

  // cache
  User.instance = this;

  /**
   * // implicit return
   * return this;
   */
}

// Usage:
var curUser = new User();
console.log(curUser.firstName, curUser.lastName); // John Doe

var other = new User();
console.log(other.firstName, other.lastName); // John Doe
console.log(other === curUser); // true` Cách này khi mới đọc thì sẽ thấy hơi ảo, ở chỗ là, trong hàm User ta lại sử dụng User.instance. Nhưng nếu nhìn theo khía cạnh, function cũng chính là mộtobjectthì mọi chuyện sẽ trở nên đơn giản.
Như trong ví dụ trên, khi khởi tạo curUser (lần đầu tiên), User.instance đang có giá trị là undefined, nên mọi thứ được xử lý như bình thường. Khi kết thúc hàm, ta gánUser.instance = thishay nói cách khác làUser.instance = curUser. Đến khi khởi tạo đối tượng thứ hai là other, lúc này User.instance đã là curUser - một object, nên hàm trên sẽ return về User.instance (curUser). Đó, dù có gọi hàm khởi tạo bao nhiêu lần thì ta cũng chỉ thu được một đối tượng duy nhất."
484,So sánh hai object trong Javascript,Giới thiệu,"Điều cơ bản khác nhau giữa object và cáckiểu dữ liệu nguyên thủykhác là object lưu trữ dữ liệu theo kiểutham chiếu. Nên việc so sánh 2 object trong JavaScript làtheo địa chỉ(chứ không phải theo giá trị).
Vì vậy, trước khi tìm hiểu chi tiết về việc so sánh giữa hai object, mình cần hiểu cơ bản về kiểu dữ liệu tham chiếu."
485,So sánh hai object trong Javascript,Kiểu dữ liệu tham chiếu,"Khi gán một object cho một biến, thực chất là biến đó đanglưu địa chỉtrong bộ nhớ của object.
Khi ta truy cập vào một thuộc tính của object, trình thông dịch sẽ dựa theođịa chỉ đã lưuđể truy xuất đúng giá trị cần lấy trong bộ nhớ.
Ví dụ về object:

```js
let p1 = { x: 1, y: 2 };
let p2 = p1;

p2.x = 2;
console.log(p2.x); // 2
console.log(p1.x); // 2
```
`let p1 = { x: 1, y: 2 };
let p2 = p1;

p2.x = 2;
console.log(p2.x); // 2
console.log(p1.x); // 2` Trong ví dụ trên, mìnhkhởi tạo objectp1. Tiếp theo, mình khởi tạop2và gán bằngp1. Sau đó, mình thay đổi giá trị thuộc tínhxtrongp2. Nhưng thấy kết quả làp1.xvàp2.xđều thay đổi.
`p1` `p2` `p1` `x` `p2` `p1.x` `p2.x` Điều này cho thấy làp2vàp1đang cùng trỏ vào mộtvùng nhớ giống nhautrong bộ nhớ.
`p2` `p1` Đây chính là đặc điểm cơ bản của kiểu dữ liệu tham chiếu. Sau đây, mình sẽ tìm hiểu kỹ hơn về cách để so sánh 2 object trong JavaScript.
Sau đây, mình sẽ tìm hiểu các phương diện so sánh 2 object trong JavaScript là:"
486,So sánh hai object trong Javascript,So sánh 2 object bằng tham chiếu,"JavaScript cung cấp haitoán tử so sánhlà==và===, trong đó:
`==` `===` `===` `true` `cùng kiểu dữ liệu` `cùng giá trị` `false` `==` `true` `cùng giá trị` `false` Đối với so sánh object bằng tham chiếu:hai object được gọi là bằng nhau khi và chỉ khi chúng cùng tham chiếu đến cùng một địa chỉ bộ nhớ. Hay nói ngắn gọn là chúng hoàn toàn giống nhau.
Ví dụ hai object bằng nhau theo tham chiếu:

```js
let x = {};
let y = x;

console.log(y == x); // true
console.log(y === x); // true
```
`let x = {};
let y = x;

console.log(y == x); // true
console.log(y === x); // true` Trong ví dụ trên, hai objectxvàyđang cùng tham chiếu tới một địa chỉ. Vì vậy, chúng hoàn toàn bằng nhau.
`x` `y` Ngược lại, hai object độc lập sẽ không bao giờ bằng nhau, mặc dù trông có vẻ giống nhau:

```js
let x = {};
let y = {}; // khởi tạo object độc lập
console.log(y == x); // false
console.log(y === x); // false
```
`let x = {};
let y = {}; // khởi tạo object độc lập
console.log(y == x); // false
console.log(y === x); // false` Hai objectyvàxđều làobject rỗngnhưng chúng đang tham chiếu tới hai địa chỉ khác nhau, nên không bằng nhau.
`y` `x` Ngoài hai toán tử trên, bạn có thể dùng hàmObject.is(value1, value2)để so sánh 2 object trong JavaScript bằng tham chiếu.
`Object.is(value1, value2)` 
```js
let x = {};
let y = x; // object cùng tham chiếu
let z = {}; // object độc lập

console.log(Object.is(y, x)); // true
console.log(Object.is(z, x)); // false
```
`let x = {};
let y = x; // object cùng tham chiếu
let z = {}; // object độc lập

console.log(Object.is(y, x)); // true
console.log(Object.is(z, x)); // false`"
487,So sánh hai object trong Javascript,So sánh 2 object qua giá trị cách thủ công,"Đôi khi mình muốn so sánh thủ côngtừng giá trịứng vớitừng thuộc tínhcủa object. Và mình coi hai object bằng nhau khi chúng có cùng thuộc tính và cùng giá trị với từng thuộc tính.
Ví dụ xây dựng bài toán vẽ hình, khi đó mỗi điểm trên màn hình là mộtpointvới tọa độ(x,y). Khi đó, haipointbằng nhau khi chúng có cùng tọa độ(x,y), ví dụ:

```js
let point1 = { x: 1, y: 2 };
let point2 = { x: 1, y: 2 };
let point3 = { x: 2, y: 3 };
```
`let point1 = { x: 1, y: 2 };
let point2 = { x: 1, y: 2 };
let point3 = { x: 2, y: 3 };` Rõ ràng,point2vàpoint1có cùng tọa độ nên trùng nhau. Trong khi đó,point3có tọa độ khác vớipoint1vàpoint2.
`point2` `point1` `point3` `point1` `point2` Làm sao để so sánh các point trên?
Đơn giản là mình sẽ truy cập giá trị của hai thuộc tínhxvàytrong từng object rồi so sánh chúng với nhau.
`x` `y` 
```js
let point1 = { x: 1, y: 2 };
let point2 = { x: 1, y: 2 };
let point3 = { x: 2, y: 3 };

if (point2.x === point1.x && point2.y === point1.y) {
  console.log(""point2 bằng point1"");
} else {
  console.log(""point2 khác point1"");
}

if (point3.x === point1.x && point3.y === point1.y) {
  console.log(""point3 bằng point1"");
} else {
  console.log(""point3 khác point1"");
}

// point2 bằng point1
// point3 khác point1
```
`let point1 = { x: 1, y: 2 };
let point2 = { x: 1, y: 2 };
let point3 = { x: 2, y: 3 };

if (point2.x === point1.x && point2.y === point1.y) {
  console.log(""point2 bằng point1"");
} else {
  console.log(""point2 khác point1"");
}

if (point3.x === point1.x && point3.y === point1.y) {
  console.log(""point3 bằng point1"");
} else {
  console.log(""point3 khác point1"");
}

// point2 bằng point1
// point3 khác point1` Kết quả hoàn toàn như mong đợi rồi đúng không?
Nhưng vấn đề là đoạn code kiểm tra điều kiện đang bị lặp lại. Do đó, khi bạn muốn thay đổi định nghĩa vềhai point bằng nhauthì bạn phải sửa đoạn code trên ở mọi nơi sử dụng.
Don't repeat yourself!
Để giải quyết vấn đề trên, mình viết lại điều kiện trên thành hàm kiểm tra như sau:

```js
function isPointEqual(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
let point1 = { x: 1, y: 2 };
let point2 = { x: 1, y: 2 };
let point3 = { x: 2, y: 3 };

console.log(isPointEqual(point1, point2)); // trueconsole.log(isPointEqual(point1, point3)); // false
```
`function isPointEqual(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
let point1 = { x: 1, y: 2 };
let point2 = { x: 1, y: 2 };
let point3 = { x: 2, y: 3 };

console.log(isPointEqual(point1, point2)); // trueconsole.log(isPointEqual(point1, point3)); // false` Đến đây cũng khá ổn rồi... nhưng lại có một vấn đề khác: nếu object không chỉ có hai thuộc tính mà córất nhiều thuộc tínhthì sao?
Thậm chí là số lượng thuộc tính không biết trước thì bạn không thể dùng cách trên được.
Để giải quyết bài toán số lượng các thuộc tính trong object nhiều hoặc không biết trước, bạn có thể sử dụngvòng lặpfor...inđể duyệt hết các thuộc tính của object.
`for...in` Mình đã viết mộthàmđể so sánh từng thuộc tính và giá trị của object như sau:

```js
function isShallowEqual(obj1, obj2) {
  for (let prop in obj1) {
    if (obj1[prop] !== obj2[prop]) return false;
  }

  for (let prop in obj2) {
    if (obj2[prop] !== obj1[prop]) return false;
  }

  return true;
}

let point1 = { x: 1, y: 2 };
let point2 = { x: 1, y: 2 };
let point3 = { x: 2, y: 3 };

console.log(isShallowEqual(point1, point2)); // true
console.log(isShallowEqual(point1, point3)); // false
```
`function isShallowEqual(obj1, obj2) {
  for (let prop in obj1) {
    if (obj1[prop] !== obj2[prop]) return false;
  }

  for (let prop in obj2) {
    if (obj2[prop] !== obj1[prop]) return false;
  }

  return true;
}

let point1 = { x: 1, y: 2 };
let point2 = { x: 1, y: 2 };
let point3 = { x: 2, y: 3 };

console.log(isShallowEqual(point1, point2)); // true
console.log(isShallowEqual(point1, point3)); // false` Ý tưởng của thuật toán trên là:duyệt tất cả các thuộc tínhcủa một object và so sánh giá trị tương ứng trong hai object. Nếu hai giá trị khác nhau thì kết luận là hai object không bằng nhau.
Nếu hai trường hợpreturn falsekhông xảy ra thì nghĩa là hai point bằng nhau, nên cuối cùngreturn true.
`return false` `return true` Thuật toán so sánh nông trông có vẻ tốt, nhưng liệu có vấn đề gì với nó không?
Câu trả lời là:CÓ.
Hãy xem ví dụ sau:

```js
function isShallowEqual(obj1, obj2) {
  for (let prop in obj1) {
    if (obj1[prop] !== obj2[prop]) return false;
  }

  for (let prop in obj2) {
    if (obj2[prop] !== obj1[prop]) return false;
  }

  return true;
}

let point1 = { x: 1, y: 2, metadata: { type: ""point"" } };
let point2 = { x: 1, y: 2, metadata: { type: ""point"" } };
console.log(isShallowEqual(point1, point2)); // false
```
`function isShallowEqual(obj1, obj2) {
  for (let prop in obj1) {
    if (obj1[prop] !== obj2[prop]) return false;
  }

  for (let prop in obj2) {
    if (obj2[prop] !== obj1[prop]) return false;
  }

  return true;
}

let point1 = { x: 1, y: 2, metadata: { type: ""point"" } };
let point2 = { x: 1, y: 2, metadata: { type: ""point"" } };
console.log(isShallowEqual(point1, point2)); // false` Bây giờ, kết quả so sánhpoint1vàpoint2lại trả vềfalse. Nguyên nhân là thuộc tínhmetadatacó giá trị kiểuobject. Nên khi so sánh haimetadatacho nhau, chúng sẽ khác nhau.
`point1` `point2` `false` `metadata` `metadata` Kết quả là hai object trên lại ""không bằng nhau"".
Kết luận: thuật toánso sánh nôngchỉ đúng khi giá trị các thuộc tính trong object có kiểu dữ liệu nguyên thủy."
488,So sánh hai object trong Javascript,,"So sánh sâu khá tương đồng với so sánh nông. Nhưng thay vì duyệt một cấp, so sánh sâu duyệt tất cả các cấp của object (trường hợp object lồng nhau).
Để triển khai thuật toán này, bạn cần phải biết vềthuật toán đệ quy. Do đó, mình sẽ không giải thích chi tiết trong bài viết này.
Sau đây là thuật toán so sánh sâu cho bạn tham khảo:

```js
// Hàm kiểm tra một giá trị là object
function isObject(obj) {
  return obj != null && typeof obj === ""object"";
}

// Hàm so sánh sâu
function isDeepEqual(obj1, obj2) {
  const keys1 = Object.keys(obj1); // trả về mảng các thuộc tính của obj1
  const keys2 = Object.keys(obj2); // trả về mảng các thuộc tính của obj2

  // nếu số lượng keys khác nhau thì chắc chắn khác nhau
  if (keys1.length !== keys2.length) {
    return false;
  }

  for (const key of keys1) {
    const val1 = obj1[key];
    const val2 = obj2[key];

    // kiểm tra xem hai giá trị có cùng là object hay không
    const areObjects = isObject(val1) && isObject(val2);

    // nếu cùng là object thì phải gọi đệ quy để so sánh 2 object
    if (areObjects && !isDeepEqual(val1, val2)) {
      return false;
    }

    // nếu không cùng là object thì so sánh giá trị
    if (!areObjects && val1 !== val2) {
      return false;
    }
  }

  return true;
}

let point1 = { x: 1, y: 2, metadata: { type: ""point"" } };
let point2 = { x: 1, y: 2, metadata: { type: ""point"" } };

console.log(isDeepEqual(point1, point2)); // true
```
`// Hàm kiểm tra một giá trị là object
function isObject(obj) {
  return obj != null && typeof obj === ""object"";
}

// Hàm so sánh sâu
function isDeepEqual(obj1, obj2) {
  const keys1 = Object.keys(obj1); // trả về mảng các thuộc tính của obj1
  const keys2 = Object.keys(obj2); // trả về mảng các thuộc tính của obj2

  // nếu số lượng keys khác nhau thì chắc chắn khác nhau
  if (keys1.length !== keys2.length) {
    return false;
  }

  for (const key of keys1) {
    const val1 = obj1[key];
    const val2 = obj2[key];

    // kiểm tra xem hai giá trị có cùng là object hay không
    const areObjects = isObject(val1) && isObject(val2);

    // nếu cùng là object thì phải gọi đệ quy để so sánh 2 object
    if (areObjects && !isDeepEqual(val1, val2)) {
      return false;
    }

    // nếu không cùng là object thì so sánh giá trị
    if (!areObjects && val1 !== val2) {
      return false;
    }
  }

  return true;
}

let point1 = { x: 1, y: 2, metadata: { type: ""point"" } };
let point2 = { x: 1, y: 2, metadata: { type: ""point"" } };

console.log(isDeepEqual(point1, point2)); // true` Trên đây là thuật toán để so sánh sâu. Bạn có thể tham khảo để rèn luyện tư duy logic.
Còn trong dự án thực tế, bạn có thể sử dụng hàm thư viện_.isEqualtrong lodash để giải quyết bài toán nhanh hơn, tránh mất công sinh ra lỗi sau này.
`_.isEqual`"
489,So sánh hai object trong Javascript,Tổng kết,"Object lưu trữ dữ liệu theo kiểu tham chiếu. Vì vậy, việc so sánh 2 object trong JavaScript là dựa trên địa chỉ của object.
Một số cách so sánh 2 object trong JavaScript là:
`==` `===` `Object.is`"
490,So sánh map và object trong Javascript,Giới thiệu,"Có thể bạn đã quen với việc sử dụng Object trong JavaScript. Trong khi đó, Map là một kiểu dữ liệu mới xuất hiện trong ES6. Map có những đặc điểmgiống và khácso với Object. Cụ thể là như thế nào? Sau đây, mình sẽ so sánh Map với Object trong JavaScript."
491,So sánh map và object trong Javascript,Nhắc lại khái niệm Map và Object,"►Objectlà một khái niệm trừu tượng dùng để biểu diễn một vật thể (cụ thể). Trong đó, các thuộc tính dùng để miêu tả đặc điểm, tính chất của đối tượng. Và các phương thức dùng để chỉ các hoạt động của đối tượng.
►Maplà một cấu trúc dữ liệu cho phép lưu trữ dữ liệu theo kiểukey-value, tương tự như object."
492,So sánh map và object trong Javascript,So sánh Map với Object trong JavaScript,"Sau đây là một số đặc điểmgiống nhau và khác nhaugiữa Map và Object.
Trước khi Map xuất hiện, người ta vẫn thường sử dụng Object cho việc lưu trữ dữ liệu dạngkey-value.
Tuy nhiên, khái niệm Object lại quá rộng, mọi thứ đều có thể là Object. Còn Map thì hướng nhiều hơn đến việclưu trữ dữ liệu.
Vậy Map khác Object như thế nào?
Object chỉ cho phép kiểu dữ liệu củakeylàStringhoặcSymbol.

```js
const symbol1 = Symbol(1);

const obj = {
  x: 1,
  ""a b"": 2,
  symbol1: 3,
};

console.log(obj);
// {x: 1, a b: 2, symbol1: 3}
```
`const symbol1 = Symbol(1);

const obj = {
  x: 1,
  ""a b"": 2,
  symbol1: 3,
};

console.log(obj);
// {x: 1, a b: 2, symbol1: 3}` Ngược lại, Map cho phépmọi kiểu dữ liệucó thể làm key, kể cảnumber,NaN,function, object,...
`NaN` 
```js
const fun = function () {};

const map = new Map();
map.set(NaN, 1).set(1, 2).set(""a"", 3).set([2], 4).set({ x: 3 }, 5).set(fun, 6);

// Map(7) {
//  NaN => 1, 1 => 2, ""a"" => 3, [2] => 4, {x:3} => 5, function() {} => 6
// }
```
`const fun = function () {};

const map = new Map();
map.set(NaN, 1).set(1, 2).set(""a"", 3).set([2], 4).set({ x: 3 }, 5).set(fun, 6);

// Map(7) {
//  NaN => 1, 1 => 2, ""a"" => 3, [2] => 4, {x:3} => 5, function() {} => 6
// }` Mapduy trì thứ tự của keygiống như khi chúng được thêm vào.

```js
const map = new Map();
map.set(""xyz"", 1);
map.set(""b"", 2);
map.set(""1"", 4);

for (const key of map.keys()) {
  console.log(key);
}
/*
 * xyz
 * b
 * 1
 */
```
`const map = new Map();
map.set(""xyz"", 1);
map.set(""b"", 2);
map.set(""1"", 4);

for (const key of map.keys()) {
  console.log(key);
}
/*
 * xyz
 * b
 * 1
 */` Object thì không đảm bảo thứ tự các key.

```js
const obj = { xyz: 1 };
obj.b = 2;
obj[""1""] = 4;

for (const key in obj) {
  console.log(key);
}

/*
 * 1
 * xyz
 * b
 */
```
`const obj = { xyz: 1 };
obj.b = 2;
obj[""1""] = 4;

for (const key in obj) {
  console.log(key);
}

/*
 * 1
 * xyz
 * b
 */` Bạn có thể lấy kích thước của Map thông qua thuộc tínhsize.
`size` 
```js
const map = new Map();
map.set(""xyz"", 1);
map.set(""b"", 2);
map.set(""1"", 4);

console.log(map.size);
// 3
```
`const map = new Map();
map.set(""xyz"", 1);
map.set(""b"", 2);
map.set(""1"", 4);

console.log(map.size);
// 3` Đối với Object, bạn phảiđếm số lượng các thuộc tính thủ công. Hoặc bạn tính số lượng này một cáchgián tiếp, thông qua phương thứcObject.keys().
Bởi lẽ, phương thứcObject.keys()trả về một mảng chứa cáckeycủa Object. Lúc này, bạn chỉ cần sử dụng thuộc tínhlengthcủaarraylà được.
`Object.keys()` `length` 
```js
const obj = { xyz: 1 };
obj.b = 2;
obj[""1""] = 4;

// sử dụng vòng lặp for...in
let size = 0;
for (const key in obj) size++;
console.log(size);
// 3

// sử dụng Object.keys
console.log(Object.keys(obj).length);
// 3
```
`const obj = { xyz: 1 };
obj.b = 2;
obj[""1""] = 4;

// sử dụng vòng lặp for...in
let size = 0;
for (const key in obj) size++;
console.log(size);
// 3

// sử dụng Object.keys
console.log(Object.keys(obj).length);
// 3` Để kiểm tra xem mộtkeytồn tại trong Map hay chưa, bạn có thể dùng phương thứcmap.has.
`map.has` 
```js
const map = new Map([
  [""a"", 1],
  [""b"", 2],
]);

console.log(map.has(""a"")); // true
console.log(map.has(""c"")); // false
```
`const map = new Map([
  [""a"", 1],
  [""b"", 2],
]);

console.log(map.has(""a"")); // true
console.log(map.has(""c"")); // false` Đối với Object, bạn sử dụng gián tiếp thông qua phương thứcObject.keys()như trên.
`Object.keys()` 
```js
const obj = { a: 1, b: 2 };
const hasKey = (obj, key) => Object.keys(obj).indexOf(key) !== -1;

console.log(hasKey(obj, ""a"")); // true
console.log(hasKey(obj, ""c"")); // false
```
`const obj = { a: 1, b: 2 };
const hasKey = (obj, key) => Object.keys(obj).indexOf(key) !== -1;

console.log(hasKey(obj, ""a"")); // true
console.log(hasKey(obj, ""c"")); // false` Trong đó,hasKeylà hàm tự định nghĩa. Và bạn thấy làObject.keys(obj)trả về một mảng chứa các key củaobj.
`hasKey` `Object.keys(obj)` `obj` Tiếp theo, mình sử dụng phương thứcarr.indexOf()để kiểm tra xemkey đã tồn tại trong mảng hay chưa.
Phương thứcarr.indexOf()trả về giá trịindex đầu tiên thoả mãn, ngược lại thì trả về-1. Nói cách khác, nếu index tìm được mà khác-1thì key đang tìm tồn tại trong Object.
`arr.indexOf()` `-1` `-1` Bạn có thể duyệt qua các phần tử của Map (để lấykey,valuehoặc[key, value]) một cách trực tiếp thông quafor...of.
`key` `value` `[key, value]` `for...of` 
```js
const map = new Map([
  [""a"", 1],
  [""b"", 2],
]);

// duyệt các keys
for (const key of map.keys()) {
  console.log(key);
}
/*
 * a
 * b
 */

// duyệt các values
for (const value of map.values()) {
  console.log(value);
}
/*
 * 1
 * 2
 */

// duyệt các cặp [key, value]
for (const [key, value] of map) {
  console.log(key, value);
}
/*
 * a 1
 * b 2
 */
```
`const map = new Map([
  [""a"", 1],
  [""b"", 2],
]);

// duyệt các keys
for (const key of map.keys()) {
  console.log(key);
}
/*
 * a
 * b
 */

// duyệt các values
for (const value of map.values()) {
  console.log(value);
}
/*
 * 1
 * 2
 */

// duyệt các cặp [key, value]
for (const [key, value] of map) {
  console.log(key, value);
}
/*
 * a 1
 * b 2
 */` Với Object, bạn chỉ có thể duyệt qua cáckey, sau đó lấyvaluethông quakey(vì object mặc địnhkhông phảiiterablenên không dùng được vớifor...of).
`key` `value` `key` `for...of` 
```js
const obj = { a: 1, b: 2 };

for (const key in obj) {
  console.log(key, obj[key]);
}
/*
 * a 1
 * b 2
 */
```
`const obj = { a: 1, b: 2 };

for (const key in obj) {
  console.log(key, obj[key]);
}
/*
 * a 1
 * b 2
 */`"
493,So sánh map và object trong Javascript,Tổng kết,"Như vậy là mình đã so sánh Map với Object. Qua đây, mình thấy rằng Map đúng là rất phù hợp với các yêu cầu liên quan đến lưu trữ dữ liệu.
Vì nó hỗ trợ sẵn các phương thức liên quan đến việcthêm, sửa, xoádữ liệu dựa theokey. Còn đối với các yêu cầu khác thì mình vẫn phải/nên sử dụng Object.
Các bạn thấy Map và Object giống và khác nhau ở những điểm nào nữa không? Nếu biết thì chia sẻ trong phần bình luận nhé!
Tham khảo:"
494,So sánh trong Javascript,Giới thiệu,"Qua bài viết trước, bạn đã biếttoán tử là gì, cũng như các loại toán tử trong JavaScript giúp cho việc tính toán. Tiếp theo, mình sẽ tìm hiểu vềtoán tử so sánhtrong JavaScript.
Cụ thể, bài viết này tập trung vào tìm hiểu toán tử so sánh là gì, các loại toán tử so sánh trong JS, kết quả của phép so sánh và một số trường hợp đặc biệt (dễ nhầm lẫn) khi so sánh."
495,So sánh trong Javascript,Toán tử so sánh là gì?,"Toán tử so sánhlà toán tử hai ngôi dùng để so sánh giá trị của hai toán hạng với nhau.
Các toán tử so sánh trong JavaScript bao gồm:
`>` `<` `>=` `<=` `==` `===` `!=` `!==` Có thể bạn chưa biết
Ví dụ các phép toán so sánh:

```js
let a = 1;
let b = 2;

a > b; // so sánh lớn hơn
a < b; // so sánh lớn hơn
a >= b; // so sánh lớn hơn hoặc bằng
a <= b; // so sánh nhỏ hơn hoặc bằng
a == b; // so sánh bằng không nghiêm ngặt
a === b; // so sánh bằng nghiêm ngặt
a != b; // so sánh khác không nghiêm ngặt
a !== b; // so sánh khác nghiêm ngặt
```
`let a = 1;
let b = 2;

a > b; // so sánh lớn hơn
a < b; // so sánh lớn hơn
a >= b; // so sánh lớn hơn hoặc bằng
a <= b; // so sánh nhỏ hơn hoặc bằng
a == b; // so sánh bằng không nghiêm ngặt
a === b; // so sánh bằng nghiêm ngặt
a != b; // so sánh khác không nghiêm ngặt
a !== b; // so sánh khác nghiêm ngặt`"
496,So sánh trong Javascript,Kết quả của phép so sánh,"Kết quả của phép so sánh luôn là một giá trị kiểuboolean.
`true` `false` 
```js
console.log(5 > 6); // false (sai)
console.log(5 < 6); // true (đúng)
console.log(5 >= 6); // false (sai)
console.log(5 <= 6); // true (đúng)
console.log(5 == 6); // false (sai)
console.log(5 === 6); // false (sai)
console.log(5 != 6); // true (đúng)
console.log(5 !== 6); // true (đúng)
```
`console.log(5 > 6); // false (sai)
console.log(5 < 6); // true (đúng)
console.log(5 >= 6); // false (sai)
console.log(5 <= 6); // true (đúng)
console.log(5 == 6); // false (sai)
console.log(5 === 6); // false (sai)
console.log(5 != 6); // true (đúng)
console.log(5 !== 6); // true (đúng)` Bạn có thể gán kết quả của phép so sánh cho một biến khác:

```js
let ret = 6 > 9;
console.log(ret); // false (sai)
```
`let ret = 6 > 9;
console.log(ret); // false (sai)`"
497,So sánh trong Javascript,So sánh string trong javascript,"Quy tắc so sánh hai string trong JavaScript cũng giống như hầu hết các ngôn ngữ lập trình khác. Đó là so sánh theo thứ tự ""từ điển"". Hay nói cách khác là so sánh từng chữ cái một (từ trái sang phải).
Ví dụ so sánh các string:

```js
console.log(""A"" < ""Z""); // true
console.log(""Small"" < ""Smart""); // true
console.log(""Big"" < ""BigBang""); // true
```
`console.log(""A"" < ""Z""); // true
console.log(""Small"" < ""Smart""); // true
console.log(""Big"" < ""BigBang""); // true` Tóm tắtthuật toán so sánh hai stringnhư sau:
So sánh kí tự đầu tiên của hai string.
Lặp lại việc so sánh như trên, cho đến khiso sánh kết thúckết thúc hoặcđã so sánh hếtcác kí tự của ít nhất một string.
Trong ví dụ so sánh""A"" < ""Z""kết quả làtrue. Quá trình so sánh dừng lại ở bước một.
`""A"" < ""Z""` `true` Trong ví dụ so sánh""Small"" < ""Smart""kết quả làtrue. Quá trình so sánh lặp lại nhiều lần.
`""Small"" < ""Smart""` `true` `S` `m` `a` `l` `r` `""Small""` `""Smart""` Trong ví dụ so sánh""Big"" < ""BigBang""kết quả làtrue. Quá trình so sánh cùng lặp lại nhiều lần. Ba kí tự đầu tiên là""Big""đều giống nhau. Lúc này, string""Big""kết thúc. Trong khi, string""BigBang""còn thêm các kí tự""Bang""(độ dài string lớn hơn). Suy ra, string""Big""nhỏ hơn string""BigBang"".
`""Big"" < ""BigBang""` `true` `""Big""` `""Big""` `""BigBang""` `""Bang""` `""Big""` `""BigBang""` Có thể bạn chưa biết
`0 < 9 < A < Z < a < z`"
498,So sánh trong Javascript,So sánh khác kiểu dữ liệu trong Javascript,"Khi so sánh các toán hạng khác kiểu dữ liệu, JavaScript chuyển đổi giá trị các toán hạng ra dạng số, ví dụ:

```js
console.log(""5"" > 4); // true, vì ""5"" chuyển thành 5
console.log(""01"" == 1); // true, vì ""01"" chuyển thành 1
console.log(""11"" == 1); // false, vì ""11"" chuyển thành 11
```
`console.log(""5"" > 4); // true, vì ""5"" chuyển thành 5
console.log(""01"" == 1); // true, vì ""01"" chuyển thành 1
console.log(""11"" == 1); // false, vì ""11"" chuyển thành 11` Đối với kiểu dữ liệu boolean,truesẽ chuyển thành1vàfalsechuyển thành0.
`true` `1` `false` `0` 
```js
console.log(true == 1); // true
console.log(false == 0); // true
```
`console.log(true == 1); // true
console.log(false == 0); // true` Việc so sánh khác kiểu dữ liệu sử dụng toán tử bằng ""không nghiêm ngặt""==dẫn đến một số trường hợp ""phi logic"", ví dụ:
`==` 
```js
console.log("""" == 0); // true
console.log(""0"" == 0); // true
console.log("""" == ""0""); // false
```
`console.log("""" == 0); // true
console.log(""0"" == 0); // true
console.log("""" == ""0""); // false` Kì lạ phải không?
Nếu theo tính chất ""bắc cầu"" trong toán học thì nếu"""" == 0làtruevà""0"" == 0làtrue, suy ra"""" == ""0""cũng phải làtrue(vì cùng bằng0).
`"""" == 0` `true` `""0"" == 0` `true` `"""" == ""0""` `true` `0` Nhưng thực tế lại không phải như vậy, hai phép so sánh đầu tiên làso sánh khác kiểu dữ liệu, nên""""và""0""đều được chuyển thành dạng số và bằng 0.
`""""` `""0""` Trong khi phép so sánh thứ ba làso sánh cùng kiểu dữ liệu, nên không có quá trình chuyển đổi dữ liệu xảy ra. Dẫn đến, kết quả của phép so sánh cuối làfalse.
`false` Để giải quyết vấn đế này, JavaScript tạo ra toán tử so sánh bằng ""nghiêm ngặt""===.
`===`"
499,So sánh trong Javascript,So sánh bằng nghiêm ngặt,"Đối với toán tử so sánh bằng ""nghiêm ngặt"", JavaScript sẽ không thực hiện chuyển đổi kiểu dữ liệu.
Nói cách khác, hai giá trịkhác kiểu dữ liệuthì luôn khác nhau, ví dụ:

```js
// So sánh bằng không nghiêm ngặt
console.log("""" == 0); // true

// So sánh bằng nghiêm ngặt
console.log("""" === 0); // false
```
`// So sánh bằng không nghiêm ngặt
console.log("""" == 0); // true

// So sánh bằng nghiêm ngặt
console.log("""" === 0); // false` Tương tự với so sánh bằng nghiêm ngặt, JavaScript cũng cóso sánh khác nghiêm ngặt, ví dụ:

```js
// So sánh khác không nghiêm ngặt
console.log("""" != 0); // false

// So sánh khác nghiêm ngặt
console.log("""" !== 0); // true
```
`// So sánh khác không nghiêm ngặt
console.log("""" != 0); // false

// So sánh khác nghiêm ngặt
console.log("""" !== 0); // true` Có thể bạn chưa biết
💡 Để tránh mắc phải những lỗi sai ngớ ngẩn khi so sánh trong JavaScript, bạn nên sử dụng toán tử so sánh bằng ""nghiêm ngặt""===và toán tử so sánh khác ""nghiêm ngặt""!==.
`===` `!==`"
500,So sánh trong Javascript,So sánh vớinullvàundefined,"`null` `undefined` Khác với các kiểu dữ liệu khác, việc so sánhnullvàundefinedthường không rõ ràng cho lắm.
`null` `undefined` Khi sử dụng toán tử so sánh bằng ""nghiêm ngặt""===thì dĩ nhiên là hai giá trị này khác nhau. Vì chúng khác kiểu dữ liệu.
`===` 
```js
console.log(null === undefined); // false
```
`console.log(null === undefined); // false` Nhưng khi sử dụng toán tử so sánh bằng ""không nghiêm ngặt""==thì kết quả lại làtrue.
`==` `true` 
```js
console.log(null == undefined); // true
```
`console.log(null == undefined); // true` Thực tế, JavaScript đã quy địnhnullvàundefinedlà bằng nhau (với trường hợp==). Và chúng không bằng (==) các giá trị khác.
`null` `undefined` `==` `==` Khi sử dụng các toán tử so sánh>,<,>=và<=thì sao?
`>` `<` `>=` `<=` Hai giá trị này sẽ được chuyển sang dạng số. Cụ thểnullchuyển thành0vàundefinedchuyển thànhNaN.
`null` `0` `undefined` `NaN` Khi sử dụng các toán tử so sánh>,<,>=và<=vớinullvàundefinedthì kết quả đềufalsehết.
`>` `<` `>=` `<=` `null` `undefined` `false` 
```js
console.log(null > undefined); // false
console.log(null < undefined); // false
console.log(null >= undefined); // false
console.log(null <= undefined); // false
```
`console.log(null > undefined); // false
console.log(null < undefined); // false
console.log(null >= undefined); // false
console.log(null <= undefined); // false` Bây giờ, mình thử so sánh hai giá trị này với số0xem có gì kỳ lạ không nào!
`0` So sánhnullvới 0
`null` 
```js
console.log(null > 0); // false (1)
console.log(null >= 0); // true (2)
console.log(null == 0); // false (3)
```
`console.log(null > 0); // false (1)
console.log(null >= 0); // true (2)
console.log(null == 0); // false (3)` Trong các phép so sánh (1), (2),nullchuyển thành số0nên ta có đáp án lần lượt làfalsevàtrue. Nhưng ở phép so sánh (3),nullkhông chuyển thành0nên kết quả làfalse.
`null` `0` `false` `true` `null` `0` `false` Đây lại là một điều khá ""phi logic"". Vì theo kết quả trên thìnulllớn hơn hoặc bằng 0 (sử dụng>=), nhưng lại không bằng 0 (sử dụng==).
`null` `>=` `==` So sánhundefinedvới 0
`undefined` 
```js
console.log(undefined > 0); // false (1)
console.log(undefined >= 0); // false (2)
console.log(undefined == 0); // false (3)
```
`console.log(undefined > 0); // false (1)
console.log(undefined >= 0); // false (2)
console.log(undefined == 0); // false (3)` Kết quả làfalsehết.
`false` Trong các phép so sánh (1) và (2),undefinedchuyển thànhNaNnên chắc chắn khác0. Trong khi phép so sánh (3),undefinedkhông bằng (==)0. Vì như mình đã nói ở trên,undefinedchỉ bằng (==)nullmà thôi.
`undefined` `NaN` `0` `undefined` `==` `0` `undefined` `==` `null` Có thể bạn chưa biết
`null` `undefined` `===` `!==` `>` `<` `>=` `<=` `null` `undefined` `null` `undefined` `null` `undefined` `null` `undefined` `>` `<` `>=` `<=`"
501,So sánh trong Javascript,Thứ tự ưu tiên của các toán tử so sánh,"Các toán tử so sánh cóthứ tự ưu tiên giống nhau. Khi trong biểu thức có nhiều toán tử so sánh, thứ tự thực hiện làtừ trái sang phải.

```js
console.log(3 > 2 > 1); // false
```
`console.log(3 > 2 > 1); // false` Thoạt đầu nhìn qua, bạn sẽ thấy kết quả trên là vô lý phải không?
Vì theo toán học thì chắc chắn số3lớn hơn số2và số2lớn hơn số1, nên kết quả (2) phải bằngtruemới hợp lý.
`3` `2` `2` `1` `true` Nhưng nếu bạn áp dụng đúngquy tắc thứ tự ưu tiênvào đây, bạn sẽ thấy kết quả trên làhoàn toàn đúng.
Vì JavaScript sẽ thực hiện so sánh hai số đầu tiên trước,3 > 2là đúng nên kết quả của phép so sánh này làtrue. Khi đó, mình có thể viết lại như sau:
`3 > 2` `true` 
```js
console.log(true > 1); // false
```
`console.log(true > 1); // false` Rõ ràng, đây là phép so sánhhai kiểu dữ liệu khác nhau. Vì vậy,trueđược chuyển thành dạng số và bằng1. Mà1 > 1làfalse.
`true` `1` `1 > 1` `false` Tóm lại, kết quả của phép so sánh trên làfalse.
`false` `(...)` `console.log((3 > 2) > 1)` `3 > 2` `2 > 1` `console.log(3 > (2 > 1))` `true`"
502,So sánh trong Javascript,Tổng kết,"Sau đây là những kiến thức cơ bản cần nhớ về toán tử so sánh trong JavaScript:
`>` `<` `>=` `<=` `==` `===` `!=` `!==` `===` `!==` `null` `undefined` `==` `>` `<` `>=` `<=` `null` `undefined` `null` `undefined` `null` `undefined` `null` `undefined` `>` `<` `>=` `<=`"
503,So sánh trong Javascript,Thực hành,"Kết quả của các phép so sánh sau là gì?

```js
console.log(15 > 9); // (1)
console.log(""no"" <= ""none""); // (2)
console.log(""3"" >= ""24""); // (3)
console.log(""3"" > 24); // (4)
console.log(null < undefined); // (5)
console.log(undefined == null); // (6)
console.log(undefined === null); // (7)
console.log(null == ""\n0\n""); // (8)
console.log(null === +""\n0\n""); // (9)
console.log(null > -1); // (10)
```
`console.log(15 > 9); // (1)
console.log(""no"" <= ""none""); // (2)
console.log(""3"" >= ""24""); // (3)
console.log(""3"" > 24); // (4)
console.log(null < undefined); // (5)
console.log(undefined == null); // (6)
console.log(undefined === null); // (7)
console.log(null == ""\n0\n""); // (8)
console.log(null === +""\n0\n""); // (9)
console.log(null > -1); // (10)` Xem đáp án

```js
console.log(15 > 9); // true
console.log(""no"" <= ""none""); // true
console.log(""3"" >= ""24""); // true
console.log(""3"" > 24); // false
console.log(null < undefined); // false
console.log(undefined == null); // true
console.log(undefined === null); // false
console.log(null == ""\n0\n""); // false
console.log(null === +""\n0\n""); // false
console.log(null >= -1); // true
```
`console.log(15 > 9); // true
console.log(""no"" <= ""none""); // true
console.log(""3"" >= ""24""); // true
console.log(""3"" > 24); // false
console.log(null < undefined); // false
console.log(undefined == null); // true
console.log(undefined === null); // false
console.log(null == ""\n0\n""); // false
console.log(null === +""\n0\n""); // false
console.log(null >= -1); // true` Giải thích:
`15` `9` `""no""` `""none""` `""no""` `""none""` `""3""` `""2""` `""3""` `""24""` `""3""` `3` `3` `24` `null` `undefined` `==` `false` `>` `null` `null` `0` `0` `-1` `true`"
504,Strict Mode trong JavaScript,Giới thiệu,"Từ khóa use strict là từ khóa để bật chế độStrict Mode, tạm dịch là chế độ nghiêm ngặt của JavaScript, bắt đầu xuất hiện từ phiên bảnECMAScript 5. Khi một đoạn lệnh được khai báouse strictthì tất cả các dòng code ở phía dưới dòng khai báo use strict sẽ được JavaScript quản lý nghiêm ngặt hơn về mặt cú pháp.
`Strict Mode` `ECMAScript 5` `use strict`"
505,Strict Mode trong JavaScript,Strict mode trong javascript là gì?,"Stricthiểu đơn giản theo nghĩa tiếng Việt là ""nghiêm ngặt, nghiêm khắc"".Strict Modelà một quy mẫu nghiêm khắc của Javascript. Nếu như coi việc viết code bình thường làNormal Mode, thìStrict Modesẽ có thêm nhiều quy định khác so vớiNormal Mode. Việc đó khiến cho một thao tác vốn bình thường có thể chạy ngon lành trở nên lỗi, và throw ra errors.
`Strict` `Strict Mode` `Normal Mode` `Strict Mode` `Normal Mode` Nhìn chung, Strict được tạo ra nhằm:
`throw errors` `unsafe` `keywork` Strict Modecó nhiều hạn chế hơn so vớinormal mode. Với việc tuân theo những quy định đó, bạn sẽ làm cho code Javascript của mình trở nên sáng sủa, dễ đọc hơn, cũng như ít vướng phải những lỗi không mong muốn.
`Strict Mode` `normal mode` Khi đọc đến đây, chắc hẳn bạn sẽ đặt câu hỏi rằng, vậy sau người ta không thay đổi hẳn phần đặc tả của ECMAScript liên quan đến những gì được đề cập trongStrict Modeđi, mà lại sinh ra thêm cáiStrict Modelàm gì cho nó rắc rối?
`Strict Mode` `Strict Mode` Có lẽ một phần là để đảm bảo phần nào tính backward compatible giữa ES5 và phiên bản trước đó là ES3, phần nữa là để ECMAScript vẫn giữ được tính đơn giản, mềm dẻo từ trước, chứ không phải bị giới hạn bởi những quy tắc cứng nhắc mới được thêm vào. Từ đó ECMAScript sẽ trở nên dễ dàng tiếp cận hơn đối với những người mới làm quen.
Tuy nhiên khi đã qua giai đoạn ""làm quen"" rồi, thì bạn cần thay đổi. Đó là lúc bạn cần đếnStrict Mode.
`Strict Mode`"
506,Strict Mode trong JavaScript,Cách sử dụng strict mode trong javascript,"Để bật chế độ strict mode cũng rất đơn giản, bạn chỉ cần đặt như thế này ở đầu file JS, hoặc đầu một hàm:

```js
""use strict"";
```
`""use strict"";` Chỉ cần gõ như vậy ở đầu một file (dành cho toàn cục), hay đầu một function (dành cho cục bộ).
Các bạn xem đoạn code dưới đây, tình huống đặt ra là chúng ta sử dụnguse strictcho toàn bộ code JavaScript. Sau đó, chúng ta không khai báo biếnmessagemà vẫn sử dụng nó.
`use strict` `message` 
```js
<script>
  // Khai báo đầu file
  ""use strict"";

  // Đoạn code này lỗi vì biến message chưa được khởi tạo
  message = ""Học lập trình JavaScript cơ bản!"";

  // In ra màn hình
  document.write(message);
</script>
```
`<script>
  // Khai báo đầu file
  ""use strict"";

  // Đoạn code này lỗi vì biến message chưa được khởi tạo
  message = ""Học lập trình JavaScript cơ bản!"";

  // In ra màn hình
  document.write(message);
</script>` Kết quả trong tab console như sau:
Chương trình sẽ báo lỗi như trên do chúng ta sử dụng strict mode (chế độ code nghiêm ngặt). Bây giờ mình comment dòng // “use strict”; lại và chạy lại để xem kết quả:
Chương trình sẽ chạy bình thường dù chúng ta không khai báo biếnmessagetrước đó. Nhưng, điều này có thể gây ra lỗi về sau.
`message` Để khai báo stric mode trong cục bộ, đơn giản là bạn đặtuse stricttrong phạm vi cục bộ nào đó.
`use strict` Ví dụ, mình tinh chỉnh một chút ở đoạn code trên để nó thành phạm vi cục bộ cho các bạn tiện theo dõi.

```js
<script>
  function print_message() {
    // Khai báo đầu function
    ""use strict"";
  }
  print_message();
  message = ""Phạm vi ngoài hàm print_message"";
  document.write(message);
</script>
```
`<script>
  function print_message() {
    // Khai báo đầu function
    ""use strict"";
  }
  print_message();
  message = ""Phạm vi ngoài hàm print_message"";
  document.write(message);
</script>` Chạy trên trình duyệt, kết quả nhận được:
Đoạn code này thì kết quả vẫn chạy bình thường vì chúng tause stricttrong hàmprint_message()nên không ảnh hưởng ra bên ngoài.
`use strict` `print_message()` Nếu chúng ta sử dụng một biến không khai báo trong phạm vi cục bộ này thì chương trình sẽ báo lỗi và không chạy.

```js
<script>
  function print_message() {
    // Khai báo đầu function
    ""use strict"";
    // Đoạn code này lỗi vì biến message chưa được khởi tạo
    message = ""Học lập trình JavaScript cơ bản!"";

    // In ra màn hình
    document.write(message);
  }
  print_message();
  message = ""Phạm vi ngoài hàm print_message"";
  document.write(message);
</script>
```
`<script>
  function print_message() {
    // Khai báo đầu function
    ""use strict"";
    // Đoạn code này lỗi vì biến message chưa được khởi tạo
    message = ""Học lập trình JavaScript cơ bản!"";

    // In ra màn hình
    document.write(message);
  }
  print_message();
  message = ""Phạm vi ngoài hàm print_message"";
  document.write(message);
</script>` Đến đây thì bạn đã hiểu cơ bản về chế độ nghiêm ngặt trong phạm vi toàn cục và phạm vi cục bộ rồi."
507,Strict Mode trong JavaScript,Browser console,"Khi bạn sử dụng developer console trên trình duyệt (như chrome, safari,...) để chạy code thì mặc định là chế độ không nghiêm ngặt. Đôi khi bạn cần sử dụng chế độuse strictđể kiểm tra kết quả thì hãy thêm""use strict""như các ví dụ bên trên nhé.
`use strict` `""use strict""` 
```js
'use strict'; <Shift+Enter for a newline>
//  ...your code
<Enter to run>
```
`'use strict'; <Shift+Enter for a newline>
//  ...your code
<Enter to run>`"
508,Strict Mode trong JavaScript,Vậy có nên sử dụng use strict không,"Câu trả lời có vẻ hiển nhiên là có, nhưng không phải vậy.
Người ta có thể khuyên bạn nên bắt đầu các tập lệnh với ""use strict""... Nhưng bạn biết điều gì thú vị không?
JavaScript hiện đại hỗ trợclassesvàmodules- các cấu trúc ngôn ngữ nâng cao (chúng ta sẽ tìm hiểu ở các bài sau), mà tự động sử dụnguse strict. Vì vậy, chúng ta không cần phải thêm chỉ thị ""use strict"", nếu chúng ta sử dụng chúng.
`classes` `modules` `use strict`"
509,Thủ thuật sử dụng console.log hiệu quả,Giới thiệu,"Có thể nói, sử dụngconsole.logđểdebug, kiểm tra lỗi là việc thường xuyên đối với hầu hết các lập trình viên JavaScript. Tuy nhiên, không phải ai cũng thực sự biết cách sử dụng công cụ này. Vì vậy, bài viết này mình sẽ chia sẻ với bạn một số thủ thuật sử dụng console hiệu quả mà mình mới học được. Mời bạn theo dõi bài viết!"
510,Thủ thuật sử dụng console.log hiệu quả,Sử dụng console.log,"Console.loglà hàm cơ bản nhất mà hầu như lập trình viên nào cũng dùng. Và hàm này có 2 cách sử dụng cơ bản như sau.

```js
console.log(obj1 [, obj2, ..., objN]);

Đối với cách 1, bạn liệt kê các giá trị, [object](/bai-viet/javascript/object-la-gi-object-trong-javascript) cách nhau bởi dấu phẩy, ví dụ:

    const foo = 1;
    const bar = ""bar"";
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.log(foo, bar, baz);
    // => 1 ""bar"" {name: ""John"", age: ""30"", gender: ""male""}
```
`console.log(obj1 [, obj2, ..., objN]);

Đối với cách 1, bạn liệt kê các giá trị, [object](/bai-viet/javascript/object-la-gi-object-trong-javascript) cách nhau bởi dấu phẩy, ví dụ:

    const foo = 1;
    const bar = ""bar"";
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.log(foo, bar, baz);
    // => 1 ""bar"" {name: ""John"", age: ""30"", gender: ""male""}` Theo mình đây là cách cơ bản mà hầu như lập trình viên nào cũng sử dụng. Bởi vì, cách này khá đơn giản và nhanh gọn.

```js
console.log(msg [, subst1, ..., substN]);
```
`console.log(msg [, subst1, ..., substN]);` Đối với cách 2, bạn hiển thịstringcùng với các tham số truyền vào. Mình chưa biết nói sao cho chuẩn. Tuy nhiên, nó khá giống với việc sử dụng hàmprintf()trong lập trình C, ví dụ:

```js
const foo = 1;
    const bar = ""bar"";
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.log(""Log: %d, %s and %o"", foo, bar, baz);
    // => Log: 1, bar and {name: ""John"", age: ""30"", gender: ""male""}
```
`const foo = 1;
    const bar = ""bar"";
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.log(""Log: %d, %s and %o"", foo, bar, baz);
    // => Log: 1, bar and {name: ""John"", age: ""30"", gender: ""male""}` Trong đó, phần string hiển thị có 3 tham số cần truyền vào ứng với%d,%svà%o. Và giá trị của nó sẽ được lấy từ 3 thành phần tiếp theo, cách nhau bởi dấu phẩy.
Chú ý:
Bạn cần sử dụng ký tự đại diện sao cho đúng với kiểu dữ bạn muốn hiển thị. Ngược lại, bạn sẽ thu được kết quả hiển thị không như mong muốn, ví dụ:

```js
const foo = 1;
    const bar = ""bar"";
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.log(""Log: %d, %s and %s"", foo, bar, baz);
    // => Log: 1, bar and Object
```
`const foo = 1;
    const bar = ""bar"";
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.log(""Log: %d, %s and %s"", foo, bar, baz);
    // => Log: 1, bar and Object` Trong ví dụ trên, mặc dù tham số thứ 3 bạn truyền vào là một object. Và bạn cũng muốn hiển thị đầy đủ nội dung của object. Tuy nhiên, nếu bạn sử dụng%sthì kết quả thu được sẽ chỉ là một string ""Object"".
Cách này mình cũng mới biết, vì thực tế chưa sử dụng nó bao giờ. Theo mình thấy cách này không phổ biến, bởi lẽ nó khá lằng nhằng. Và bạn phải ghi nhớ kí tự đại diện nào thì tương ứng với kiểu dữ liệu nào.
Trên đây, mình nhắc lại 2 cú pháp cơ bản sử dụng console.log rồi. Quay lại với chủ đề chính của bài viết hôm nay là làm sao sử dụng console.log cho hiệu quả.
Hãy thử xem ví dụ về cách sử dụng console.log sau đây:

```js
const foo = { name: ""Alex"", age: ""26"", gender: ""male"" };
    const bar = { name: ""Jenifer"", age: ""18"", gender: ""female"" };
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.log(foo, bar, baz);

    /*
     * {name: ""Alex"", age: ""26"", gender: ""male""}
     * {name: ""Jenifer"", age: ""18"", gender: ""female""}
     * {name: ""John"", age: ""30"", gender: ""male""}
     */
```
`const foo = { name: ""Alex"", age: ""26"", gender: ""male"" };
    const bar = { name: ""Jenifer"", age: ""18"", gender: ""female"" };
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.log(foo, bar, baz);

    /*
     * {name: ""Alex"", age: ""26"", gender: ""male""}
     * {name: ""Jenifer"", age: ""18"", gender: ""female""}
     * {name: ""John"", age: ""30"", gender: ""male""}
     */` Cách sử dụng console.log như trên có một vấn đề là: bạn không trực tiếp thấy được mỗi giá trị tương ứng với biến nào. Khi xem log, bạn phải quay lại code để xem thứ tự các biến là gì. Như vậy, chẳng phải là rất mất thời gian hay sao?
Có 2 giải pháp cho vấn đề trên.

```js
const foo = { name: ""Alex"", age: ""26"", gender: ""male"" };
  const bar = { name: ""Jenifer"", age: ""18"", gender: ""female"" };
  const baz = { name: ""John"", age: ""30"", gender: ""male"" };

  console.log(""foo"", foo);
  console.log(""bar"", bar);
  console.log(""baz"", baz);

  /\*

  - foo {name: ""Alex"", age: ""26"", gender: ""male""}
  - bar {name: ""Jenifer"", age: ""18"", gender: ""female""}
  - baz {name: ""John"", age: ""30"", gender: ""male""}
    \*/
```
`const foo = { name: ""Alex"", age: ""26"", gender: ""male"" };
  const bar = { name: ""Jenifer"", age: ""18"", gender: ""female"" };
  const baz = { name: ""John"", age: ""30"", gender: ""male"" };

  console.log(""foo"", foo);
  console.log(""bar"", bar);
  console.log(""baz"", baz);

  /\*

  - foo {name: ""Alex"", age: ""26"", gender: ""male""}
  - bar {name: ""Jenifer"", age: ""18"", gender: ""female""}
  - baz {name: ""John"", age: ""30"", gender: ""male""}
    \*/` Rõ ràng, bây giờ chỉ cần xem log là biết mỗi giá trị tương ứng với biến nào rồi phải không? Cách này khá ổn, tuy nhiên vẫn hơi mất công.

```js
const foo = { name: ""Alex"", age: ""26"", gender: ""male"" };
  const bar = { name: ""Jenifer"", age: ""18"", gender: ""female"" };
  const baz = { name: ""John"", age: ""30"", gender: ""male"" };

  console.log({ foo, bar, baz });

  /_
  {
  bar: {name: ""Jenifer"", age: ""18"", gender: ""female""},
  baz: {name: ""John"", age: ""30"", gender: ""male""},
  foo: {name: ""Alex"", age: ""26"", gender: ""male""},
  }
  _/
```
`const foo = { name: ""Alex"", age: ""26"", gender: ""male"" };
  const bar = { name: ""Jenifer"", age: ""18"", gender: ""female"" };
  const baz = { name: ""John"", age: ""30"", gender: ""male"" };

  console.log({ foo, bar, baz });

  /_
  {
  bar: {name: ""Jenifer"", age: ""18"", gender: ""female""},
  baz: {name: ""John"", age: ""30"", gender: ""male""},
  foo: {name: ""Alex"", age: ""26"", gender: ""male""},
  }
  _/` Cách này mình thấy khá sáng tạo và thú vị. Bởi cách viết rất ngắn gọn. Mà nội dung hiển thị ra lại đầy đủ và chi tiết."
511,Thủ thuật sử dụng console.log hiệu quả,Sử dụng console.table hiển thị thông tin trực quan hơn,"Tiếp tục với ví dụ bên trên, mình có thể sử dụngconsole.tableđể hiển thị các giá trị thành dạng bảng như sau:

```js
const foo = { name: ""Alex"", age: ""26"", gender: ""male"" };
    const bar = { name: ""Jenifer"", age: ""18"", gender: ""female"" };
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.table([foo, bar, baz]);
```
`const foo = { name: ""Alex"", age: ""26"", gender: ""male"" };
    const bar = { name: ""Jenifer"", age: ""18"", gender: ""female"" };
    const baz = { name: ""John"", age: ""30"", gender: ""male"" };

    console.table([foo, bar, baz]);` Kết quả
┌─────────┬──────────┬─────┬─────────┐│ (index) │   name   │ age │ gender  │├─────────┼──────────┼─────┼─────────┤│    0    │  'Alex'  │ '26'│ 'male'  ││    1    │ 'Jenifer'│ '18'│'female' ││    2    │  'John'  │ '30'│ 'male'  │└─────────┴──────────┴─────┴─────────┘"
512,Thủ thuật sử dụng console.log hiệu quả,Sử dụng console.time và console.timeEnd,"Trong 2 bài viết là: Triển khai Stack trong JavaScript với Array, Object hay Map và Triển khai Queue trong JavaScript, mình có sử dụngperformance.now()để tính toán thời gian thực hiện.
Trong đó, cách sử dụng của mình như sau:

```js
let start = performance.now();

    let i = 0;
    while (i < 1000000) {
      i++;
    }

    let end = performance.now();

    console.log(`looper: ${end - start}ms`);
    // => looper: 5.25999999808846ms
```
`let start = performance.now();

    let i = 0;
    while (i < 1000000) {
      i++;
    }

    let end = performance.now();

    console.log(`looper: ${end - start}ms`);
    // => looper: 5.25999999808846ms` Ở đây, mình phải lấy thời điểm sau và thời điểm trước rồi trừ cho nhau để suy ra thời gian thực hiện của vòng lặp.
Tuy nhiên, nếu sử dụngconsole.timevàconsole.timeEndthì sẽ đơn giản hơn như sau:

```js
console.time(""looper"");

    let i = 0;
    while (i < 1000000) {
      i++;
    }

    console.timeEnd(""looper"");
    // => looper: 5.14501953125ms
```
`console.time(""looper"");

    let i = 0;
    while (i < 1000000) {
      i++;
    }

    console.timeEnd(""looper"");
    // => looper: 5.14501953125ms`"
513,Thủ thuật sử dụng console.log hiệu quả,Lời kết,"Trên đây là một số thủ thuật sử dụng console hiệu quả mà mình mới học được. Theo bạn thì những thủ thuật trên có thật sự cần thiết hay không?
Ngoài ra, bạn còn biết những thủ thuật, tiện ích nào với console hay không? Chia sẻ với mình và mọi người trong phần bình luận phía dưới nhé!
Xin chào và hẹn gặp lại, thân ái!
Tham khảo:"
514,Switch case trong Javascript,Giới thiệu,"Trong bài viết vềcấu trúc rẽ nhánh trong JavaScript, mình đã tìm hiểu về câu lệnhifvà toán tử?. Ngoài ra, mình cũng có thể sử dụnglệnh switch caselàm cấu trúc rẽ nhánh thay thế cho câu lệnhif.
`if` `?` `if` Sau đây, mình cùng tìm hiểu về cách sử dụng câu lệnh switch - case trong JavaScript và khi nào thì nên sử dụng cấu trúc rẽ nhánh switch - case."
515,Switch case trong Javascript,Lệnh switch case là gì?,"Câu lệnh switch - case trong JavaScript là một cấu trúc rẽ nhánh dùng đểxác định một danh sách các trường hợp và khối lệnh tương ứng với mỗi trường hợp.
Khi giá trị đang xétbằng nghiêm ngặt(===) với trường hợp nào thì khối lệnh tương ứng bắt đầu từ trường hợp đó được thực thi.
`===`"
516,Switch case trong Javascript,Cú pháp câu lệnh switch case,"Lệnh switch case trong JS có cú pháp như sau:

```js
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}
```
`switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}` Trong đó:
`x` `value1` `value2` `case` `break` `default` `break`"
517,Switch case trong Javascript,Ví dụ lệnh switch case,"Sau đây là ví dụ sử dụng lệnh switch case trong JavaScript:

```js
const x = 2 + 3;

switch (x) {
  case 4:
    console.log(""Less than"");
    break;
  case 5:
    console.log(""Equal"");
    break;
  case 6:
    console.log(""Greater than"");
    break;
  default:
    console.log(""Don't know the answer"");
}

// Equal
```
`const x = 2 + 3;

switch (x) {
  case 4:
    console.log(""Less than"");
    break;
  case 5:
    console.log(""Equal"");
    break;
  case 6:
    console.log(""Greater than"");
    break;
  default:
    console.log(""Don't know the answer"");
}

// Equal` Kết quả
Equal
Giải thích:
`switch` `x` `case` `4` `5` `6` `case 4` `x` `5` `case 5` `x` `Equal` `break` Nếu không có từ khóabreakthì sao?
`break` Nếu không có từ khóabreakthì toàn bộ khối lệnh phía saucase 5được thực thi.
`break` `case 5` 
```js
const x = 2 + 3;

switch (x) {
  case 4:
    console.log(""Less than"");
  case 5:
    console.log(""Equal"");
  case 6:
    console.log(""Greater than"");
  default:
    console.log(""Don't know the answer"");
}

// Equal
// Greater than
// Don't know the answer
```
`const x = 2 + 3;

switch (x) {
  case 4:
    console.log(""Less than"");
  case 5:
    console.log(""Equal"");
  case 6:
    console.log(""Greater than"");
  default:
    console.log(""Don't know the answer"");
}

// Equal
// Greater than
// Don't know the answer` switchvàcaseđều có thể chứa biểu thức - không chỉ làbiếnhayhằng.
`switch` `case` Ví dụ lệnh switch case với biểu thức:

```js
let x = ""3"";
let v = 0;

switch (x - 1) {
  case v + 1:
    console.log(""case 1"");
    break;
  case v + 2:
    console.log(""case 2"");
    break;
  default:
    console.log(""default"");
}

// case 2
```
`let x = ""3"";
let v = 0;

switch (x - 1) {
  case v + 1:
    console.log(""case 1"");
    break;
  case v + 2:
    console.log(""case 2"");
    break;
  default:
    console.log(""default"");
}

// case 2` Vìx = ""3""nên ta cóx - 1bằng""3"" - 1. Trường hợp này là phép trừ hai giá trị khác kiểu dữ liệu, nên kí tự""3""đượcchuyển đổi về dạng sốthành số3. Vì vậy,x - 1sẽ bằng2.
`x = ""3""` `x - 1` `""3"" - 1` `""3""` `3` `x - 1` `2` Mà ta cóv = 0, nênv + 1bằng1vàv + 2bằng2. Suy ra, trường hợpcase v + 2thỏa mãn. Do đó,case 2được in ra.
`v = 0` `v + 1` `1` `v + 2` `2` `case v + 2` `case 2`"
518,Switch case trong Javascript,Nhóm cáccase,"`case` Hãy xem ví dụ sau:

```js
const n = 5;

switch (n) {
  case 3:
    console.log(""Hi!"");
    break;
  case 4:
    console.log(""Hello!"");
    break;
  case 5:
    console.log(""Hi!"");
    break;
  default:
    console.log(""Bye!"");
}

// Hi!
```
`const n = 5;

switch (n) {
  case 3:
    console.log(""Hi!"");
    break;
  case 4:
    console.log(""Hello!"");
    break;
  case 5:
    console.log(""Hi!"");
    break;
  default:
    console.log(""Bye!"");
}

// Hi!` Với đoạn code trên, bạn thấy rằngcase 3vàcase 5xử lý giống nhau.
`case 3` `case 5` Khi đó, thay vì viết tường minh như trên, bạn có thể gộp hai trường hợp này với nhau bằng cách bỏ qua từ khóabreak:
`break` 
```js
const n = 5;

switch (n) {
  case 4:
    console.log(""Hello!"");
    break;
  case 3:
  case 5:
    console.log(""Hi!"");
    break;
  default:
    console.log(""Bye!"");
}

// Hi!
```
`const n = 5;

switch (n) {
  case 4:
    console.log(""Hello!"");
    break;
  case 3:
  case 5:
    console.log(""Hi!"");
    break;
  default:
    console.log(""Bye!"");
}

// Hi!` Chạy thử với hai trường hợpn = 5vàn = 3, bạn sẽ thấy kết quả hiển thị giống nhau làHi!.
`n = 5` `n = 3` `Hi!` Vì khi bỏ qua từ khóabreak, toàn bộ khối lệnh bắt đầu từcasehợp lệ được thực hiện cho đến khi gặp từ khóabreakgần nhất hoặc kết thúc lệnh switch case.
`break` `case` `break`"
519,Switch case trong Javascript,Vấn đề so sánh bằng nghiêm ngặt,"Mình muốn nhấn mạnh rằng lệnh switch case sử dụngso sánh bằng nghiêm ngặt===. Nghĩa là các giá trịphải cùng kiểu dữ liệu.
`===` Ví dụ:

```js
let x = 3;

switch (x) {
  case ""3"":
    console.log(""string"");
    break;
  case 3:
    console.log(""number"");
    break;
  default:
    console.log(""unknown"");
    break;
}

// number
```
`let x = 3;

switch (x) {
  case ""3"":
    console.log(""string"");
    break;
  case 3:
    console.log(""number"");
    break;
  default:
    console.log(""unknown"");
    break;
}

// number`"
520,Switch case trong Javascript,Tổng kết,"Sau đây là những kiến thức cơ bản cần nhớ về lệnh switch case trong JavaScript:
`===` `case` `break` `default` `case` `break`"
521,Switch case trong Javascript,Thực hành,"Sử dụngif..elseđể viết đoạn code tương ứng với đoạn code sau:
`if..else` 
```js
let browser = ""Chrome"";

switch (browser) {
  case ""IE"":
    console.log(""Not support!"");
    break;
  case ""Chrome"":
  case ""Firefox"":
  case ""Safari"":
  case ""Edge"":
    console.log(""Support!"");
    break;
  default:
    console.log(""Unknown browser!"");
}

// Support!
```
`let browser = ""Chrome"";

switch (browser) {
  case ""IE"":
    console.log(""Not support!"");
    break;
  case ""Chrome"":
  case ""Firefox"":
  case ""Safari"":
  case ""Edge"":
    console.log(""Support!"");
    break;
  default:
    console.log(""Unknown browser!"");
}

// Support!` Xem đáp án

```js
let browser = ""Chrome"";

if (browser === ""IE"") {
  console.log(""Not support!"");
} else if (
  browser === ""Chrome"" ||
  browser === ""Firefox"" ||
  browser === ""Safari"" ||
  browser === ""Edge""
) {
  console.log(""Support!"");
} else {
  console.log(""Unknown browser!"");
}

// Support!
```
`let browser = ""Chrome"";

if (browser === ""IE"") {
  console.log(""Not support!"");
} else if (
  browser === ""Chrome"" ||
  browser === ""Firefox"" ||
  browser === ""Safari"" ||
  browser === ""Edge""
) {
  console.log(""Support!"");
} else {
  console.log(""Unknown browser!"");
}

// Support!` Mặc dù trông code có vẻ tương đương, nhưng theo mình thấy thì dùng lệnh switch case sẽdễ nhìn hơn."
522,Switch case trong Javascript,Bài 2,"Sử dụng lệnh switch case viết đoạn code tương ứng với đoạn code sau:

```js
let x = 2;

if (x === 1) {
  console.log(""x KHÔNG LÀ số nguyên tố"");
} else if (x === 2) {
  console.log(""x LÀ số nguyên tố"");
} else if (x === 3) {
  console.log(""x LÀ số nguyên tố"");
} else if (x === 4) {
  console.log(""x KHÔNG LÀ số nguyên tố"");
} else if (x === 5) {
  console.log(""x LÀ số nguyên tố"");
} else if (x === 6) {
  console.log(""x KHÔNG LÀ số nguyên tố"");
} else {
  console.log(""CHƯA RÕ!"");
}
```
`let x = 2;

if (x === 1) {
  console.log(""x KHÔNG LÀ số nguyên tố"");
} else if (x === 2) {
  console.log(""x LÀ số nguyên tố"");
} else if (x === 3) {
  console.log(""x LÀ số nguyên tố"");
} else if (x === 4) {
  console.log(""x KHÔNG LÀ số nguyên tố"");
} else if (x === 5) {
  console.log(""x LÀ số nguyên tố"");
} else if (x === 6) {
  console.log(""x KHÔNG LÀ số nguyên tố"");
} else {
  console.log(""CHƯA RÕ!"");
}` Xem đáp án
Bạn thấy rằng, có một vài trường hợp xử lý giống nhau. Nên mình có thể nhóm cáccaselại như sau:
`case` 
```js
let x = 2;

switch (x) {
  case 2:
  case 3:
  case 5:
    console.log(""x LÀ số nguyên tố"");
    break;
  case 1:
  case 4:
  case 6:
    console.log(""x KHÔNG LÀ số nguyên tố"");
    break;
  default:
    console.log(""CHƯA RÕ!"");
}
```
`let x = 2;

switch (x) {
  case 2:
  case 3:
  case 5:
    console.log(""x LÀ số nguyên tố"");
    break;
  case 1:
  case 4:
  case 6:
    console.log(""x KHÔNG LÀ số nguyên tố"");
    break;
  default:
    console.log(""CHƯA RÕ!"");
}`"
523,Symbol trong Javascript,Giới thiệu,"Symbol là một kiểu dữ liệu mới được giới thiệu từ phiên bản ES6. Tuy nhiên, mình cũng chưa từng dùng Symbol trong JavaScript bao giờ cả.
Nếu vậy thì người ta đưa ra kiểu dữ liệu này để làm gì? Symbol có ưu điểm gì? Ứng dụng của Symbol như thế nào? Cách sử dụng Symbol trong JavaScript ra sao?
Bài viết này, mình sẽ đi tìm lời giải cho những câu hỏi trên. Và nếu nó thật sự có ích thì chẳng tội gì mà mình không dùng nhỉ!"
524,Symbol trong Javascript,Symbol là gì?,"Symbol là một kiểu dữ liệu dạngprimitive data. Để tạo mới một Symbol, bạn có thể dùng hàmSymbol(), ví dụ:
`Symbol()` 
```js
let myId = Symbol();
```
`let myId = Symbol();` Hoặc bạn có thể thêmdescriptionđể miêu tả Symbol:

```js
let myId = Symbol(""id"");
```
`let myId = Symbol(""id"");` Chú ý:Symbolkhông có hàm khởi tạo. Do đó, bạn không thể dùng từ khoánewđể tạo mới một Symbol:
`new` 
```js
let myId = new Symbol(""id"");
// => Uncaught TypeError: Symbol is not a constructor
```
`let myId = new Symbol(""id"");
// => Uncaught TypeError: Symbol is not a constructor` Cơ bản về Symbol là vậy. Tiếp theo, mình sẽ tìm hiểu về một số đặc điểm, tính chất của nó nhé!"
525,Symbol trong Javascript,Một số đặc điểm của Symbol trong JavaScript,"Nghĩa là dù bạn có tạo ra bao nhiêu Symbol với cùng description thì chúng vẫn khác nhau:

```js
let myId1 = Symbol(""id"");
let myId2 = Symbol(""id"");

console.log(myId1 == myId2); // => false
console.log(myId1 === myId2); // => false
```
`let myId1 = Symbol(""id"");
let myId2 = Symbol(""id"");

console.log(myId1 == myId2); // => false
console.log(myId1 === myId2); // => false` Hầu hết các kiểu dữ liệu trong JavaScript đều hỗ trợtự động convertsangstring, nhưng Symbol thì không.
Ví dụ khi bạn sử dụng Symbol với phương thứcalert():
`alert()` 
```js
let a = true;
let b = [1, 2];
let c = { x: 1, y: 2 };
let d = Symbol();

alert(a); // => true
alert(b); // => 1,2
alert(c); // => [object Object]
alert(d); // => TypeError: Cannot convert a Symbol value to a string
```
`let a = true;
let b = [1, 2];
let c = { x: 1, y: 2 };
let d = Symbol();

alert(a); // => true
alert(b); // => 1,2
alert(c); // => [object Object]
alert(d); // => TypeError: Cannot convert a Symbol value to a string`"
526,Symbol trong Javascript,Sử dụng Global Symbol,"`Symbol.for` Như mình đã nói ở trên, Symbol là unique dù cho bạn có tạo ra nhiều Symbol với cùng description.
Tuy nhiên, nhiều khi mình muốn các description giống nhau sẽ ứng với một Symbol duy nhất. Lúc này, description có thể coi làkey.
Để làm được việc này, mình có thể sử dụng phương thứcSymbol.for(key). Phương thức này sẽ tìm trong một đối tượngGlobalnào đó, xem có tồn tại một Symbol tương ứng vớikeyhay không.
`Symbol.for(key)` Nếu chưa có Symbol nào thoả mãn thì JavaScript Engine sẽ tạo ra một Symbol mới được xác định bởikey. Ngược lại, nó sẽ trả về Symbol đó.

```js
// Tạo một Symbol mới với description là ""id""
let id1 = Symbol(""id"");

/*
 * Tìm trong Global một Symbol với key là ""id"".
 * Nếu Symbol chưa tồn tại thì tạo mới một Symbol
 */
let id2 = Symbol.for(""id"");

/*
 * Tiếp tục tìm trong Global một Symbol với key là ""id"".
 * Lần này thì Symbol đã tồn tại rồi, nên sẽ trả về Symbol trên.
 */
let id3 = Symbol.for(""id"");

// Kết quả
console.log(id1 === id2); // => false
console.log(id2 === id3); // => true
```
`// Tạo một Symbol mới với description là ""id""
let id1 = Symbol(""id"");

/*
 * Tìm trong Global một Symbol với key là ""id"".
 * Nếu Symbol chưa tồn tại thì tạo mới một Symbol
 */
let id2 = Symbol.for(""id"");

/*
 * Tiếp tục tìm trong Global một Symbol với key là ""id"".
 * Lần này thì Symbol đã tồn tại rồi, nên sẽ trả về Symbol trên.
 */
let id3 = Symbol.for(""id"");

// Kết quả
console.log(id1 === id2); // => false
console.log(id2 === id3); // => true` Việc sử dụngSymbol.fornhư thế này giúp Symbol có thể được sử dụng rộng rãi, nhiều nơi trong ứng dụng hơn.
`Symbol.for` `Symbol.keyFor` Ngược lại với phương thức trên, phương thứcSymbol.keyFor(symbol)sẽ trả về giá trịkeytương ứng vớisymbol.
`Symbol.keyFor(symbol)` `symbol` Tuy nhiên, phương thức này chỉ có tác dụng với Symbol được tạo ra từ phương thứcSymbol.for(key)bên trên.
`Symbol.for(key)` 
```js
let sym1 = Symbol(""id"");
let key1 = Symbol.keyFor(sym1);

let sym2 = Symbol.for(""name"");
let key2 = Symbol.keyFor(sym2);

console.log(""key1: "", key1); // => undefined
console.log(""key2: "", key2); // => name
```
`let sym1 = Symbol(""id"");
let key1 = Symbol.keyFor(sym1);

let sym2 = Symbol.for(""name"");
let key2 = Symbol.keyFor(sym2);

console.log(""key1: "", key1); // => undefined
console.log(""key2: "", key2); // => name`"
527,Symbol trong Javascript,Ứng dụng của Symbol,"Đối vớiobjectthì ngoài string, Symbol cũng có thể làm key cho thuộc tính của Object, ví dụ:

```js
const id = Symbol(""id"");
const obj = {
  [id]: ""abc123"",
};

console.log(obj);
// => {Symbol(id): ""abc123""}
```
`const id = Symbol(""id"");
const obj = {
  [id]: ""abc123"",
};

console.log(obj);
// => {Symbol(id): ""abc123""}` Tuy nhiên, thuộc tính với Symbol sẽ lànon-enumerable. Do đó, bạn không thể dùngfor...inđể duyệt nó.
`for...in` 
```js
const id = Symbol(""id"");
const obj = {
  [id]: ""abc123"",
  x: 1,
  y: 2,
};

console.log(obj);
// => {x: 1, y: 2, Symbol(id): ""abc123""}

for (let key in obj) {
  console.log(key);
}
/*
 * x
 * y
 */
```
`const id = Symbol(""id"");
const obj = {
  [id]: ""abc123"",
  x: 1,
  y: 2,
};

console.log(obj);
// => {x: 1, y: 2, Symbol(id): ""abc123""}

for (let key in obj) {
  console.log(key);
}
/*
 * x
 * y
 */` Để duyệt các thuộc tính với key là Symbol, bạn có thể sử dụng phương thứcObject.getOwnPropertySymbols(). Phương thức này trả về mảng của tất cả các thuộc tính có key là Symbol, ví dụ:
`Object.getOwnPropertySymbols()` 
```js
const id = Symbol(""id"");
const name = Symbol(""name"");

const obj = {
  [id]: ""abc123"",
  [name]: ""obj"",
  y: 2,
};

console.log(obj);
// => {y: 2, Symbol(id): ""abc123"", Symbol(name): ""obj""}

const arr = Object.getOwnPropertySymbols(obj);
console.log(arr);
// => [Symbol(id), Symbol(name)]
```
`const id = Symbol(""id"");
const name = Symbol(""name"");

const obj = {
  [id]: ""abc123"",
  [name]: ""obj"",
  y: 2,
};

console.log(obj);
// => {y: 2, Symbol(id): ""abc123"", Symbol(name): ""obj""}

const arr = Object.getOwnPropertySymbols(obj);
console.log(arr);
// => [Symbol(id), Symbol(name)]` Giả sử mình định nghĩa một module như là một object, với một key dạng string làid. Trườngidsẽ được sử dụng với mục đích nào đó bên trong module.
`id` `id` 
```js
// lib.js
let module = {
  id: ""abc"",
  printId: function () {
    console.log(""id in lib:"", this.id);
  },
};

export default module;
```
`// lib.js
let module = {
  id: ""abc"",
  printId: function () {
    console.log(""id in lib:"", this.id);
  },
};

export default module;` Khi một người khác sử dụng module của mình, do không biết nên người đó lại tiếp tục sử dụng thuộc tính với key làid. Dẫn đến giá trị củaidbị thay đổi.
`id` `id` Cuối cùng, các logic khác cũng bị thay đổi theo. Và đây là điều mà mình không mong muốn.

```js
// main.js
import module from ""./lib.js"";

module.id = ""123"";
module.printId();
// => id in lib: 123

console.log(""id in main:"", module.id);
// => id in main: 123
```
`// main.js
import module from ""./lib.js"";

module.id = ""123"";
module.printId();
// => id in lib: 123

console.log(""id in main:"", module.id);
// => id in main: 123` Nhưng nếu mình sử dụng ""id"" là Symbol thì sao?
Định nghĩa thư viện:

```js
// lib.js
let id = Symbol(""id"");

let module = {
  [id]: ""abc"",
  printId: function () {
    console.log(""id in lib:"", this[id]);
  },
};

export default module;
```
`// lib.js
let id = Symbol(""id"");

let module = {
  [id]: ""abc"",
  printId: function () {
    console.log(""id in lib:"", this[id]);
  },
};

export default module;` Sử dụng thư viện:

```js
// main.js
import module from ""./lib.js"";

let id = Symbol(""id"");
module[id] = ""123"";

module.printId();
// => id in lib: abc

console.log(""id in main:"", module[id]);
// => id in main: 123
```
`// main.js
import module from ""./lib.js"";

let id = Symbol(""id"");
module[id] = ""123"";

module.printId();
// => id in lib: abc

console.log(""id in main:"", module[id]);
// => id in main: 123` Rõ ràng, dù ởmain.jscó thay đổiidnhư nào thì hàmprintIdvẫn không hề thay đổi.
`id` `printId`"
528,Symbol trong Javascript,Tổng kết,"Sau đây là những kiến thức cơ bản cần nhớ về Symbol trong JavaScript:
`Symbol()` `Symbol.for(key)` Để biết thêm về các phương thức hỗ trợ của Symbol trong JavaScript, bạn có thể tham khảo các bài viết dưới đây:"
529,Tagged template ES6 trong Javascript,Giới thiệu,"Trong bài viết vềsử dụng ES6 Template String có gì hay, mình đã giới thiệu với bạn về ES6 Template String là gì, cũng như cách dùng và ứng dụng của nó.
https://user-images.githubusercontent.com/29374426/168242173-f4c90841-cb1f-4f3f-b978-286dbc7fbd1e.png
Tuy nhiên, có một tính năng mà mình chưa đề cập đến là:Tagged template. Sau đây, mình sẽ tìm hiểu xem rốt cuộc Tagged template ES6 là gì và sử dụng Tagged template như thế nào nhé."
530,Tagged template ES6 trong Javascript,Cơ bản về Tagged template ES6,"Cú pháp về Tagged template:

```js
func`template string with ${expression}`;
```
`func`template string with ${expression}`;` Tagged template ES6 cho phép bạnxử lý template stringvới mộthàm.
Trong đó,funcchính là function mà bạn tự định nghĩa. Tiếp sau là một đoạn template string có thể chứa một hoặc nhiềuexpression(biểu thức).
`func` `expression` Ở đây,funcnhận tham số đầu tiên làmảngcác string (sử dụng trong template string). Các tham số tiếp theo là các biểu thức trong template string.
`func` Kết quả trả về của Tagged template là kết quả của hàmfunc. Đó có thể là bất cứ kiểu dữ liệu nào tùy thích. Chứ không phải luôn luôn là string!
`func` Đọc đến đây có thể bạn vẫn chưa hiểu được cách sử dụng của Tagged template ES6. Do đó, mình sẽ tìm hiểu nó qua một ví dụ cụ thể phía dưới."
531,Tagged template ES6 trong Javascript,Ví dụ sử dụng Tagged template ES6,"Xem xét đoạn code sau:

```js
// func
const math = ([x, y], op) => op(Number(x), Number(y));

// expression
const plus = (x, y) => x + y;

// tagged template string
const result = math`6 ${plus} 3`;

// kết quả
console.log(result); // 9
```
`// func
const math = ([x, y], op) => op(Number(x), Number(y));

// expression
const plus = (x, y) => x + y;

// tagged template string
const result = math`6 ${plus} 3`;

// kết quả
console.log(result); // 9` Trong đó:
`func` `math` `expression` `plus` `6 ${plus} 3` Đối với hàmmath(), tham số đầu tiên làmảng của các stringđược sử dụng trong template string.
`math()` Do đó, mảng này gồm 2 phần tử là:['6 ', ' 3'](chú ý sự tồn tại của dấu cách trong các string nhé).
`['6 ', ' 3']` Tham số tiếp theo của hàmmath()chính là hàmplus().
`math()` Như vậy, bên trong hàmmath():
`math()` 
```js
x = '6 ' => Number(x) = 6
y = ' 3' => Number(y) = 3
op = plus

=> op(Number(x), Number(y)) = plus(6, 3) = 9
```
`x = '6 ' => Number(x) = 6
y = ' 3' => Number(y) = 3
op = plus

=> op(Number(x), Number(y)) = plus(6, 3) = 9` Cuối cùng kết quả của biếnresultbằng9.
`result` `9` Có lẽ bạn đã phần nào mường tượng ra cách sử dụng của Tagged template ES6 rồi. Tuy nhiên, mình tiếp tục nghiên cứu thêm một ví dụ nữa để hiểu hơn về nó."
532,Tagged template ES6 trong Javascript,Ví dụ khác của Tagged template ES6,"Giả sử trường hợp template string với expressionở đầu hoặc/và ở cuối:

```js
// func
const func = (arr, expr1, expr2) => {
  console.log(arr); // (1)
  console.log(expr1, expr2); // (2)
  return { x: ""1"" };
};

// expression
const a = 1;
const b = 2;

// tagged template
const result = func`${a} and then ${b}`;

// kết quả
console.log(result); // (3)

// (1) - mảng các string: ["""", "" and then "", """"]
// (2) - các expression: 1 2
// (3) - kết quả: { x: ""1"" }
```
`// func
const func = (arr, expr1, expr2) => {
  console.log(arr); // (1)
  console.log(expr1, expr2); // (2)
  return { x: ""1"" };
};

// expression
const a = 1;
const b = 2;

// tagged template
const result = func`${a} and then ${b}`;

// kết quả
console.log(result); // (3)

// (1) - mảng các string: ["""", "" and then "", """"]
// (2) - các expression: 1 2
// (3) - kết quả: { x: ""1"" }` Đây chỉ là một ví dụ để minh họa. Và qua ví dụ này, bạn biết thêm một số vấn đề về tagged template như sau:"
533,Tagged template ES6 trong Javascript,Tổng kết,"Trên đây là một số ví dụ cơ bản giúp bạn hiểu về Tagged template ES6.
Vậy theo bạn, ứng dụng thực tế của Tagged template ES6 là gì? Chia sẻ quan điểm của bạn trong phần bình luận phía dưới nhé!"
534,This trong Javascript,Giới thiệu,"Trong bài viết này, mình sẽ bạn sẽ tìm hiểu về giá trịthistrong JavaScript và hiểu nó rõ ràng trong các ngữ cảnh khác nhau.
`this` thischính là bối cảnh(context) của nơi mà hàm chứa từ this được gọi. Bạn hãy nhớ từthistham chiếu tới cái vùng không gian mà hàm chứa từthisđược gọi. Chỉ có 2 loại context đối vớithislàobjectchứa method được gọi hoặc global , ngoài ra không có loại khác. Khi gặp từthis, chỉ quan tâm tới cái nơi gọi hàm chứa nó chứ không được dịchthislà nội hàm hiện tại.
`this` `this` `this` `this` `object` `this` `this`"
535,This trong Javascript,this trong ngữ cảnh toàn cục,"Trong ngữ cảnh toàn cục (global context),thistham chiếu đến đối tượng toàn cục, là đối tượngwindowtrên trình duyệt web hoặc đối tượng global trên Node.js.
`this` `window` Hành vi này nhất quán cho dù chế độ nghiêm ngặt có được áp dụng hay không, ví dụ thử gọi câu lệnh này trong phạm vi cao nhất:

```js
console.log(this === window); // true
```
`console.log(this === window); // true` Nếu bạn gán một thuộc tính cho đối tượngthistrong ngữ cảnh toàn cục, JavaScript sẽ thêm thuộc tính vào đối tượng toàn cục như trong ví dụ sau:
`this` 
```js
this.color = ""Red"";
console.log(window.color); // 'Red'
```
`this.color = ""Red"";
console.log(window.color); // 'Red'`"
536,This trong Javascript,this trong ngữ cảnh hàm,"Trong JavaScript, bạn có thể gọi một hàm theo những cách sau:
Mỗi lời gọi hàm xác định ngữ cảnh riêng của nó, do đó, this có thể hoạt động khác với những gì bạn nghĩ
Trong chế độ không nghiêm ngặt (non-strict mode),thistham chiếu đến đối tượng toàn cục khi hàm được gọi như sau:
`this` 
```js
function run() {
  console.log(this === window); // true
}

run();
```
`function run() {
  console.log(this === window); // true
}

run();` Khi bạn gọi hàmrun(), this tham chiếu đến đối tượng toàn cục, là đối tượngwindowtrên trình duyệt web và là đối tượng global trên Node.js.
`run()` `window` Do đó, lệnh gọi hàmrun()ở trên cũng tương đương như sau:
`run()` 
```js
window.run();
```
`window.run();` Trong chế độ nghiêm ngặt (strict mode), để hạn chế hành vi không rõ ràng, lời gọi hàm như vậy sẽ được JavaScript đặt giá trị this thànhundefined.
`undefined` Ví dụ:

```js
""use strict""; // Khai báo strict mode

function run() {
  console.log(this === undefined); // true
}

run();
```
`""use strict""; // Khai báo strict mode

function run() {
  console.log(this === undefined); // true
}

run();` Lưu ý
Khi bạn gọi một phương thức của một đối tượng, JavaScript sẽ đặtthischo đối tượng sở hữu phương thức.
`this` Xem đối tượng person sau:

```js
let person = {
  name: ""Thaycacac"",
  getName: function () {
    return this.name;
  },
};

console.log(person.getName()); // Thaycacac
```
`let person = {
  name: ""Thaycacac"",
  getName: function () {
    return this.name;
  },
};

console.log(person.getName()); // Thaycacac` Trong ví dụ này, đối tượngthistrong phương thứcgetName()tham chiếu đến đối tượngperson.
`this` `getName()` `person` Và vì một phương thức là thuộc tính của một đối tượng, cũng là một giá trị, thế nên bạn có thể lưu trữ nó trong một biến như thế này:

```js
const name = person.getBrand;
```
`const name = person.getBrand;` Và sau đó, gọi phương thức thông qua biến rất bình thường như sau:

```js
console.log(brand()); // undefined
```
`console.log(brand()); // undefined` Kết quả, bạn nhận đượcundefinedthay vìThaycacacnhư mong đợi
`undefined` `Thaycacac` Bởi vì, khi bạn gọi một phương thức mà không chỉ định đối tượng của nó, JavaScript sẽ đặtthisthành đối tượng toàn cục ở chế độ không nghiêm ngặt vàundefinedtrong chế độ nghiêm ngặt.
`this` `undefined` Để xử lý tình huống này, bạn có thể sử dụng phương thứcbind()mình sẽ đề cập ở bài khác. Bạn có thể xem ví dụ giới đây để có thể biết cách xử lý
`bind()` 
```js
let name = person.getName.bind(person);
console.log(name()); // Thaycacac
```
`let name = person.getName.bind(person);
console.log(name()); // Thaycacac` Trong ví dụ trên, khi bạn gọi phương thứcname(), từ khóathisđược liên kết với đối tượngpersonbởibind()
`name()` `this` `person` `bind()` Khi bạn sử dụng từ khóanewđể tạo một thể hiện của một đối tượng hàm, bạn sử dụng hàm như một phương thức khởi tạo (constructor).
`new` Ví dụ sau khai báo một hàmPerson, sau đó gọi nó như một hàm tạo:
`Person` 
```js
function Person(name) {
  this.name = name;
}

Person.prototype.getName = function () {
  return this.name;
};

var name = new Person(""Thaycacac"");
console.log(name.getName());
```
`function Person(name) {
  this.name = name;
}

Person.prototype.getName = function () {
  return this.name;
};

var name = new Person(""Thaycacac"");
console.log(name.getName());` Biểu thứcnew Person('Thaycacac')là một lệnh gọi hàm tạo của hàmPerson.
`new Person('Thaycacac')` `Person` JavaScript tạo một đối tượng mới và đặt đối tượngthisthành đối tượng mới được tạo (Cách này hoạt động tốt nhưng có một vấn đề tiềm ẩn)
`this` Bây giờ, bạn có thể gọiPerson()dưới dạng một hàm hoặc như một phương thức khởi tạo.
`Person()` 
```js
var girl = Person(""Huyen"");
console.log(girl.name);
// TypeError: Cannot read property 'name' of undefined
```
`var girl = Person(""Huyen"");
console.log(girl.name);
// TypeError: Cannot read property 'name' of undefined` Vì giá trịthistrongPerson()được đặt thành đối tượng toàn cục, do đógirl.nametrả về không xác định.
`this` `Person()` `girl.name` Để đảm bảo rằng hàmPerson()luôn được gọi bằng cách gọi hàm tạo, bạn thêm kiểm tra vào đầu hàmPerson()như sau:
`Person()` `Person()` 
```js
function Person(name) {
  if (!(this instanceof Person)) {
    throw Error(""Phải sử dụng từ khóa new"");
  }
  this.name = name;
}
```
`function Person(name) {
  if (!(this instanceof Person)) {
    throw Error(""Phải sử dụng từ khóa new"");
  }
  this.name = name;
}` ES6 đã giới thiệu một thuộc tính meta có tênnew.targetcho phép bạn phát hiện xem một hàm được gọi như một lời gọi hàm đơn giản hay như một hàm tạo.
`new.target` Bạn có thể sửa đổi hàmPerson()sử dụngnew.targetnhư sau:
`Person()` `new.target` 
```js
function Person(name) {
  if (!new.target) {
    throw Error(""Phải sử dụng từ khóa new"");
  }
  this.name = name;
}
```
`function Person(name) {
  if (!new.target) {
    throw Error(""Phải sử dụng từ khóa new"");
  }
  this.name = name;
}` Trong JavaScript, các hàm là first-class citizens. Nói cách khác, các hàm là các đối tượng, là các thể hiện của kiểuFunction.
`Function` Kiểu Function có hai phương thức:call()vàapply(). Các phương thức này cho phép bạn đặt giá trịthiskhi gọi một hàm. Phần này chúng ta sẽ tìm hiểu ở bài bind, call, aplly
`call()` `apply()` `this`"
537,This trong Javascript,this trong Arrow Function,"ES6 đã giới thiệu một khái niệm mới có tên là Arrow Function, bạn cũng có thể gọi đếnthistrong đó.
`this` Tuy nhiên, arrow function không tạo bối cảnh thực thi của riêng nó, mà kế thừathistừ hàm bên ngoài nơi arrow function được định nghĩa.
`this` Ví dụ:

```js
let getThis = () => this;
console.log(getThis() === window); // true
```
`let getThis = () => this;
console.log(getThis() === window); // true` Trong ví dụ này, giá trịthisđược đặt thành đối tượng toàn cục, tức làwindowtrong trình duyệt web.
`this` `window` Và vì một hàm mũi tên không tạo ngữ cảnh thực thi của riêng nó, nên việc xác định một phương thức bằng arrow function sẽ gây ra sự cố.

```js
function Person() {
  this.name = ""Thaycacac"";
}

// Thêm vào đối tượng Person một hàm
// bằng arrow function
Person.prototype.getName = () => {
  return this.name;
};

var person = new Person();
person.getName(); // TypeError
```
`function Person() {
  this.name = ""Thaycacac"";
}

// Thêm vào đối tượng Person một hàm
// bằng arrow function
Person.prototype.getName = () => {
  return this.name;
};

var person = new Person();
person.getName(); // TypeError` Bên trong phương thứcgetName(), giá trịthistham chiếu đến đối tượng toàn cục, không phải đối tượng Person.
`getName()` `this` Do đó, lời gọiperson.getName()gây ra lỗi vì đối tượng toàn cục không có thuộc tínhname.
`person.getName()` `name`"
538,This trong Javascript,this trong callback của hàm setTimeout,"thistrong hàm ẩn danh(anonymous function) luôn là global.
`this` Không thể tham chiếu tới chính function trong callback của hàmsetTimeoutvì nó là anonymous function.
`setTimeout` Ví dụ:

```js
var a = 10;
setTimeout(function () {
  // anonymous function (no name)
  var a = 20;
  console.log(this.a); // 10
}, 1000);
```
`var a = 10;
setTimeout(function () {
  // anonymous function (no name)
  var a = 20;
  console.log(this.a); // 10
}, 1000);`"
539,This trong Javascript,this trong DOM event handler,"```js
<button onclick=""console.log(this)"">Click me</button>
```
`<button onclick=""console.log(this)"">Click me</button>` thiskhi event được trigger chính làbuttonchứa event đó. Nhưng nếu bạn khai báo một hàm trong event handler thìthissẽ làglobal(window trong browser) vìthisđã nằm trong hàm ẩn danh.
`this` `button` `this` `global` `this` 
```js
<button onclick=""console.log(myFunction())"">Click me</button>

<script>
  function myFunction() {
    return this;
  }
</script>
```
`<button onclick=""console.log(myFunction())"">Click me</button>

<script>
  function myFunction() {
    return this;
  }
</script>` hoặc

```js
<button onclick=""console.log((function(){return this})());"">Click me</button>
```
`<button onclick=""console.log((function(){return this})());"">Click me</button>`"
540,Thuật toán cơ bản trong Javascript,Giới thiệu,"Trong lập trình nói chung và lập trình JavaScript nói riêng, việc học thuật toán vẫn luôn vô cùng quan trọng. Thuật toán giúp cho lập trình viên rèn luyện tư duy.
Ngoài ra, khi thuật toán tốt thì chương trình viết ra sẽ chạy nhanh hơn, hoặc trông sẽ sáng sủa, dễ hiểu và dễ bảo trì hơn.
Bôm nay, mình sẽ tổng hợp lại những bài toán thuộc chủ đềBasic Algorithm Scriptingtrên freeCodeCamp để các bạn tiện theo dõi và có thể tham khảo khi cần.
Tuy nhiên, những bài toán này khá đơn giản nên mình sẽ không giải thích cách làm. Nếu các bạn có thắc mắc hay góp ý thì có thể để lại ở phần bình luận phía dưới.
Trước khi đi vào tìm hiểu các bài toán, các bạn có thể đọc trước các bài viết sau. Chúng khá hữu ích vì các thuật toán sau đây sẽ sử dụng đến những kiến thức trong đó."
541,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Reverse a String,"Cho một string, nhiệm vụ của bạn là phải đảo ngược lại string đó. Ví dụ:Hello=>olleH.

```js
function reverseString(str) {
  return str.split("""").reverse().join("""");
}

reverseString(""hello"");
```
`function reverseString(str) {
  return str.split("""").reverse().join("""");
}

reverseString(""hello"");` Tham khảo:"
542,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Factorialize a Number,"Tính giai thừa của một số tự nhiên n!. Ví dụ:5! = 5 * 4 * 3 * 2 * 1.

```js
function factorialize(num) {
  if (num == 0) return 1;

  for (var i = num - 1; i >= 1; i--) num *= i;

  return num;
}

factorialize(5);
```
`function factorialize(num) {
  if (num == 0) return 1;

  for (var i = num - 1; i >= 1; i--) num *= i;

  return num;
}

factorialize(5);` Tham khảo:"
543,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Check for Palindromes,"Kiểm tra xem một string có phải làpalindromehay không? (Một string được gọi làpalindromekhi và chỉ khi đọc ngược và đọc xuôi đều giống nhau, với điều kiện bỏ qua các dấu câu, kí tự đặc biệt, dấu cách). Ví dụ:boob, eye,...

```js
function palindrome(str) {
  var newStr = str.replace(/[^a-zA-Z0-9]/g, """").toLowerCase();
  var newStrReverse = newStr.split("""").reverse().join("""");
  return newStr === newStrReverse;
}

palindrome(""eye"");
```
`function palindrome(str) {
  var newStr = str.replace(/[^a-zA-Z0-9]/g, """").toLowerCase();
  var newStrReverse = newStr.split("""").reverse().join("""");
  return newStr === newStrReverse;
}

palindrome(""eye"");` Tham khảo:"
544,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Find the Longest Word in a String,"Tìm độ dài của từ dài nhất trong câu.

```js
function findLongestWord(str) {
  var words = str.split("" "");
  var maxLength = words.reduce(function (acc, cur) {
    return cur.length > acc ? cur.length : acc;
  }, 0);
  return maxLength;
}

findLongestWord(""The quick brown fox jumped over the lazy dog"");
```
`function findLongestWord(str) {
  var words = str.split("" "");
  var maxLength = words.reduce(function (acc, cur) {
    return cur.length > acc ? cur.length : acc;
  }, 0);
  return maxLength;
}

findLongestWord(""The quick brown fox jumped over the lazy dog"");` Tham khảo:"
545,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Title Case a Sentence,"Trả về string với các từ có chữ cái đầu tiên viết hoa. Ví dụ:I'm a little tea pot=>I'm A Little Tea Pot.

```js
function titleCase(str) {
  var words = str.split("" "");

  var newWords = words.map(function (word) {
    var chars = word.split("""");

    chars[0] = chars[0].toUpperCase();
    for (var i = 1; i < chars.length; i++) {
      chars[i] = chars[i].toLowerCase();
    }

    return chars.join("""");
  });

  return newWords.join("" "");
}

titleCase(""I'm a little tea pot"");
```
`function titleCase(str) {
  var words = str.split("" "");

  var newWords = words.map(function (word) {
    var chars = word.split("""");

    chars[0] = chars[0].toUpperCase();
    for (var i = 1; i < chars.length; i++) {
      chars[i] = chars[i].toLowerCase();
    }

    return chars.join("""");
  });

  return newWords.join("" "");
}

titleCase(""I'm a little tea pot"");` Tham khảo:"
546,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Return Largest Numbers in Arrays,"Trả về một mảng gồm các số lớn nhất của mỗi sub-array.

```js
function largestOfFour(arr) {
  var answer = [];
  for (var i = 0; i < arr.length; i++) {
    var max = 0;
    for (var j = 0; j < arr[i].length; j++) {
      if (arr[i][j] > max) max = arr[i][j];
    }
    answer.push(max);
  }
  return answer;
}

largestOfFour([
  [4, 5, 1, 3],
  [13, 27, 18, 26],
  [32, 35, 37, 39],
  [1000, 1001, 857, 1],
]);
```
`function largestOfFour(arr) {
  var answer = [];
  for (var i = 0; i < arr.length; i++) {
    var max = 0;
    for (var j = 0; j < arr[i].length; j++) {
      if (arr[i][j] > max) max = arr[i][j];
    }
    answer.push(max);
  }
  return answer;
}

largestOfFour([
  [4, 5, 1, 3],
  [13, 27, 18, 26],
  [32, 35, 37, 39],
  [1000, 1001, 857, 1],
]);` Tham khảo:"
547,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Confirm the Ending,"Kiểm tra xem một string có được kết thúc bởi một string khác.

```js
function confirmEnding(str, target) {
  return target === str.substr(-target.length);
}

confirmEnding(""Bastian"", ""n"");
```
`function confirmEnding(str, target) {
  return target === str.substr(-target.length);
}

confirmEnding(""Bastian"", ""n"");` Tham khảo:"
548,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Repeat a string repeat a string,"Lặp lại string với số lần cho trước.

```js
function repeatStringNumTimes(str, num) {
  var answer = """";
  for (var i = 0; i < num; i++) answer += str;
  return answer;
}

repeatStringNumTimes(""abc"", 3);
```
`function repeatStringNumTimes(str, num) {
  var answer = """";
  for (var i = 0; i < num; i++) answer += str;
  return answer;
}

repeatStringNumTimes(""abc"", 3);` Tham khảo:"
549,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Truncate a string,"Rút gọn string nếu nó dài quá n kí tự.

```js
function truncateString(str, num) {
  if (str.length <= num) return str;
  if (num <= 3) return str.slice(0, num) + ""..."";
  return str.slice(0, num - 3) + ""..."";
}

truncateString(""A-tisket a-tasket A green and yellow basket"", 11);
```
`function truncateString(str, num) {
  if (str.length <= num) return str;
  if (num <= 3) return str.slice(0, num) + ""..."";
  return str.slice(0, num - 3) + ""..."";
}

truncateString(""A-tisket a-tasket A green and yellow basket"", 11);` Tham khảo:"
550,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Chunky Monkey,"Chia mảng thành các phần với độ dài n cho trước.

```js
function chunkArrayInGroups(arr, size) {
  var answer = [];
  for (var i = 0; i < arr.length; i += size) {
    answer.push(arr.slice(i, i + size));
  }
  return answer;
}

chunkArrayInGroups([""a"", ""b"", ""c"", ""d""], 2);
```
`function chunkArrayInGroups(arr, size) {
  var answer = [];
  for (var i = 0; i < arr.length; i += size) {
    answer.push(arr.slice(i, i + size));
  }
  return answer;
}

chunkArrayInGroups([""a"", ""b"", ""c"", ""d""], 2);` Tham khảo:"
551,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Slasher Flick,"Trả về những phần tử của mảng sau khi đã cắt đi n phần tử đầu tiên.

```js
function slasher(arr, howMany) {
  arr.splice(0, howMany);
  return arr;
}

slasher([1, 2, 3], 2);
```
`function slasher(arr, howMany) {
  arr.splice(0, howMany);
  return arr;
}

slasher([1, 2, 3], 2);` Tham khảo:"
552,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Mutations,"Kiểm tra xem trong 1 string có chứa tất cả các kí tự của string thứ 2 hay không.

```js
function mutation(arr) {
  arr[0] = arr[0].toLowerCase();
  arr[1] = arr[1].toLowerCase();
  for (var i = 0; i < arr[1].length; i++) {
    if (arr[0].indexOf(arr[1][i]) < 0) return false;
  }
  return true;
}

mutation([""hello"", ""hey""]);
```
`function mutation(arr) {
  arr[0] = arr[0].toLowerCase();
  arr[1] = arr[1].toLowerCase();
  for (var i = 0; i < arr[1].length; i++) {
    if (arr[0].indexOf(arr[1][i]) < 0) return false;
  }
  return true;
}

mutation([""hello"", ""hey""]);` Tham khảo:"
553,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Falsy Bouncer,"Bỏ đi tất cả các giá trịfalsykhỏi một mảng (giá trịfalsylà false, null, 0, """", undefined và NaN).

```js
function bouncer(arr) {
  var answer = arr.filter(function (val) {
    return (
      (typeof val == ""string"" && val != """") ||
      (val != false &&
        val != null &&
        val != 0 &&
        val != undefined &&
        !isNaN(val))
    );
  });
  return answer;
}

bouncer([7, ""ate"", """", false, 9]);
```
`function bouncer(arr) {
  var answer = arr.filter(function (val) {
    return (
      (typeof val == ""string"" && val != """") ||
      (val != false &&
        val != null &&
        val != 0 &&
        val != undefined &&
        !isNaN(val))
    );
  });
  return answer;
}

bouncer([7, ""ate"", """", false, 9]);` Tham khảo:"
554,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Seek and Destroy,"Bỏ đi tất cả các phần tử của mảng giống với tập cho trước.

```js
function destroyer(arr) {
  var args = arguments;
  var answer = arr.filter(function (val) {
    for (var i = 1; i < args.length; i++) {
      if (val === args[i]) return false;
    }
    return true;
  });
  return answer;
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);
```
`function destroyer(arr) {
  var args = arguments;
  var answer = arr.filter(function (val) {
    for (var i = 1; i < args.length; i++) {
      if (val === args[i]) return false;
    }
    return true;
  });
  return answer;
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);` Tham khảo:"
555,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Where do I belong,"Tìm ra vị trí có chỉ số nhỏ nhất phù hợp để chèn một số cho trước vào.

```js
function getIndexToIns(arr, num) {
  var newArr = arr.sort(function (a, b) {
    return a - b;
  });
  var index = 0;
  while (true) {
    if (index == newArr.length || newArr[index] >= num) return index;
    index++;
  }
}

getIndexToIns([40, 60], 50);
```
`function getIndexToIns(arr, num) {
  var newArr = arr.sort(function (a, b) {
    return a - b;
  });
  var index = 0;
  while (true) {
    if (index == newArr.length || newArr[index] >= num) return index;
    index++;
  }
}

getIndexToIns([40, 60], 50);` Tham khảo:"
556,Thuật toán cơ bản trong Javascript,Basic Algorithm Scripting - Caesars Cipher,"Giải mã string cho trước sử dụngROT13.

```js
function rot13(str) {
  // LBH QVQ VG!
  var arr = str.split("""");
  var code, delta;
  for (var i = 0; i < arr.length; i++) {
    code = arr[i].charCodeAt(0) - 13;

    if (arr[i] >= ""A"" && arr[i] < ""N"") {
      delta = ""A"".charCodeAt(0) - code;
      code = ""Z"".charCodeAt(0) - delta + 1;
      arr[i] = String.fromCharCode(code);
    } else if (arr[i] >= ""N"" && arr[i] <= ""Z"") {
      arr[i] = String.fromCharCode(code);
    }
  }
  return arr.join("""");
}

// Change the inputs below to test
rot13(""SERR PBQR PNZC"");
```
`function rot13(str) {
  // LBH QVQ VG!
  var arr = str.split("""");
  var code, delta;
  for (var i = 0; i < arr.length; i++) {
    code = arr[i].charCodeAt(0) - 13;

    if (arr[i] >= ""A"" && arr[i] < ""N"") {
      delta = ""A"".charCodeAt(0) - code;
      code = ""Z"".charCodeAt(0) - delta + 1;
      arr[i] = String.fromCharCode(code);
    } else if (arr[i] >= ""N"" && arr[i] <= ""Z"") {
      arr[i] = String.fromCharCode(code);
    }
  }
  return arr.join("""");
}

// Change the inputs below to test
rot13(""SERR PBQR PNZC"");` Tham khảo:"
557,Thuật toán cơ bản trong Javascript,Kết luận,"Trên đây là tổng hợp các bài toán thuộc chủ đềBasic Algorithm Scriptingtrên freeCodeCamp. Theo cá nhân mình thấy thì các bài toán trên khá dễ. Nhưng lại rất hay ở chỗ, nó giúp ta áp dụng được kiến thức lý thuyết. Nếu các bạn có gì thắc mắc, góp ý hay cải tiến các thuật toán trên. Vui lòng để lại bình luận phía dưới nhé."
558,Thuật toán nâng cao trong Javascript,Giới thiệu,"Bài viết trước mình đã chia sẻ với bạn các bài toán thuộc chủ đềBasic Algorithm Scripting. Nếu bạn đã đọc qua thì có thể thấy rằng, đó đều là những bài toán khá dễ. Ngược lại, các bài toán hôm nay sẽ khó hơn một chút. Vì chúng thuộc chủ đềIntermediate Algorithm Scripting."
559,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Sum All Numbers in a Range,"Tính tổng các số trong một khoảng cho trước.

```js
function sumAll(arr) {
  var min = Math.min(arr[0], arr[1]);
  var max = Math.max(arr[0], arr[1]);
  var ans = 0;
  for (var i = min; i <= max; i++) {
    ans += i;
  }
  return ans;
}

sumAll([1, 4]);
```
`function sumAll(arr) {
  var min = Math.min(arr[0], arr[1]);
  var max = Math.max(arr[0], arr[1]);
  var ans = 0;
  for (var i = min; i <= max; i++) {
    ans += i;
  }
  return ans;
}

sumAll([1, 4]);` Tham khảo:"
560,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Diff Two Arrays,"Kiểm tra hai mảng cho trước và trả về mảng mới chứa những phần tử thuộc chỉ một trong hai mảng đó.

```js
function diffArray(arr1, arr2) {
  function isExist(item, arr) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === item) return true;
    }
    return false;
  }

  var newArr = [];
  arr1.forEach(function (val) {
    if (!isExist(val, arr2)) newArr.push(val);
  });
  arr2.forEach(function (val) {
    if (!isExist(val, arr1)) newArr.push(val);
  });
  return newArr;
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);
```
`function diffArray(arr1, arr2) {
  function isExist(item, arr) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === item) return true;
    }
    return false;
  }

  var newArr = [];
  arr1.forEach(function (val) {
    if (!isExist(val, arr2)) newArr.push(val);
  });
  arr2.forEach(function (val) {
    if (!isExist(val, arr1)) newArr.push(val);
  });
  return newArr;
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);` Tham khảo:"
561,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Roman Numeral Converter,"Convert số cho trước sang số La Mã.

```js
function convertToRoman(num) {
  var table = {
    1000: ""M"",
    900: ""CM"",
    500: ""D"",
    400: ""CD"",
    100: ""C"",
    90: ""XC"",
    50: ""L"",
    40: ""XL"",
    10: ""X"",
    9: ""IX"",
    5: ""V"",
    4: ""IV"",
    1: ""I"",
  };

  var keys = Object.keys(table).sort(function (a, b) {
    return b - a;
  });

  var ans = """";
  keys.forEach(function (key) {
    while (num >= key) {
      ans += table[key];
      num -= key;
    }
  });
  return ans;
}

convertToRoman(36);
```
`function convertToRoman(num) {
  var table = {
    1000: ""M"",
    900: ""CM"",
    500: ""D"",
    400: ""CD"",
    100: ""C"",
    90: ""XC"",
    50: ""L"",
    40: ""XL"",
    10: ""X"",
    9: ""IX"",
    5: ""V"",
    4: ""IV"",
    1: ""I"",
  };

  var keys = Object.keys(table).sort(function (a, b) {
    return b - a;
  });

  var ans = """";
  keys.forEach(function (key) {
    while (num >= key) {
      ans += table[key];
      num -= key;
    }
  });
  return ans;
}

convertToRoman(36);` Tham khảo:"
562,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Wherefore art thou,"Duyệt mảng của cácobjectvà trả về một mảng bao gồm các object chứa thuộc tính trùng khớp với thành phần cho trước.

```js
function whatIsInAName(collection, source) {
  var arr = [];
  collection.forEach(function (item) {
    for (var key in source) {
      if (!item.hasOwnProperty(key) || item[key] !== source[key]) return;
    }
    arr.push(item);
  });
  return arr;
}

whatIsInAName(
  [
    { first: ""Romeo"", last: ""Montague"" },
    { first: ""Mercutio"", last: null },
    { first: ""Tybalt"", last: ""Capulet"" },
  ],
  { last: ""Capulet"" }
);
```
`function whatIsInAName(collection, source) {
  var arr = [];
  collection.forEach(function (item) {
    for (var key in source) {
      if (!item.hasOwnProperty(key) || item[key] !== source[key]) return;
    }
    arr.push(item);
  });
  return arr;
}

whatIsInAName(
  [
    { first: ""Romeo"", last: ""Montague"" },
    { first: ""Mercutio"", last: null },
    { first: ""Tybalt"", last: ""Capulet"" },
  ],
  { last: ""Capulet"" }
);` Tham khảo:"
563,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Search and Replace,"Thực hiện tìm và thay thế trên một string sử dụng tham số cho trước, sau đó trả về một string mới.

```js
function myReplace(str, before, after) {
  var beforeFirst = before.charAt(0);
  var afterChars = after.split("""");

  var answer = [];
  var words = str.split("" "");
  words.forEach(function (word) {
    if (word === before) {
      if (beforeFirst >= ""A"" && beforeFirst <= ""Z"") {
        afterChars[0] = afterChars[0].toUpperCase();
      } else if (beforeFirst >= ""a"" && beforeFirst <= ""z"") {
        afterChars[0] = afterChars[0].toLowerCase();
      }
      answer.push(afterChars.join(""""));
    } else {
      answer.push(word);
    }
  });
  return answer.join("" "");
}

myReplace(""A quick brown fox jumped over the lazy dog"", ""jumped"", ""leaped"");
```
`function myReplace(str, before, after) {
  var beforeFirst = before.charAt(0);
  var afterChars = after.split("""");

  var answer = [];
  var words = str.split("" "");
  words.forEach(function (word) {
    if (word === before) {
      if (beforeFirst >= ""A"" && beforeFirst <= ""Z"") {
        afterChars[0] = afterChars[0].toUpperCase();
      } else if (beforeFirst >= ""a"" && beforeFirst <= ""z"") {
        afterChars[0] = afterChars[0].toLowerCase();
      }
      answer.push(afterChars.join(""""));
    } else {
      answer.push(word);
    }
  });
  return answer.join("" "");
}

myReplace(""A quick brown fox jumped over the lazy dog"", ""jumped"", ""leaped"");` Tham khảo:"
564,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Pig Latin,"Dịch string cho trước sang ngôn ngữLatin Lợn.

```js
function translatePigLatin(str) {
  var firstVowel = str.search(/[ueoai]/);
  if (firstVowel > 0) {
    var firstConsonant = str.substr(0, firstVowel);
    var others = str.substr(firstVowel);
    return others + firstConsonant + ""ay"";
  }
  return str + ""way"";
}

translatePigLatin(""consonant"");
```
`function translatePigLatin(str) {
  var firstVowel = str.search(/[ueoai]/);
  if (firstVowel > 0) {
    var firstConsonant = str.substr(0, firstVowel);
    var others = str.substr(firstVowel);
    return others + firstConsonant + ""ay"";
  }
  return str + ""way"";
}

translatePigLatin(""consonant"");` Tham khảo:"
565,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - DNA Pairing,"Các DNA đang thiếu các thành phần tương ứng. Hãy tìm các kí tự tương ứng với thành phần cho trước rồi trả về kết quả là một mảng 2 chiều.

```js
function pairElement(str) {
  var ans = [];
  str.split("""").forEach(function (val) {
    var tmp = [val];
    switch (val) {
      case ""A"":
        tmp.push(""T"");
        break;
      case ""T"":
        tmp.push(""A"");
        break;
      case ""G"":
        tmp.push(""C"");
        break;
      case ""C"":
        tmp.push(""G"");
        break;
    }
    ans.push(tmp);
  });
  return ans;
}

pairElement(""GCG"");
```
`function pairElement(str) {
  var ans = [];
  str.split("""").forEach(function (val) {
    var tmp = [val];
    switch (val) {
      case ""A"":
        tmp.push(""T"");
        break;
      case ""T"":
        tmp.push(""A"");
        break;
      case ""G"":
        tmp.push(""C"");
        break;
      case ""C"":
        tmp.push(""G"");
        break;
    }
    ans.push(tmp);
  });
  return ans;
}

pairElement(""GCG"");` Tham khảo:"
566,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Missing letters,"Tìm kí tự thiếu ở một chuỗi các kí tự cho trước. Nếu tất cả các kí tự đầy đủ thì trả vềundefined.

```js
function fearNotLetter(str) {
  for (var i = 1; i < str.length; i++) {
    var currCode = str.charCodeAt(i);
    var beforeCode = str.charCodeAt(i - 1);
    if (currCode > beforeCode + 1) return String.fromCharCode(beforeCode + 1);
  }
}

fearNotLetter(""abce"");
```
`function fearNotLetter(str) {
  for (var i = 1; i < str.length; i++) {
    var currCode = str.charCodeAt(i);
    var beforeCode = str.charCodeAt(i - 1);
    if (currCode > beforeCode + 1) return String.fromCharCode(beforeCode + 1);
  }
}

fearNotLetter(""abce"");` Tham khảo:"
567,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Boo who,"Kiểm tra xem nếu một giá trị cho trước là kiểu boolean, rồi trả về kết quả làtruehoặcfalse.

```js
function booWho(bool) {
  return typeof bool == ""boolean"";
}

booWho(null);
```
`function booWho(bool) {
  return typeof bool == ""boolean"";
}

booWho(null);` Tham khảo:"
568,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Sorted Union,"Viết mộtfunctionnhận đầu vào là 2 hay nhiều array. Trả về một array mới bao gồm các phần tử duy nhất, theo đúng thứ tự ban đầu.

```js
function uniteUnique(arr) {
  var table = {};
  var ans = [];
  for (var i = 0; i < arguments.length; i++) {
    for (var j = 0; j < arguments[i].length; j++) {
      var val = arguments[i][j];
      if (table[val] == undefined) {
        ans.push(val);
        table[val] = 1;
      }
    }
  }
  return ans;
}

uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
```
`function uniteUnique(arr) {
  var table = {};
  var ans = [];
  for (var i = 0; i < arguments.length; i++) {
    for (var j = 0; j < arguments[i].length; j++) {
      var val = arguments[i][j];
      if (table[val] == undefined) {
        ans.push(val);
        table[val] = 1;
      }
    }
  }
  return ans;
}

uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);` Tham khảo:"
569,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Convert HTML Entities,"Chuyển các kí tự &, <, >, "" và ' ở một string cho trước sang dạngHTML Entities.

```js
function convertHTML(str) {
  var table = {
    ""&"": ""&amp;"",
    ""<"": ""&lt;"",
    "">"": ""&gt;"",
    '""': ""&quot;"",
    ""'"": ""&apos;"",
  };
  for (var key in table) {
    str = str.replace(RegExp(key, ""g""), table[key]);
  }
  return str;
}

convertHTML(""Hamburgers < Pizza < Tacos"");
```
`function convertHTML(str) {
  var table = {
    ""&"": ""&amp;"",
    ""<"": ""&lt;"",
    "">"": ""&gt;"",
    '""': ""&quot;"",
    ""'"": ""&apos;"",
  };
  for (var key in table) {
    str = str.replace(RegExp(key, ""g""), table[key]);
  }
  return str;
}

convertHTML(""Hamburgers < Pizza < Tacos"");` Tham khảo:"
570,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Spinal Tap Case,"Convert một string sang dạngspinal case- bao gồm các chữ cái thường phân cách nhau bởi dấu -.

```js
function spinalCase(str) {
  var words = str.split(/[\s_-]/);
  words = words.map(function (word) {
    return word.replace(/[A-Z]/g, function (match, offset) {
      var lower = match.toLowerCase();
      return offset > 0 ? ""-"" + lower : lower;
    });
  });
  return words.join(""-"");
}

spinalCase(""This Is Spinal Tap"");
```
`function spinalCase(str) {
  var words = str.split(/[\s_-]/);
  words = words.map(function (word) {
    return word.replace(/[A-Z]/g, function (match, offset) {
      var lower = match.toLowerCase();
      return offset > 0 ? ""-"" + lower : lower;
    });
  });
  return words.join(""-"");
}

spinalCase(""This Is Spinal Tap"");` Tham khảo:"
571,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Sum All Odd Fibonacci Numbers,"Cho trước một số nguyên dương, tính tổng các số Fibonacci lẻ nhỏ hơn hoặc bằng số cho trước.

```js
function sumFibs(num) {
  if (num == 0 || num == 1) return 0;
  if (num == 2) return 2;

  var a = 1,
    b = 1,
    c = 0;
  var ans = 2;
  while (true) {
    c = b + a;

    if (c > num) break;
    if (c % 2) ans += c;

    a = b;
    b = c;
  }
  return ans;
}

sumFibs(75025);
```
`function sumFibs(num) {
  if (num == 0 || num == 1) return 0;
  if (num == 2) return 2;

  var a = 1,
    b = 1,
    c = 0;
  var ans = 2;
  while (true) {
    c = b + a;

    if (c > num) break;
    if (c % 2) ans += c;

    a = b;
    b = c;
  }
  return ans;
}

sumFibs(75025);`"
572,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Sum All Primes,"Tính tổng các số nguyên tố nhỏ hơn hoặc bằng số cho trước.

```js
function sumPrimes(num) {
  function isPrime(val) {
    if (val == 0 || val == 1) return false;
    if (val == 2) return true;

    for (var i = 2; i * i <= val; i++) {
      if (val % i == 0) return false;
    }
    return true;
  }
  var sum = 0;
  for (var j = 0; j <= num; j++) {
    if (isPrime(j)) sum += j;
  }
  return sum;
}

sumPrimes(10);
```
`function sumPrimes(num) {
  function isPrime(val) {
    if (val == 0 || val == 1) return false;
    if (val == 2) return true;

    for (var i = 2; i * i <= val; i++) {
      if (val % i == 0) return false;
    }
    return true;
  }
  var sum = 0;
  for (var j = 0; j <= num; j++) {
    if (isPrime(j)) sum += j;
  }
  return sum;
}

sumPrimes(10);`"
573,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Smallest Common Multiple,"Tìm bội số chung nhỏ nhất của các số trong một khoảng cho trước.

```js
function smallestCommons(arr) {
  function isDivisibleBy(num, from, to) {
    for (var i = from; i <= to; i++) {
      if (num % i) return false;
    }
    return true;
  }

  var max = Math.max(arr[0], arr[1]);
  var min = Math.min(arr[0], arr[1]);
  var mul = max;
  while (true) {
    if (isDivisibleBy(mul, min, max)) break;
    else mul += max;
  }
  return mul;
}

smallestCommons([1, 5]);
```
`function smallestCommons(arr) {
  function isDivisibleBy(num, from, to) {
    for (var i = from; i <= to; i++) {
      if (num % i) return false;
    }
    return true;
  }

  var max = Math.max(arr[0], arr[1]);
  var min = Math.min(arr[0], arr[1]);
  var mul = max;
  while (true) {
    if (isDivisibleBy(mul, min, max)) break;
    else mul += max;
  }
  return mul;
}

smallestCommons([1, 5]);` Tham khảo:"
574,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Finders Keepers,"Duyệt một mảng các số và tìm ra số đầu tiên thỏa mãn test.

```js
function findElement(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    if (func(val)) return val;
  }
}

findElement([1, 3, 5, 8, 9, 10], function (num) {
  return num % 2 === 0;
});
```
`function findElement(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    if (func(val)) return val;
  }
}

findElement([1, 3, 5, 8, 9, 10], function (num) {
  return num % 2 === 0;
});`"
575,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Drop it,"Bỏ đi các số của một mảng, từ trái sang phải, cho đến khi thỏa mãn test.

```js
function dropElements(arr, func) {
  while (arr.length > 0) {
    if (func(arr[0]) == false) arr.shift();
    else break;
  }
  return arr;
}

dropElements([1, 2, 3], function (n) {
  return n < 3;
});
```
`function dropElements(arr, func) {
  while (arr.length > 0) {
    if (func(arr[0]) == false) arr.shift();
    else break;
  }
  return arr;
}

dropElements([1, 2, 3], function (n) {
  return n < 3;
});` Tham khảo:"
576,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Steamroller,"San phẳng (chuyển về mảng một chiều) một mảng nhiều chiều cho trước.

```js
function steamrollArray(arr) {
  var ans = [];
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    if (Array.isArray(item)) {
      ans = ans.concat(steamrollArray(item));
    } else {
      ans = ans.concat([item]);
    }
  }
  return ans;
}

steamrollArray([1]);
```
`function steamrollArray(arr) {
  var ans = [];
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    if (Array.isArray(item)) {
      ans = ans.concat(steamrollArray(item));
    } else {
      ans = ans.concat([item]);
    }
  }
  return ans;
}

steamrollArray([1]);` Tham khảo:"
577,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Binary Agents,"Trả về một string bao gồm các kí tự tiếng anh từ chuỗi nhị phân cho trước.

```js
function binaryAgent(str) {
  function bin2Dec(bin) {
    var binArr = bin.split("""");
    return binArr.reduce(function (acc, cur, index) {
      return acc * 2 + Number(cur);
    }, 0);
  }
  var arr = str.split(/\s+/).map(function (bin) {
    var dec = bin2Dec(bin);
    return String.fromCharCode(dec);
  });
  return arr.join("""");
}

binaryAgent(
  ""01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111""
);
```
`function binaryAgent(str) {
  function bin2Dec(bin) {
    var binArr = bin.split("""");
    return binArr.reduce(function (acc, cur, index) {
      return acc * 2 + Number(cur);
    }, 0);
  }
  var arr = str.split(/\s+/).map(function (bin) {
    var dec = bin2Dec(bin);
    return String.fromCharCode(dec);
  });
  return arr.join("""");
}

binaryAgent(
  ""01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111""
);` Tham khảo:"
578,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Everything Be True,"Kiểm tra xem tham số thứ 2 đưa vào hàm có tồn tại trong tất cả các phần tử thuộc tham số thứ nhất.

```js
function truthCheck(collection, pre) {
  for (var i = 0; i < collection.length; i++) {
    if (!collection[i].hasOwnProperty(pre) || !collection[i][pre]) return false;
  }
  return true;
}

truthCheck(
  [
    { user: ""Tinky-Winky"", sex: ""male"" },
    { user: ""Dipsy"", sex: ""male"" },
    { user: ""Laa-Laa"", sex: ""female"" },
    { user: ""Po"", sex: ""female"" },
  ],
  ""sex""
);
```
`function truthCheck(collection, pre) {
  for (var i = 0; i < collection.length; i++) {
    if (!collection[i].hasOwnProperty(pre) || !collection[i][pre]) return false;
  }
  return true;
}

truthCheck(
  [
    { user: ""Tinky-Winky"", sex: ""male"" },
    { user: ""Dipsy"", sex: ""male"" },
    { user: ""Laa-Laa"", sex: ""female"" },
    { user: ""Po"", sex: ""female"" },
  ],
  ""sex""
);` Tham khảo:"
579,Thuật toán nâng cao trong Javascript,Intermediate Algorithm Scripting - Arguments Optional,"Viết một hàm số tính tổng 2 tham số. Nếu chỉ có một tham số được đưa vào thì trả về một function mới yêu cầu đưa vào một tham số, cuối cùng trả về kết quả tổng.

```js
function addTogether() {
  function isNumber(val) {
    if (typeof val === ""number"") return true;
    return false;
  }

  if (isNumber(arguments[0])) {
    if (isNumber(arguments[1])) return arguments[0] + arguments[1];
    if (arguments.length == 1) {
      var sum = arguments[0];
      return function () {
        if (isNumber(arguments[0])) return sum + arguments[0];
      };
    }
  }
}

addTogether(2, ""3"");
```
`function addTogether() {
  function isNumber(val) {
    if (typeof val === ""number"") return true;
    return false;
  }

  if (isNumber(arguments[0])) {
    if (isNumber(arguments[1])) return arguments[0] + arguments[1];
    if (arguments.length == 1) {
      var sum = arguments[0];
      return function () {
        if (isNumber(arguments[0])) return sum + arguments[0];
      };
    }
  }
}

addTogether(2, ""3"");` Tham khảo:"
580,Thuật toán nâng cao trong Javascript,Kết luận,"Trên đây là tổng hợp các bài toán thuộc chủ đềIntermediate Algorithm Scriptingtrên freeCodeCamp.
Nếu bạn có gì thắc mắc, góp ý hay cải tiến các thuật toán trên. Vui lòng để lại bình luận phía dưới nhé.
Xin chào và hẹn gặp lại bạn trong bài viết tiếp theo, thân ái!"
581,Thuộc tính và phương thức private của class trong Javascript,Giới thiệu,"Một trong những tính chất quan trọng của lập trình hướng đối tượng làtính đóng gói-Encapsulation.
Có thể bạn chưa biết
Hiểu đơn giản,tính đóng góilà khả năngche giấu thông tin của đối tượng với môi trường bên ngoài. Việc cho phép môi trường bên ngoài tác động lên các dữ liệu bên trong của đối tượng hoàn toàn tùy thuộc vào người lập trình.
Để làm được điều này, các ngôn ngữ lập trình như C++, Java,... hỗ trợ từ khóaprivatevàprotectedgiúphạn chế phạm vi sử dụngcủa các thuộc tính và phương thức trong class.
`private` `protected` Tuy nhiên, JavaScript lại không hỗ trợ các từ khóa này. Vậy thì làm sao để khai báo và sử dụng cácphương thức private (protected), thuộc tính private (protected)trong JavaScript?"
582,Thuộc tính và phương thức private của class trong Javascript,Đặt bài toán,"Trước khi đi vào chi tiết cách triển khai phương thức private (protected), thuộc tính private (protected) trong JavaScript, mình đặt ra bài toán minh họa vềbình nướcnhư sau:

```js
class WaterBottle {
  waterAmount = 0; // lượng nước trong bình

  constructor(volume) {
    this.volume = volume; // thế tích của bình
  }
}

// tạo mới bình nước
let waterBottle = new WaterBottle(100);

// gán giá trị nước
waterBottle.waterAmount = 10;
```
`class WaterBottle {
  waterAmount = 0; // lượng nước trong bình

  constructor(volume) {
    this.volume = volume; // thế tích của bình
  }
}

// tạo mới bình nước
let waterBottle = new WaterBottle(100);

// gán giá trị nước
waterBottle.waterAmount = 10;` Trong đoạn code trên, mình định nghĩa classWaterBottlebao gồm:
`WaterBottle` `waterAmount` `volume` Với cách định nghĩa như trên, thuộc tínhwaterAmountvàvolumelà hoàn toànpublic. Nói cách khác, bạn có thểdễ dàng get/set giá trịcho chúng từ bên ngoài classWaterBottlemà không bị giới hạn gì.
`waterAmount` `volume` `WaterBottle` 
```js
waterBottle.waterAmount = 20;
waterBottle.volume = 200;
```
`waterBottle.waterAmount = 20;
waterBottle.volume = 200;` Tuy nhiên, thực tế là luôn có giới hạn. Mình mong muốn giá trị củavolumekhông đổisau khi tạo đối tượng. Còn thuộc tínhwaterAmountluôn không âm và không vượt quávolume.
`volume` `waterAmount` `volume` Vì vậy, mình muốncác thuộc tính trên được bảo vệđể có thể dễ dàng kiểm soát việc thay đổi chúng."
583,Thuộc tính và phương thức private của class trong Javascript,Định nghĩa thuộc tính protected và phương thức protected,"Như mình đã nói ở trên, JavaScript không hỗ trợ từ khóaprotected. Tuy nhiên, có một cách mà nhiều lập trình viên ngầm định với nhau là sử dụng dấu gạch dưới_để biểu diễn phương thức protected và thuộc tính protected.
`_` Với cách này, đoạn code trên có thể sửa thành như sau:

```js
class WaterBottle {
  _waterAmount = 0; // lượng nước trong bình

  get waterAmount() {
    return this._waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) value = 0;
    if (value > this._volume) value = this._volume;
    this._waterAmount = value;
  }

  get volume() {
    return this._volume;
  }

  constructor(volume) {
    this._volume = volume; // thế tích của bình
  }
}

let waterBottle = new WaterBottle(100); // tạo mới bình nước

waterBottle.waterAmount = -10; // gán giá trị nước
console.log(waterBottle.waterAmount); // 0

waterBottle.waterAmount = 200; // gán giá trị nước
console.log(waterBottle.waterAmount); // 100

waterBottle.waterAmount = 50; // gán giá trị nước
console.log(waterBottle.waterAmount); // 50
```
`class WaterBottle {
  _waterAmount = 0; // lượng nước trong bình

  get waterAmount() {
    return this._waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) value = 0;
    if (value > this._volume) value = this._volume;
    this._waterAmount = value;
  }

  get volume() {
    return this._volume;
  }

  constructor(volume) {
    this._volume = volume; // thế tích của bình
  }
}

let waterBottle = new WaterBottle(100); // tạo mới bình nước

waterBottle.waterAmount = -10; // gán giá trị nước
console.log(waterBottle.waterAmount); // 0

waterBottle.waterAmount = 200; // gán giá trị nước
console.log(waterBottle.waterAmount); // 100

waterBottle.waterAmount = 50; // gán giá trị nước
console.log(waterBottle.waterAmount); // 50` Trong đoạn code trên, mình đã đổi tên các thuộc tính thành_waterAmountvà_volume.
`_waterAmount` `_volume` Giờ đây, việc get/set giá trị củawaterAmountđều thông qua hàm get và set. Trong hàmset waterAmount(), mình có thêmcác điều kiện ràng buộcđể đảm bảo giá trị củawaterAmountluôn không âm và không vượt quávolume.
`waterAmount` `set waterAmount()` `waterAmount` `volume` Đối với_volume, vì mình mong muốn thuộc tính này không thay đổi sau khi khởi tạo đối tượng, nên mình chỉ triển khai hàm getvolumechứ không viết hàm set.
`_volume` `volume` Chú ý:
► Mình muốn nhấn mạnh lại rằng, việc get/set giá trị cho các thuộc tính_waterAmountvà_volumelà hoàn toàn có thể. Tuy nhiên, việc này là không khuyến khích vì có thể gây ra lỗi logic sau này.
`_waterAmount` `_volume` 
```js
waterBottle._waterAmount = -10; // gán giá trị nước
waterBottle._volume = 0; // thay đổi thế tích
```
`waterBottle._waterAmount = -10; // gán giá trị nước
waterBottle._volume = 0; // thay đổi thế tích` ► Ngoài cách sử dụng hàmgetter và setter, bạn có thể viết hàm bình thường dạngget...vàset...như sau:
`get...` `set...` 
```js
class WaterBottle {
  _waterAmount = 0; // lượng nước trong bình

  getWaterAmount() {
    return this._waterAmount;
  }
  setWaterAmount(value) {
    if (value < 0) value = 0;
    if (value > this._volume) value = this._volume;
    this._waterAmount = value;
  }
  getVolume() {
    return this._volume;
  }
  constructor(volume) {
    this._volume = volume; // thế tích của bình
  }
}

let waterBottle = new WaterBottle(100); // tạo mới bình nước
waterBottle.setWaterAmount(50);
console.log(waterBottle.getWaterAmount()); // 50
```
`class WaterBottle {
  _waterAmount = 0; // lượng nước trong bình

  getWaterAmount() {
    return this._waterAmount;
  }
  setWaterAmount(value) {
    if (value < 0) value = 0;
    if (value > this._volume) value = this._volume;
    this._waterAmount = value;
  }
  getVolume() {
    return this._volume;
  }
  constructor(volume) {
    this._volume = volume; // thế tích của bình
  }
}

let waterBottle = new WaterBottle(100); // tạo mới bình nước
waterBottle.setWaterAmount(50);
console.log(waterBottle.getWaterAmount()); // 50` Cách viết này thường dài dòng hơn cách sử dụng getter/setter, tuy nhiên lại linh động hơn.
Vì cách sử dụng getter/setter, bạn chỉ truyền được một tham số. Còn khi viết hàm bình thường, bạn có thể truyền số lượng tham số tùy ý.
► Các thuộc tính, phương thức protected với_như trên không khác gì các thuộc tính, phương thức thông thường về mặt logic. Vì vậy, chúng có thể được truy cập từ các class kế thừa thông qua prototype haytừ khóaextend.
`_` `extend`"
584,Thuộc tính và phương thức private của class trong Javascript,Định nghĩa thuộc tính private và phương thức private,"Để định nghĩa thuộc tính private và phương thức private trong class JavaScript, bạn chỉ cần thêm kí tự#trước tên thuộc tính hay phương thức.
`#` Lưu ý
Thuộc tính private hay phương thức privatechưa support hoàn toàntrên các trình duyệt, bạn có thể tham khảo thêm tại đây:CanIUse - JavaScript classes: Private class fields
Áp dụng cách này vào đoạn code trên ta có kết quả như sau:

```js
class WaterBottle {
  #waterAmount = 0; // lượng nước trong bình
  #volume = 0; // thế tích của bình

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) value = 0;
    if (value > this.#volume) value = this.#volume;
    this.#waterAmount = value;
  }

  get volume() {
    return this.#volume;
  }

  constructor(volume) {
    this.#volume = volume;
  }
}

let waterBottle = new WaterBottle(100); // tạo mới bình nước
console.log(waterBottle.#volume);
// Lỗi: Private field '#volume' must be declared in an enclosing class
```
`class WaterBottle {
  #waterAmount = 0; // lượng nước trong bình
  #volume = 0; // thế tích của bình

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) value = 0;
    if (value > this.#volume) value = this.#volume;
    this.#waterAmount = value;
  }

  get volume() {
    return this.#volume;
  }

  constructor(volume) {
    this.#volume = volume;
  }
}

let waterBottle = new WaterBottle(100); // tạo mới bình nước
console.log(waterBottle.#volume);
// Lỗi: Private field '#volume' must be declared in an enclosing class` Trong đoạn code trên, mình đã thay đổi_waterAmountvà_volumethành#waterAmountvà#volume. Lúc này, các thuộc tính đãhoàn toàn private. Nếu bạn cố tình truy cập các thuộc tính này từ bên ngoài class thì sẽ gặp lỗi dạng như trên:
`_waterAmount` `_volume` `#waterAmount` `#volume` Kết quả
Private field '#volume' must be declared in an enclosing class
Đặc biệt, với thuộc tính private và phương thức private, bạn không thể truy cập được chúng từ class kế thừa, ví dụ:

```js
class ExtendedWaterBottle extends WaterBottle {
  constructor(volume) {
    super(volume);
  }

  debug() {
    console.log(this.#volume);
  }
}

let waterBottle = new ExtendedWaterBottle(100); // tạo mới bình nước
console.log(waterBottle.#volume);
// Lỗi: Private field '#volume' must be declared in an enclosing class
```
`class ExtendedWaterBottle extends WaterBottle {
  constructor(volume) {
    super(volume);
  }

  debug() {
    console.log(this.#volume);
  }
}

let waterBottle = new ExtendedWaterBottle(100); // tạo mới bình nước
console.log(waterBottle.#volume);
// Lỗi: Private field '#volume' must be declared in an enclosing class` Chú ý:thuộc tính private và phương thức private không thể truy cập thông qua cách sử dụngthis[name], ví dụ:
`this[name]` 
```js
class WaterBottle {
  #volume = 0; // lượng nước trong bình

  debug() {
    const fieldName = ""#volume"";
    console.log(""this[fieldName]"", this[fieldName]);
    console.log(""this.#volume"", this.#volume);
  }

  constructor(volume) {
    this.#volume = volume;
  }
}

let waterBottle = new WaterBottle(100);
waterBottle.debug();
// this[fieldName] undefined
// this.#volume 100
```
`class WaterBottle {
  #volume = 0; // lượng nước trong bình

  debug() {
    const fieldName = ""#volume"";
    console.log(""this[fieldName]"", this[fieldName]);
    console.log(""this.#volume"", this.#volume);
  }

  constructor(volume) {
    this.#volume = volume;
  }
}

let waterBottle = new WaterBottle(100);
waterBottle.debug();
// this[fieldName] undefined
// this.#volume 100`"
585,Thuộc tính và phương thức private của class trong Javascript,Tổng kết,"Tính đóng gói là một trong bốn tính chất quan trọng của lập trình hướng đối tượng. Việc sử dụng tính đóng gói giúp tách biệt phần triển khai code với phần sử dụng bên ngoài.
Điều này đặc biệt hữu ích khi bạn xây dựng các module và thư viện. Khi mà người sử dụng code không cần biết đến phần triển khai bên trong, giúp việc sử dụng code trở nên đơn giản hơn.
Để áp dụng tính chất đóng gói vào class trong JavaScript, bạn có thể sử dụng một trong hai cách sau:
`_` `#` Tham khảo:Private and protected properties and methods"
586,Thuộc tính và phương thức static của class trong Javascript,Giới thiệu,"Bạn có thể gán một phương thức trực tiếp cho class mà không phảiprototype. Phương thức khi đó được gọi làstatic.
`prototype`"
587,Thuộc tính và phương thức static của class trong Javascript,Phương thức static,"Đối với class trong JavaScript, bạn chỉ cần thêm từ khóastatictrước phương thức như sau:
`static` 
```js
class User {
  static staticMethod() {
    console.log(this === User);
  }
}

User.staticMethod(); // true
```
`class User {
  static staticMethod() {
    console.log(this === User);
  }
}

User.staticMethod(); // true` Cách này hoàn toàn tương tự việc định nghĩa thuộc tính trực tiếp trong class:

```js
class User {}

User.staticMethod = function () {
  console.log(this === User);
};

User.staticMethod(); // true
```
`class User {}

User.staticMethod = function () {
  console.log(this === User);
};

User.staticMethod(); // true` Giá trị củathistrongUser.staticMethod()chính làhàm khởi tạocủa classUser.
`this` `User.staticMethod()` `User` Thông thường, phương thức static được sử dụng để triển khai cáchàm thuộc về classnói chung mà không phải ở bất kỳ một object nào.
Ví dụ, bạn có các đối tượngArticlevà cần một hàm đểso sánh chúng. Và bạn có thể định nghĩa một phương thức staticArticle.comparenhư sau:
`Article` `Article.compare` 
```js
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

// sử dụng
let articles = [
  new Article(""HTML"", new Date(2019, 1, 1)),
  new Article(""CSS"", new Date(2019, 0, 1)),
  new Article(""JavaScript"", new Date(2019, 11, 1)),
];

articles.sort(Article.compare);
console.log(articles[0].title); // CSS
```
`class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

// sử dụng
let articles = [
  new Article(""HTML"", new Date(2019, 1, 1)),
  new Article(""CSS"", new Date(2019, 0, 1)),
  new Article(""JavaScript"", new Date(2019, 11, 1)),
];

articles.sort(Article.compare);
console.log(articles[0].title); // CSS` Trong ví dụ trên,Article.comparekhông thuộc bất kỳ một đối tượng article nào cả, mà thuộc về classArticle.
`Article.compare` `Article` Còn một ví dụ khác mà mọi người hay gọi làphương thức factoryhayfactory pattern. Tưởng tượng, bạn cần một vài cách để khởi tạo đối tượng article như:
`title` `date` `date` Cách đầu tiên có thể triển khai thông qua hàm khởi tạo. Với cách thứ hai, bạn có thể viết một phương thức static của classArticle.
`Article` Ví dụ phương thứcArtice.createTodays():
`Artice.createTodays()` 
```js
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static createTodays() {
    // Chú ý: this = Article    return new this(""Today's digest"", new Date());  }}

    let article = Article.createTodays();
    console.log(article.title); // Today's digest
  }
}
```
`class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static createTodays() {
    // Chú ý: this = Article    return new this(""Today's digest"", new Date());  }}

    let article = Article.createTodays();
    console.log(article.title); // Today's digest
  }
}` Mỗi khi cần tạo một article chongày hôm nay, bạn có thể gọiArticle.createTodays().
`Article.createTodays()` Ngoài ra, phương thức static còn được dùng trong các class liên quan đếndatabaseđể thực hiện các thao tác nhưtìm kiếm, lưu, xóa dự liệutrong database, ví dụ:

```js
// Xóa một article với id = 12345 trong database ứng với Article
Article.remove({ id: 12345 });
```
`// Xóa một article với id = 12345 trong database ứng với Article
Article.remove({ id: 12345 });`"
588,Thuộc tính và phương thức static của class trong Javascript,Thuộc tính static,"Bạn cũng có thể định nghĩa thuộc tính static trong class như sau:

```js
class Article {
  static publisher = ""Lam P."";
}

console.log(Article.publisher); // Lam P.
```
`class Article {
  static publisher = ""Lam P."";
}

console.log(Article.publisher); // Lam P.` Cách trên hoàn toàn giống với cách gán trực tiếp thuộc tính cho class:

```js
Article.publisher = ""Lam P."";
```
`Article.publisher = ""Lam P."";`"
589,Thuộc tính và phương thức static của class trong Javascript,Kế thừa thuộc tính và phương thức static,"Thuộc tính và phương thức static của class trong JavaScriptđều có thểkế thừa.
Ví dụ,Animal.comparevàAnimal.planetở đoạn code sau được kế thừa, sử dụng như làRabbit.comparehayRabbit.planet:
`Animal.compare` `Animal.planet` `Rabbit.compare` `Rabbit.planet` 
```js
class Animal {
  static planet = ""Earth"";
  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }

  run(speed = 0) {
    this.speed += speed;
    console.log(`${this.name} runs with speed ${this.speed}.`);
  }

  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }
}

// Kế thừa từ Animal
class Rabbit extends Animal {
  hide() {
    console.log(`${this.name} hides!`);
  }
}

let rabbits = [new Rabbit(""White Rabbit"", 10), new Rabbit(""Black Rabbit"", 5)];

rabbits.sort(Rabbit.compare);
rabbits[0].run(); // Black Rabbit runs with speed 5.

console.log(Rabbit.planet); // Earth
```
`class Animal {
  static planet = ""Earth"";
  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }

  run(speed = 0) {
    this.speed += speed;
    console.log(`${this.name} runs with speed ${this.speed}.`);
  }

  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }
}

// Kế thừa từ Animal
class Rabbit extends Animal {
  hide() {
    console.log(`${this.name} hides!`);
  }
}

let rabbits = [new Rabbit(""White Rabbit"", 10), new Rabbit(""Black Rabbit"", 5)];

rabbits.sort(Rabbit.compare);
rabbits[0].run(); // Black Rabbit runs with speed 5.

console.log(Rabbit.planet); // Earth` Trong ví dụ trên, khi gọiRabbit.comparethì hàm được kế thừa làAnimal.comparesẽ được gọi.
`Rabbit.compare` `Animal.compare` Nguyên nhân là khi kế thừa với class,Rabbit extends Animalthực sự tạo rahai tham chiếucủa[[Prototype]]như sau:
`Rabbit extends Animal` `[[Prototype]]` `Rabbit` `Animal` `Rabbit.prototype` `Animal.prototype` Bạn có thể xem ví dụ sau để thấy rõ điều đó:

```js
class Animal {}
class Rabbit extends Animal {}

// phương thức static
console.log(Rabbit.__proto__ === Animal); // true

// phương thức thông thường
console.log(Rabbit.prototype.__proto__ === Animal.prototype); // true
```
`class Animal {}
class Rabbit extends Animal {}

// phương thức static
console.log(Rabbit.__proto__ === Animal); // true

// phương thức thông thường
console.log(Rabbit.prototype.__proto__ === Animal.prototype); // true`"
590,Thuộc tính và phương thức static của class trong Javascript,Tổng kết,"Các phương thức static trong class thuộc về chính class đó mà không phải ở bất kỳ một đối tượng nào.
Ví dụ phương thức so sánhArticle.compare(article1, article2)hay phương thức khởi tạofactorynhưArticle.createTodays().
`Article.compare(article1, article2)` `Article.createTodays()` Các phương thức static được định nghĩa trong class bằng cách sử dụng từ khóastaticđằng trước.
`static` Các thuộc tính static cũng tương tự như phương thức static, chúng tồn tại trong chính class.
Cú pháp cơ bản để định nghĩa thuộc tính và phương thức static trong class là:

```js
class MyClass {
  static property = ...;
  static method() {
    ...
  }
}
```
`class MyClass {
  static property = ...;
  static method() {
    ...
  }
}` Về cơ bản, cách định nghĩa thuộc tính static và phương thức static trong class giống với cách gán trực tiếp cho class như sau:

```js
MyClass.property = ...
MyClass.method = ...
```
`MyClass.property = ...
MyClass.method = ...` Thuộc tính hay phương thức static đều có thểkế thừa.
Ví dụ khiclass B extends A, prototype củaBđược gán bằngAnhư sau:B.[[Prototype]] = A. Do đó, nếu một phương thức hay thuộc tính static không được tìm thấy ởBthì JavaScript sẽ tìm kiếm trongA.
`class B extends A` `B` `A` `B.[[Prototype]] = A` `B` `A` Tham khảo:Static properties and methods"
591,Tìm hiểu regex trong Javascript,Giới thiệu,"Regular expression hay còn được gọi tắt là Regex hay RegExp, là một cách để biểu diễn khuôn mẫu của string. Regex là một phần quan trọng của ngôn ngữ lập trình JavaScript, cũng như nhiều ngôn ngữ lập trình khác.
Nếu bạn là một lập trình viên và đã từng sử dụng Regular Expression thì bạn chắc hẳn sẽ thấy rằng nó có cú pháp rất kinh khủng và có phần ""bí ẩn"". Tuy nhiên, công cụ này lại cực kì mạnh mẽ và hiệu quả khi dùng để xử lý string.
Sau đây, chúng ta sẽ cùng tìm hiểu về Regular Expression trong JavaScript."
592,Tìm hiểu regex trong Javascript,Khởi tạo Regular Expression,"Có hai cách để tạo ra một Regex JavaScript là:

```js
var re1 = new RegExp(""abc"");
var re2 = /abc/;
```
`var re1 = new RegExp(""abc"");
var re2 = /abc/;` Cả hai cách trên ta đều thu được một Regular Expression biểu diễn một string có dạng:abc."
593,Tìm hiểu regex trong Javascript,Một số phương thức của Regular Expression,"Đây là phương thức đơn giản nhất dùng để kiểm tra xem một string có chứa khuôn mẫu đã định nghĩa hay không. Nếu có thì kết quả trả về là TRUE và ngược lại thì là FALSE.

```js
console.log(/abc/.test(""abcde""));
// => true
console.log(/abc/.test(""12abcde""));
// => true
console.log(/abc/.test(""abxcde""));
// => false
```
`console.log(/abc/.test(""abcde""));
// => true
console.log(/abc/.test(""12abcde""));
// => true
console.log(/abc/.test(""abxcde""));
// => false` Trong ví dụ trên, 2 string ""abcde"" và ""12abcde"" đều chứa ""abc"" nên kết quả trả về là true. String còn lại ""abxcde"" không chứa ""abc"" nên kết quả là false.
Nếu chỉ kiểm tra như ví dụ trên thì bạn hoàn toàn có thể sử dụng phương thứcindexOfcủa string thay vì sử dụng JavaScript Regular Expression.
Tuy nhiên, với RegExp JavaScript thì bạn có thể kiểm tra những mẫu string phức tạp hơn.
Ví dụ:

```js
console.log(/[0123456789]/.test(""in 1992""));
// => true
console.log(/[0-9]/.test(""in 1992""));
// => true
console.log(/[0-9]/.test(""Hello ""));
// => false
console.log(/[0-5]/.test(""Gold 9999""));
// => false
```
`console.log(/[0123456789]/.test(""in 1992""));
// => true
console.log(/[0-9]/.test(""in 1992""));
// => true
console.log(/[0-9]/.test(""Hello ""));
// => false
console.log(/[0-5]/.test(""Gold 9999""));
// => false` Ví dụ 1, 2, 3 kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 9. Ví dụ cuối cùng kiểm tra xem string có chứa bất kì chữ số nào từ 0 đến 5.
JavaScript sử dụng cặp dấu ngoặc vuông [] để biểu thị việc kiểm tra string có chứa bất kì kí tự nào có trong cặp dấu [] hay không. Trong đó, dấu ""-"" giữa hai kí tự dùng để chỉ 1 khoảng giữa hai kí tự đó.
`\[0-9\]` `\[a-z\]` Ngoài ra, JavaScript cung cấp sẵn một số cách biểu diễn một tập hợp các kí tự:
`\\d` `\\w` `\\s` `\\D` `\\W` `\\S` `.` Ví dụ kiểm tra ngày giờ có định dạng:dd-mm-yyyy hh:mm

```js
var dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(dateTime.test(""30-01-2003 15:20""));
// => true
console.log(dateTime.test(""30-jan-2003 15:20""));
// => false
```
`var dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(dateTime.test(""30-01-2003 15:20""));
// => true
console.log(dateTime.test(""30-jan-2003 15:20""));
// => false` Trường hợp bạn muốn kiểm tra một string chứa bất kì kí tự nào không có trong tập hợp đã cho thì bạn có thể sử dụng kí tự ""^"".
Ví dụ:

```js
var notBinary = /[^01]/;
console.log(notBinary.test(""1100100010100110""));
// => false
console.log(notBinary.test(""1100100010200110""));
// => true
```
`var notBinary = /[^01]/;
console.log(notBinary.test(""1100100010100110""));
// => false
console.log(notBinary.test(""1100100010200110""));
// => true` Trong ví dụ về kiểm tra ngày giờ bên trên, ""\d"" xuất hiện lặp lại rất nhiều lần. Điều này gây nên sự khó theo dõi. Do đó, JavaScript cung cấp cách thức để biểu diễn sự lặp lại khuôn mẫu:

```js
console.log(/'\d+'/.test(""'123'""));
// => true
console.log(/'\d+'/.test(""''""));
// => false
```
`console.log(/'\d+'/.test(""'123'""));
// => true
console.log(/'\d+'/.test(""''""));
// => false` 
```js
console.log(/'\d*'/.test(""'123'""));
// => true
console.log(/'\d*'/.test(""''""));
// => true
```
`console.log(/'\d*'/.test(""'123'""));
// => true
console.log(/'\d*'/.test(""''""));
// => true` 
```js
var neighbor = /neighbou?r/;
console.log(neighbor.test(""neighbour""));
// => true
console.log(neighbor.test(""neighbor""));
// => true
console.log(neighbor.test(""neighbouur""));
// => false
```
`var neighbor = /neighbou?r/;
console.log(neighbor.test(""neighbour""));
// => true
console.log(neighbor.test(""neighbor""));
// => true
console.log(neighbor.test(""neighbouur""));
// => false` 
```js
console.log(/\d{4}/.test(""1234""));
// => true
console.log(/\d{4}/.test(""12345""));
// => true
console.log(/\d{4}/.test(""123""));
// => false
```
`console.log(/\d{4}/.test(""1234""));
// => true
console.log(/\d{4}/.test(""12345""));
// => true
console.log(/\d{4}/.test(""123""));
// => false` 
```js
console.log(/\d{2,4}/.test(""12345""));
// => true
console.log(/\d{2,4}/.test(""1234""));
// => true
console.log(/\d{2,4}/.test(""123""));
// => true
console.log(/\d{2,4}/.test(""12""));
// => true
console.log(/\d{2,4}/.test(""1""));
// => false
```
`console.log(/\d{2,4}/.test(""12345""));
// => true
console.log(/\d{2,4}/.test(""1234""));
// => true
console.log(/\d{2,4}/.test(""123""));
// => true
console.log(/\d{2,4}/.test(""12""));
// => true
console.log(/\d{2,4}/.test(""1""));
// => false` 
```js
console.log(/\d{2,}/.test(""12""));
// => true
console.log(/\d{2,}/.test(""1234""));
// => true
console.log(/\d{2,}/.test(""1""));
// => false
```
`console.log(/\d{2,}/.test(""12""));
// => true
console.log(/\d{2,}/.test(""1234""));
// => true
console.log(/\d{2,}/.test(""1""));
// => false` Trong nhiều trường hợp bạn muốn lặp lại cả một nhóm các phần tử. Khi đó, bạn phải nhóm các phần tử đó lại sử dụng cặp dấu ngoặc đơn ""( )"".

```js
var cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test(""Boohoooohoohooo""));
// => true
```
`var cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test(""Boohoooohoohooo""));
// => true` Trường hợp bạn có nhiều khuôn mẫu và bạn cần kiểm tra xem string đưa ra chứa một trong các khuôn mẫu đó thì bạn có thể viết các Regular Expression tương ứng để kiểm tra. Hoặc sử dụng kí tự (|) để biểu diễn ""hoặc"":

```js
var animalCount = /\d+ (pig|cow|chicken)s?/;
console.log(animalCount.test(""15 pigs""));
// => true
console.log(animalCount.test(""15 pigchickens""));
// => false
```
`var animalCount = /\d+ (pig|cow|chicken)s?/;
console.log(animalCount.test(""15 pigs""));
// => true
console.log(animalCount.test(""15 pigchickens""));
// => false` Nếu như phương thứctestchỉ kiểm tra xem có tồn tại khuôn mẫu hay không thì phương thứcexecsẽ trả về một đối tượng chứa thông tin thành phần trùng khớp với khuôn mẫu, ngược lại thì trả về null.

```js
var match = /\d+/.exec(""one two 100 200"");
console.log(match);
// => [""100"", index: 8, input: ""one two 100 200""]
console.log(match.index);
// => 8
```
`var match = /\d+/.exec(""one two 100 200"");
console.log(match);
// => [""100"", index: 8, input: ""one two 100 200""]
console.log(match.index);
// => 8` Ví dụ trên trả về thành phần thoả mãn khuôn mẫu đầu tiên là: ""100"".Indexlà vị trí đầu tiên của string thoả mãn khuôn mẫu.
Khi Regular Expression chứa group với cặp dấu ngoặc đơn thì phần tử đầu tiên trong kết quả sẽ là toàn bộ thành phần trùng khớp, thành phần tiếp theo là phần trùng khớp với group đầu tiên, thành phần tiếp theo là phần trùng khớp với group thứ 2,...

```js
var quotedText = /'([^']*)'/;
console.log(quotedText.exec(""she said 'hello'""));
// => [""'hello'"", ""hello"", index: 9, input: ""she said 'hello'""]

console.log(/bad(ly)?/.exec(""bad""));
// => [""bad"", undefined, index: 0, input: ""bad""]

console.log(/(\d)+/.exec(""123""));
// => [""123"", ""3"", index: 0, input: ""123""]
```
`var quotedText = /'([^']*)'/;
console.log(quotedText.exec(""she said 'hello'""));
// => [""'hello'"", ""hello"", index: 9, input: ""she said 'hello'""]

console.log(/bad(ly)?/.exec(""bad""));
// => [""bad"", undefined, index: 0, input: ""bad""]

console.log(/(\d)+/.exec(""123""));
// => [""123"", ""3"", index: 0, input: ""123""]` Đặc biệt nếu một group có nhiều thành phần trùng khớp thì chỉ lấy thành phần trùng khớp cuối cùng. Trong ví dụ trên, group(\d)có 3 thành phần trùng khớp là1,2,3. Nhưng chỉ thành phần trùng khớp cuối cùng là3xuất hiện trong kết quả.
Phương thức này đặc biệt hữu ích khi bạn muốn lấy thông tin ra từ string.
Ví dụ sau đưa ra một string biểu diễn ngày, tháng, năm. Sau đó chúng ta sẽ trích xuất ra thông tin về ngày, tháng và năm ở trong đó:

```js
function findDate(string) {
  var dateTime = /(\d{1,2})-(\d{1,2})-(\d{4})/;
  var match = dateTime.exec(string);
  return {
    day: match[1],
    month: match[2],
    year: match[3],
  };
}
var obj = findDate(""30-1-2003"");
console.log(obj);
// => Object {day: ""30"", month: ""1"", year: ""2003""}
```
`function findDate(string) {
  var dateTime = /(\d{1,2})-(\d{1,2})-(\d{4})/;
  var match = dateTime.exec(string);
  return {
    day: match[1],
    month: match[2],
    year: match[3],
  };
}
var obj = findDate(""30-1-2003"");
console.log(obj);
// => Object {day: ""30"", month: ""1"", year: ""2003""}` Trong ví dụ trên, hàm findDate vẫn tìm ra kết quả nếu như string là ""30-1-200300"" hay ""1130-1-2003"",... Đây là trường hợp không mong muốn.
Regular Expression JavaScript cung cấp 2 cách để giải quyết vấn đề này:

```js
function findDate(string) {
  var dateTime = /^(\d{1,2})-(\d{1,2})-(\d{4})$/;
  var match = dateTime.exec(string);
  if (!match) return null;
  return {
    day: match[1],
    month: match[2],
    year: match[3],
  };
}
var obj1 = findDate(""30-1-2003"");
console.log(obj1);
// => Object {day: ""30"", month: ""1"", year: ""2003""}

var obj2 = findDate(""0030-1-200300"");
console.log(obj2);
// => null

var obj3 = findDate(""Hello 30-1-2003 Haha"");
console.log(obj3);
// => null
```
`function findDate(string) {
  var dateTime = /^(\d{1,2})-(\d{1,2})-(\d{4})$/;
  var match = dateTime.exec(string);
  if (!match) return null;
  return {
    day: match[1],
    month: match[2],
    year: match[3],
  };
}
var obj1 = findDate(""30-1-2003"");
console.log(obj1);
// => Object {day: ""30"", month: ""1"", year: ""2003""}

var obj2 = findDate(""0030-1-200300"");
console.log(obj2);
// => null

var obj3 = findDate(""Hello 30-1-2003 Haha"");
console.log(obj3);
// => null` 
```js
function findDate(string) {
  var dateTime = /\b(\d{1,2})-(\d{1,2})-(\d{4})\b/;
  var match = dateTime.exec(string);
  if (!match) return null;
  return {
    day: match[1],
    month: match[2],
    year: match[3],
  };
}
var obj1 = findDate(""30-1-2003"");
console.log(obj1);
// => Object {day: ""30"", month: ""1"", year: ""2003""}

var obj2 = findDate(""0030-1-200300"");
console.log(obj2);
// => null

var obj3 = findDate(""Hello 30-1-2003 Haha"");
console.log(obj3);
// => Object {day: ""30"", month: ""1"", year: ""2003""}
```
`function findDate(string) {
  var dateTime = /\b(\d{1,2})-(\d{1,2})-(\d{4})\b/;
  var match = dateTime.exec(string);
  if (!match) return null;
  return {
    day: match[1],
    month: match[2],
    year: match[3],
  };
}
var obj1 = findDate(""30-1-2003"");
console.log(obj1);
// => Object {day: ""30"", month: ""1"", year: ""2003""}

var obj2 = findDate(""0030-1-200300"");
console.log(obj2);
// => null

var obj3 = findDate(""Hello 30-1-2003 Haha"");
console.log(obj3);
// => Object {day: ""30"", month: ""1"", year: ""2003""}`"
594,Tìm hiểu regex trong Javascript,Tạo đối tượng RegExp JavaScript một cách linh động,"Trong nhiều trường hợp, bạn muốn tạo ra một Regular Expression với nội dung chưa được biết trước. Bạn có thể sử dụng hàm khởi tạo của RegExp theo cách sau:

```js
var name = ""lampv"";
var text = ""LamPV is a suspicious character."";
var regexp = new RegExp(""\\b("" + name + "")\\b"", ""gi"");
console.log(text.replace(regexp, ""_$1_""));
// => _LamPV_ is a suspicious character.
```
`var name = ""lampv"";
var text = ""LamPV is a suspicious character."";
var regexp = new RegExp(""\\b("" + name + "")\\b"", ""gi"");
console.log(text.replace(regexp, ""_$1_""));
// => _LamPV_ is a suspicious character.` Trong đó:
Ngoài ra, ở đây mình có sử dụng phương thứcreplacecủastring- dùng để thay thế tất cả những thành phần trùng khớp với khuôn mẫu với ""$1"".
Ở đây $1 chính là nội dung của group thứ nhất."
595,Tìm hiểu regex trong Javascript,Kết luận,"Trên đây là một số kiến thức cơ bản về Regular Expression. Hy vọng qua bài viết này bạn phần nào hiểu và biết cách sử dụng Regex JavaScript.
Tóm tắt một số khuôn mẫu cơ bản của Regex trong JavaScript:
`/abc/` `/\[abc\]` `/\[^abc\]` `/\[0-9\]/` `/x+/` `/x\*/` `/x?/` `/x{2, 4}/` `/(abc)/` `/a|b|c/` `/\\d/` `/\\w/` `/\\s/` `/./` `/\\b/` `/^/` `/$/`"
596,Tìm hiểu về HTTP Cookie trong JavaScript,Giới thiệu,"Nếu bạn tìm kiếm Google về ""cookie"" hay ""HTTP Cookie"" thì sẽ ra rất nhiều kết quả như: ""kỹ thuật lấy cắp cookie của nạn nhân"", ""cách thức đánh cắp cookie thông qua lỗ hổng XSS"", ""khai thác cookie trình duyệt để bypass HTTPS và đánh cắp thông tin""... Qua đây, bạn có thể thấy cookie thường sẽ liên quan đến những thông tin cá nhân khá nhạy cảm. Và đó chính là một trong những mục tiêu tấn công của các Hackers.
Vậy rốt cuộc HTTP Cookie là gì?
Sau đây mình sẽ cùng nhau tìm hiểu về HTTP Cookie nhé!"
597,Tìm hiểu về HTTP Cookie trong JavaScript,Cơ bản về HTTP Cookie,"Theo MDN,HTTP Cookieđược định nghĩa như sau:
Có thể bạn chưa biết
HTTP Cookie (web cookie, browser cookie) là dữ liệu được gửi từ server tới trình duyệt của người dùng. Trình duyệt sẽ lưu dữ liệu cookie này và gửi lại theo mỗi HTTP request về cho cùng server đó. Về cơ bản, cookie dùng để nói cho server biết các request đến từ một trình duyệt, ví dụ để giữ lại trạng thái đăng nhập...
Đúng vậy, HTTP làstateless. Do đó, mọi request đến server đều giống nhau. Vì vậy, server không thể phân biệt được request được gửi đến là từ một client đã thực hiện request trước đó, đã đăng nhập,... hay từ một client mới.
Vì vậy, HTTP Cookie đã ra đời để giải quyết vấn đề này.
Cụ thể, các tác dụng chính của cookie là:
HTTP Cookie có nhiều lợi ích, nhưng cũng tồn tại nhiều giới hạn như:"
598,Tìm hiểu về HTTP Cookie trong JavaScript,Các thao tác với cookie,"Thực tế, HTTP Cookie có thể được thao tác (cài đặt, đọc) từ cảservervàclient. Và khi bạn thiết lậpchỉ sử dụng cookie phía serverthì những phần mình nói sau đây sẽ không thể thực hiện.
Tuy nhiên, do mình đang tập trung vào JavaScript nên sẽ giả định là server cho phép client truy cập vào cookie. Và đối tượng giúp tương tác với HTTP Cookie phía trình duyệt, chính làdocument.cookie. Sau đây, mình sẽ tìm hiểu về các thao tác mà đối tượng này hỗ trợ.
Cách đơn giản nhất để tạo mới một cookie là:

```js
document.cookie = ""foo1=bar1"";
```
`document.cookie = ""foo1=bar1"";` Đoạn code trên sẽ tạo thêm một cookie vớikeylàfoo1vàvaluelàbar1.
Chú ý: Tuy đoạn code trên thực hiện phép gán, nhưng thực tế, nó sẽ không ghi đè lên các cookies có sẵn mà chỉ tạo thêm giá trị mới. Nghĩa là nếu bạn muốn tạo thêm cookie với key làfoo2và value làbar2, bạn có thể viết tiếp:

```js
document.cookie = ""foo2=bar2"";
```
`document.cookie = ""foo2=bar2"";` Lúc này, bạn sẽ có 2 cookie là:'foo1=bar1; foo2=bar2'.
`'foo1=bar1; foo2=bar2'` Ngoài ra, giá trị của cookie nên được encode với phương thứcencodeURIComponent()để tránh các kí tự không hợp lệ như: dấu cách, dấu phẩy và dấu chấm phẩy. Ví dụ, nếu mình muốn thêm cookie với key lànamevà value làLam Pham, thì có thể làm như sau:

```js
const value = encodeURIComponent(""Lam Pham"");
document.cookie = `name=${value}`;
```
`const value = encodeURIComponent(""Lam Pham"");
document.cookie = `name=${value}`;` Khi đó, giá trị cookie thu được là:'foo1=bar1; foo2=bar2; name=Lam%20Pham'.
`'foo1=bar1; foo2=bar2; name=Lam%20Pham'` Nếu bạn không cài đặt thời gian hết hạn cho HTTP Cookie thì mặc định nó sẽ bị xoá khi trình duyệt đóng. Để tránh việc này, bạn có thể cài đặt thời điểm hết hạn cho cookie bằng cách khai báo thêm thuộc tínhexpiresvới giá trị thời gian ở định dạng UTC, ví dụ:

```js
document.cookie = ""foo1=bar1; expires=Thu, 04 Apr 2019 17:00:00 GMT"";
```
`document.cookie = ""foo1=bar1; expires=Thu, 04 Apr 2019 17:00:00 GMT"";` Để thu được định dạng thời gian như trên, bạn có thể dùng phương thứctoUTCString():

```js
const d = new Date(2019, 03, 5).toUTCString();
console.log(d);
// => Thu, 04 Apr 2019 17:00:00 GMT
```
`const d = new Date(2019, 03, 5).toUTCString();
console.log(d);
// => Thu, 04 Apr 2019 17:00:00 GMT` Thay vì cài đặt thời điểm hết hạn cookie, bạn có thể cài đặt thời gian hết hạn cho nó. Hay nói cách khác là sau bao nhiêu lâu thì cookies sẽ bị hết hạn. Để làm việc này, bạn cài đặt thuộc tínhmax-agevới giá trị là thời gian tính bằng đơn vị giây, ví dụ:

```js
document.cookie = ""foo1=bar1; max-age=3600""; // hết hạn sau 60 phút
document.cookie = ""foo2=bar2; max-age=31536000""; // hết hạn sau 1 năm
```
`document.cookie = ""foo1=bar1; max-age=3600""; // hết hạn sau 60 phút
document.cookie = ""foo2=bar2; max-age=31536000""; // hết hạn sau 1 năm` Khi bạn không cài đặt thuộc tínhdomaincho cookie, mặc định, giá trị này được gán cho domain mà bạn sử dụng, giả sử làdomain.com. Khi đó, cookies cũng được sử dụng cho các subdomain, ví dụ:sub1.domain.com,sub2.domain.com,child.sub2.domain.com... Tuy nhiên, bạn cũng có thể giới hạn domain sử dụng bằng cách cài đặt chính xác giá trị cho nó:

```js
document.cookie = 'foo1=bar1; domain=""sub1.domain.com"";';
```
`document.cookie = 'foo1=bar1; domain=""sub1.domain.com"";';` Khi đó, cookies chỉ tồn tại ở domainsub1.domain.com(mà không có ởsub2.domain.com) và các domain con của nó nhưchild1.sub1.domain.com,child2.sub1.domain.com,...
`sub2.domain.com` `child1.sub1.domain.com` `child2.sub1.domain.com` Tương tự như domain, nếu bạn không cài đặtpaththì mặc định, giá trị này sẽ là ""/"". Khi đó, cookies sẽ tồn tại ở trang chủ ""/"" và các trang con như: ""/tag"", ""/category"", ""/category/cookie"",... Ngoài ra, bạn cũng có thể xác định rõ giá trị cho nó:

```js
document.cookie = 'foo=bar; path=""/category""';
```
`document.cookie = 'foo=bar; path=""/category""';` Khi đó, cookies sẽ có giá trị ở path/categoryvà các path con của nó như/category/cookie,/category/session,... mà không có ở các path khác như/tag,...
Lưu ý
Trên đây mình chỉ ví dụ minh hoạ cho mỗi thuộc tính, thực tế bạn có thể kết hợp chúng lại với nhau:

```js
document.cookie =
  'foo1=bar1; expires=Thu, 04 Apr 2019 17:00:00 GMT; domain=""mysite.com""; path=""/category""';
document.cookie =
  'foo2=bar2; max-age=3600; domain=""sub.mysite.com""; path=""/tag""';
```
`document.cookie =
  'foo1=bar1; expires=Thu, 04 Apr 2019 17:00:00 GMT; domain=""mysite.com""; path=""/category""';
document.cookie =
  'foo2=bar2; max-age=3600; domain=""sub.mysite.com""; path=""/tag""';` Để cập nhật giá trị cho một cookie, bạn cũng sử dụng cú pháp như việc tạo mới một cookie. Chỉ khác là ở đây, tên của cookie đã tồn tại, nên giá trị của nó sẽ bị ghi đè:

```js
document.cookie = ""foo=bar1"";
console.log(document.cookie);
// => foo=bar1

document.cookie = ""foo=bar2; max-age=3600"";
console.log(document.cookie);
// => foo=bar2
```
`document.cookie = ""foo=bar1"";
console.log(document.cookie);
// => foo=bar1

document.cookie = ""foo=bar2; max-age=3600"";
console.log(document.cookie);
// => foo=bar2` Để đọc giá trị của cookie, bạn sẽ lấy ra giá trị củadocument.cookie.

```js
const cookies = document.cookie;
console.log(cookies);
// => 'foo1=bar1; foo2=bar2; foo3=bar3'
```
`const cookies = document.cookie;
console.log(cookies);
// => 'foo1=bar1; foo2=bar2; foo3=bar3'` Giá trị trả về sẽ là một đoạn string chứa tất cả các cookies. Với các cặp cookie có dạngkey=valueđược phân cách nhau bởi một dấu chấm phẩy và một dấu cách theo sau (trừ cặp cuối cùng). Khi đó, để lấy ra giá trị tương ứng với một cookie cụ thể, bạn chỉ cần duyệt string trên để lấy ra giá trị của nó.
Để xoá một cookie, bạn cũng sử dụng cú pháp phần cập nhật cookie bên trên. Vớikeylà tên của cookie bạn muốn xoá vàvaluebạn bỏ trống, cùng với giá trị củaexpireslà một thời điểm trong quá khứ. Ví dụ:

```js
document.cookie = ""foo=; expires=Wed, 27 Feb 2019 07:41:28 GMT;"";
```
`document.cookie = ""foo=; expires=Wed, 27 Feb 2019 07:41:28 GMT;"";`"
599,Tìm hiểu về HTTP Cookie trong JavaScript,Thao tác với Cookie từ Server,"Bên trên, mình đã tìm hiểu về việc thao tác với HTTP Cookie phía client sử dụng JavaScript. Phần này, mình sẽ tìm hiểu cơ bản về cách làm việc với cookie từ phía server.
Khi server nhận được mộtHTTP requesttừ client, response trả về sẽ sử dụng headerSet-Cookieđể xác định những cookie được trình duyệt lưu lại, với cấu trúc đơn giản:

```js
HTTP/2.0 200 OK
    Content-type: text/html
    Set-Cookie: foo1=bar1
    Set-Cookie: foo2=bar2

    [page content]
```
`HTTP/2.0 200 OK
    Content-type: text/html
    Set-Cookie: foo1=bar1
    Set-Cookie: foo2=bar2

    [page content]` Và sau đó, với mỗi request đến server, trình duyệt sẽ sử dụng headerCookieđể gửi lại các cookies lên server:

```js
GET /sample.html HTTP/2.0
    Host: www.example.org
    Cookie: foo1=bar1; foo2=bar2
```
`GET /sample.html HTTP/2.0
    Host: www.example.org
    Cookie: foo1=bar1; foo2=bar2` Dĩ nhiên, bạn không cần phải làm việc trực tiếp với cấu trúc này. Vì mỗi ngôn ngữ lập trình đều có API riêng giúp bạn thao tác với cookies một cách đơn giản, ví dụ:PHP,Node.JS,Python,Ruby on Rails.
Ngoài ra, bạn cũng có thể cài đặt thêm các thuộc tínhExpires,Max-Age,DomainvàPathtương tự như mình đã trình bày bên trên. Và một vài các thuộc tính khác giúp cho việc sử dụng HTTP Cookie an toàn hơn, đó là:"
600,Tìm hiểu về HTTP Cookie trong JavaScript,Kiểm tra giá trị của cookie trên trình duyệt,"Để kiểm tra giá trị của cookie trên trình duyệt, bạn có thể sử dụng thông qua Console của DevTools (được mở bằng cách nhấnF12hoặc tổ hợpCtrl Shift I). Tại console, bạn gõ lệnhdocument.cookie, khi đó kết quả thu được là:
`document.cookie` 
```js
document.cookie;
// => ""foo1=bar1; foo2=bar2""
```
`document.cookie;
// => ""foo1=bar1; foo2=bar2""` Hoặc cũng trong DevTools, bạn vào tabApplication -> Storage -> Cookies. Khi đó, thông tin chi tiết về các cookies sẽ được hiển thị."
601,Tìm hiểu về HTTP Cookie trong JavaScript,Lời kết,"Trên đây là những kiến thức cơ bản về HTTP Cookie. Hy vọng bạn có thể hiểu được về cookie và cách sử dụng nó phía client và server. Nếu có gì thắc mắc hay góp ý, bạn vui lòng để lại trong phần bình luận phía dưới. Mình sẽ cố gắng giải đáp.
Tham khảo:"
602,Tìm hiểu về forEach trong Javascript,Giới thiệu,"Trong JavaScript, để duyệtarraythìforEachlà một hàm rất hay. Vậy hàm forEach trong JavaScript cụ thể là như thế nào? Cách sử dụng forEach JavaScript ra sao? Mình hãy cùng tìm hiểu để làm chủ forEach js nhé!"
603,Tìm hiểu về forEach trong Javascript,Đặt bài toán,"Cho một mảngnumbers= [1, 2, 3, 4, 5, 6,7, 8, 9, 10]. Hãy tính tổng các số trong mảng và hiển thị raconsole.
`numbers= [1, 2, 3, 4, 5, 6,7, 8, 9, 10]` Khi mới học JavaScript, mình giải bài toán này như sau:

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let sum = 0;

// duyệt từng phần tử của mảng để cộng dồn vào biến sum
for (let i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}

console.log(sum); // 55
```
`const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let sum = 0;

// duyệt từng phần tử của mảng để cộng dồn vào biến sum
for (let i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}

console.log(sum); // 55` Cách giải trên khá dễ hiểu. Mình duyệt tất cả các phần tử mảng bằngvòng lặp for với chỉ số. Tại mỗi lượt lặp, mình lấy phần tử đang duyệt cộng dồn với biếnsum.
`sum` Có một vấn đề với cách này, đó là việc sử dụng chỉ sốicó thể khiến bạn bị nhầm với một biến trước đó. Dẫn đến những lỗi sai không đoán trước được.
`i` Lúc này,forEachJavaScript xuất hiện giúp bạn giải quyết vấn đề trên.
Một cách đơn giản để triển khai hàm forEach như sau:

```js
function forEach(array, action) {
  for (let i = 0; i < array.length; i++) {
    action(array[i]);
  }
}
```
`function forEach(array, action) {
  for (let i = 0; i < array.length; i++) {
    action(array[i]);
  }
}` HàmforEachtrên nhận đầu vào là một mảngarrayvà một hàmaction- thực hiện hành động với mỗi phần tử của mảngarray[i].
`forEach` `array` `action` `array[i]` 
```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let sum = 0;

forEach(numbers, function (element) {
  sum += element;
});
console.log(sum);
// 55
```
`const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let sum = 0;

forEach(numbers, function (element) {
  sum += element;
});
console.log(sum);
// 55` Mình có thể diễn giải thuật toán trên bằng lới như sau:Với mỗi phần tử trong mảngnumbers, mình lấy nó ra và cộng dồn với biến sum. Kết quả thu được, sẽ ghi ra console.
`numbers` Nếu so sánh với cách làm trước thì cách này rõ ràng là dài hơn. Tuy nhiên, đây chỉ là một ví dụ cơ bản, nên mình sẽ không bàn vềđộ dài, ngắncủa code.
Vấn đề nên quan tâm trước tiên đó là:code-đọc-dễ-hiểu.
Theo quan điểm cá nhân mình, việc sử dụng hàmforEachgiúp code gần giống với ngôn ngữ tự nhiên hơn. Quan điểm của bạn về vấn đề này thế nào?"
604,Tìm hiểu về forEach trong Javascript,Giới thiệu hàm forEach trong JavaScript,"Hàm forEach là gì? Hay vòng lặp forEach trong JavaScript là gì?
Trả lời:forEachlà một phương thức có sẵn củaarray, để duyệt qua mỗi phần tử của mảng và thực hiện một hành động nào đó.

```js
arr.forEach(function callback(currentValue, index, array) {
  // code xử lý
}[, thisArg]);
```
`arr.forEach(function callback(currentValue, index, array) {
  // code xử lý
}[, thisArg]);` `callback` `currentValue` `index` `array` `thisArg` `this` `callback` Chú ý:
`thisArg` `undefined` `callback` 
```js
arr.forEach(function(currentValue, index, array) { // code xử lý
  }[, thisArg]);
```
`arr.forEach(function(currentValue, index, array) { // code xử lý
  }[, thisArg]);` 
```js
function printContentArray(array) {
  array.forEach(function print(element) {
    console.log(element);
  });
}

printContentArray([1, 3, 5]);
```
`function printContentArray(array) {
  array.forEach(function print(element) {
    console.log(element);
  });
}

printContentArray([1, 3, 5]);` Kết quả
1
3
5
`thisArg` 
```js
function Counter() {
      this.sum = 0;
      this.count = 0;

      this.add = function(array) {
        array.forEach(function(item) {
          this.sum += item;
          ++this.count;
        }, this); // this chính là đối tượng tạo new Counter  }
    }

    const obj = new Counter();
    obj.add([2, 5, 9]);

    console.log(obj.count); // 3
    console.log(obj.sum); // 16
```
`function Counter() {
      this.sum = 0;
      this.count = 0;

      this.add = function(array) {
        array.forEach(function(item) {
          this.sum += item;
          ++this.count;
        }, this); // this chính là đối tượng tạo new Counter  }
    }

    const obj = new Counter();
    obj.add([2, 5, 9]);

    console.log(obj.count); // 3
    console.log(obj.sum); // 16`"
605,Tìm hiểu về forEach trong Javascript,"Ưu, nhược điểm của việc sử dụng forEach","Bất cứ thứ gì cũng có hai mặt,forEachJavaScript cũng không ngoại lệ. Sau đây là một số ưu, nhược điểm của phương thứcforEach:
`forEach` `for` `while` Trên đây là một số ưu, nhược điểm của việc sử dụngforEach. Mình không khuyên bạnnên hay không nênsử dụng phương thức này.
`forEach` Đây chỉ đơn giản là một cách thức để duyệt mảng, bạn có thể sử dụng nó hoặc bạn chỉ cần sử dụng vòng lặp.
It's the choice."
606,Tìm hiểu về forEach trong Javascript,Một số từ khóa trong vòng lặp forEach JS,"Khi so sánh với cácvòng lặp khác, ngôn ngữ lập trình khác, bạn sẽ thấy một số từ khóa hay sử dụng trong vòng lặp như:return,breakvàcontinue.
`return` `break` `continue` Câu hỏi đặt ra là liệu những từ khóa này có sử dụng được trong vòng lặp forEach JavaScript hay không? Cách sử dụng của chúng có giống hay không?
Sau đây là câu trả lời.
Từ khóareturndùng để dừng lại một hàm và trả về giá trị từ hàm đó.
`return` Giả sử, bạn cần viết một hàm tìmvị trí của số chẵn đầu tiêntrong một mảng. Nếu không tìm thấy thì trả về giá trị-1.
`-1` Sau đây là code sử dụngvòng lặp forthông thường:

```js
function findFirstEvenIndex(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] % 2 === 0) return i;
  }

  return -1;
}

// Ví dụ
const arr = [1, 2, 3, 4, 5];
const ret = findFirstEvenIndex(arr);

console.log(""ret="", ret);
// ret= 1
```
`function findFirstEvenIndex(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] % 2 === 0) return i;
  }

  return -1;
}

// Ví dụ
const arr = [1, 2, 3, 4, 5];
const ret = findFirstEvenIndex(arr);

console.log(""ret="", ret);
// ret= 1` Chuyển đoạn code trên sang forEach như sau:

```js
function findFirstEvenIndex(arr) {
  arr.forEach(function (item, i) {
    if (arr[i] % 2 === 0) return i;
  });

  return -1;
}

// Ví dụ
const arr = [1, 2, 3, 4, 5];
const ret = findFirstEvenIndex(arr);

console.log(""ret="", -1);
// ret= -1
```
`function findFirstEvenIndex(arr) {
  arr.forEach(function (item, i) {
    if (arr[i] % 2 === 0) return i;
  });

  return -1;
}

// Ví dụ
const arr = [1, 2, 3, 4, 5];
const ret = findFirstEvenIndex(arr);

console.log(""ret="", -1);
// ret= -1` Tại sao kết quả lại là-1?
Tại vì từ khóareturntrong forEach chỉ có tác dụng đểthoát khỏi hàm callbackbên trong forEach mà thôi. Do đó, kết quả của hàm trên là giá trị của câu lệnhreturn -1cuối cùng.
`return` `return -1` Dể giải quyết bài toán này, mình khuyên bạn không nên dùngforEach. Thay vào đó bạn có thể dùng vòng lặp for thông thường như trên, hoặc sử dụng vòng lặpfor...innhư sau:
`forEach` 
```js
function findFirstEvenIndex(arr) {
  for (let i in arr) {
    if (arr[i] % 2 === 0) return i;
  }

  return -1;
}

// Ví dụ
const arr = [1, 2, 3, 4, 5];
const ret = findFirstEvenIndex(arr);

console.log(""ret="", ret);
// ret= 1
```
`function findFirstEvenIndex(arr) {
  for (let i in arr) {
    if (arr[i] % 2 === 0) return i;
  }

  return -1;
}

// Ví dụ
const arr = [1, 2, 3, 4, 5];
const ret = findFirstEvenIndex(arr);

console.log(""ret="", ret);
// ret= 1` Có thể bạn chưa biết
vòng lặpfor...inchỉ nên dùng vớiarray, không nên sử dụng với đối tượngarray-like.
`for...in` `array-like` Từ khóabreakthường dùng để thoát khỏicâu lệnhswitchhoặc thoát khỏi vòng lặp (for,while,do...while,for...in).
`break` `switch` `for` `while` `do...while` `for...in` Ví dụ đoạn code sau dùng để thoát khỏi vòng lặp for khiibằng3:
`i` `3` 
```js
const arr = [1, 2, 3, 4, 5];

for (let i = 0; i < arr.length; i++) {
  if (i === 3) break;
  console.log(""i="", i);
}

/* Kết quả trên console:
    i= 0
    i= 1
    i= 2
    */
```
`const arr = [1, 2, 3, 4, 5];

for (let i = 0; i < arr.length; i++) {
  if (i === 3) break;
  console.log(""i="", i);
}

/* Kết quả trên console:
    i= 0
    i= 1
    i= 2
    */` Nếu sử dụng từ khóabreakvới forEach thì sao?
`break` 
```js
const arr = [1, 2, 3, 4, 5];

    arr.forEach((item, i) => {
      if (i === 3) break;
      console.log(""i="", i);
    });

    /* Kết quả trên console:
    Uncaught SyntaxError: Illegal break statement
    */
```
`const arr = [1, 2, 3, 4, 5];

    arr.forEach((item, i) => {
      if (i === 3) break;
      console.log(""i="", i);
    });

    /* Kết quả trên console:
    Uncaught SyntaxError: Illegal break statement
    */` Đúng vậy, bạn sẽ bị lỗi cú phápIllegal break statementvì từ khóa break là không hợp lệ với forEach JS.
Nghĩa là bạn không thể sử dụng từ khóa break với forEach. Thay vào đó bạn có thể sử dụng vòng lặpfornhư trên hoặc dùng phương thứcarr.some()để thay thế:
`arr.some()` 
```js
const arr = [1, 2, 3, 4, 5];

arr.some(function (item, index) {
  if (index === 3) return true;
  console.log(""i="", index);
});

/* Kết quả trên console:
    i= 0
    i= 1
    i= 2
    */
```
`const arr = [1, 2, 3, 4, 5];

arr.some(function (item, index) {
  if (index === 3) return true;
  console.log(""i="", index);
});

/* Kết quả trên console:
    i= 0
    i= 1
    i= 2
    */` Từ khóacontinuethường dùng đểbỏ qua một lượt lặptrong vòng lặp.
`continue` Ví dụ đoạn code sau dùng để bỏ qua lượt lặp khiibằng3:
`i` `3` 
```js
const arr = [1, 2, 3, 4, 5];

for (let i = 0; i < arr.length; i++) {
  if (i === 3) continue;
  console.log(""i="", i);
}

/* Kết quả trên console:
    i= 0
    i= 1
    i= 2
    i= 4
    */
```
`const arr = [1, 2, 3, 4, 5];

for (let i = 0; i < arr.length; i++) {
  if (i === 3) continue;
  console.log(""i="", i);
}

/* Kết quả trên console:
    i= 0
    i= 1
    i= 2
    i= 4
    */` Nếu chuyển sang dùng vớiforEach:
`forEach` 
```js
const arr = [1, 2, 3, 4, 5];

    arr.forEach(function(item, i) {
      if (i === 3) continue;
      console.log(""i="", i);
    });

    /* Kết quả trên console:
    Uncaught SyntaxError:
    Illegal continue statement: no surrounding iteration statement
    */
```
`const arr = [1, 2, 3, 4, 5];

    arr.forEach(function(item, i) {
      if (i === 3) continue;
      console.log(""i="", i);
    });

    /* Kết quả trên console:
    Uncaught SyntaxError:
    Illegal continue statement: no surrounding iteration statement
    */` Bạn sẽ bị lỗiIllegal continue statement: no surrounding iteration statement. Vì từ khóacontinuekhông hợp lệ với forEach JavaScript.
`continue` Nghĩa là bạn cũng không thể dùngcontinuebên trongforEachđược. Thay vào đó, bạn có thể dùngvòng lặp fornhư trên hoặc sử dụng từ khóareturnnhư sau:
`continue` `forEach` `return` 
```js
const arr = [1, 2, 3, 4, 5];

arr.forEach(function (item, i) {
  if (i === 3) return;
  console.log(""i="", i);
});

/* Kết quả trên console:
    i= 0
    i= 1
    i= 2
    i= 4
    */
```
`const arr = [1, 2, 3, 4, 5];

arr.forEach(function (item, i) {
  if (i === 3) return;
  console.log(""i="", i);
});

/* Kết quả trên console:
    i= 0
    i= 1
    i= 2
    i= 4
    */`"
607,Tìm hiểu về forEach trong Javascript,Từ JavaScript forEach đến các phương thức khác,"Ngoài forEach, JavaScript còn cung cấp một số phương thức khác, tương tự dành cho array. Đó là:entries, every, filter, find, findIndex, keys, map, reduce, reduceRight, some, values.
Trả về một mảng đối tượng mới, chứakey/valuecho mỗi phần tử trong array.

```js
a.entries();
```
`a.entries();` Để duyệt mảng đối tượng mới này, mình sử dụng vòng lặpfor...of:
`for...of` 
```js
const a = [""a"", ""b"", ""c""];
const iterator = a.entries();

for (let e of iterator) {
  console.log(e);
}
/*
 * [0, 'a']
 * [1, 'b']
 * [2, 'c']
 */
```
`const a = [""a"", ""b"", ""c""];
const iterator = a.entries();

for (let e of iterator) {
  console.log(e);
}
/*
 * [0, 'a']
 * [1, 'b']
 * [2, 'c']
 */` Trả vềtruenếu như tất cả các phần tử trong mảng thoả mãn 1 hàm kiểm tra, ngược lại trả vềfalse.
`true` `false` 
```js
arr.every(callback[, thisArg])
```
`arr.every(callback[, thisArg])` Tham số truyền vào giống với hàmforEach.
`forEach` Ví dụ sau trả vềtruenếu tất cả các phần tử trong mảng thoả mãn đều lớn hơn hoặc bằng 10:
`true` 
```js
function isBigEnough(element, index, array) {
  return element >= 10;
}

console.log([12, 5, 8, 130, 44].every(isBigEnough)); // false
console.log([12, 54, 18, 130, 44].every(isBigEnough)); // true
```
`function isBigEnough(element, index, array) {
  return element >= 10;
}

console.log([12, 5, 8, 130, 44].every(isBigEnough)); // false
console.log([12, 54, 18, 130, 44].every(isBigEnough)); // true` Giống như cái tên của nó, phương thức này dùng đểlọc ra các phần tử trong mảng thoả mãn một điều kiệncho trước và trả về một mảng mới chứa những phần tử đó.

```js
let newArray = arr.filter(callback[, thisArg])
```
`let newArray = arr.filter(callback[, thisArg])` Tham số truyền vào giống với hàmforEach.
`forEach` Ví dụ sau lọc ra những phần tử trong mảng có giá trị lớn hơn hoặc bằng 10:

```js
function isBigEnough(value) {
  return value >= 10;
}

const filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
console.log(filtered);
// [12, 130, 44]
```
`function isBigEnough(value) {
  return value >= 10;
}

const filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
console.log(filtered);
// [12, 130, 44]` Trả về giá trị củaphần tử đầu tiêntrong mảng thoả mãn điều kiện cho trước, nếu không tìm thấy thì trả vềundefined.
`undefined` 
```js
let var1 = arr.find(callback[, thisArg])
```
`let var1 = arr.find(callback[, thisArg])` Tham số truyền vào cũng giống như hàmforEach.
`forEach` Ví dụ sau tìm ra mộtobjectvớinamethoả mãn điều kiện cho trước:
`name` 
```js
const inventory = [
  { name: ""apples"", from: ""usa"" },
  { name: ""bananas"", from: ""vietnam"" },
  { name: ""cherries"", from: ""usa"" },
  { name: ""cherries"", from: ""china"" },
];

function findCherries(fruit) {
  return fruit.name === ""cherries"";
}

console.log(inventory.find(findCherries));
// {name: 'cherries', from: 'usa'}
```
`const inventory = [
  { name: ""apples"", from: ""usa"" },
  { name: ""bananas"", from: ""vietnam"" },
  { name: ""cherries"", from: ""usa"" },
  { name: ""cherries"", from: ""china"" },
];

function findCherries(fruit) {
  return fruit.name === ""cherries"";
}

console.log(inventory.find(findCherries));
// {name: 'cherries', from: 'usa'}` Trả vềchỉ số đầu tiêncủa phần tử thoả mãn điều kiện cho trước, ngược lại trả về-1.
`-1` 
```js
let id = arr.findIndex(callback[, thisArg])
```
`let id = arr.findIndex(callback[, thisArg])` Tham số truyền vào cũng giống như hàmforEach.
`forEach` Ví dụ sau tìm ra chỉ số object vớinamethoả mãn điều kiện cho trước:
`name` 
```js
const inventory = [
  { name: ""apples"", from: ""usa"" },
  { name: ""bananas"", from: ""vietnam"" },
  { name: ""cherries"", from: ""usa"" },
  { name: ""cherries"", from: ""china"" },
];

function findCherries(fruit) {
  return fruit.name === ""cherries"";
}

console.log(inventory.findIndex(findCherries));
// 2
```
`const inventory = [
  { name: ""apples"", from: ""usa"" },
  { name: ""bananas"", from: ""vietnam"" },
  { name: ""cherries"", from: ""usa"" },
  { name: ""cherries"", from: ""china"" },
];

function findCherries(fruit) {
  return fruit.name === ""cherries"";
}

console.log(inventory.findIndex(findCherries));
// 2` Trả về mảng mới với mỗi phần tử là kết quả của việc gọi hàm callback với mỗi phần tử của mảng ban đầu.

```js
let new_array = arr.map(callback[, thisArg])
```
`let new_array = arr.map(callback[, thisArg])` Tham số truyền vào cũng giống như hàmforEachJavaScript.
`forEach` Ví dụ sau trả về mảng mới, mà mỗi phần tử của mảng mới làcăn bậc haicủa phần tử tương ứng trong mảng ban đầu:

```js
const numbers = [1, 4, 9];
const roots = numbers.map(Math.sqrt);

console.log(roots); // [1, 2, 3]
console.log(numbers); // [1, 4, 9]
```
`const numbers = [1, 4, 9];
const roots = numbers.map(Math.sqrt);

console.log(roots); // [1, 2, 3]
console.log(numbers); // [1, 4, 9]` Những phương thức còn lại bạn có thể tham khảo thêm tại bài viết:Các phương thức của mảng trong JavaScript."
608,Tìm hiểu về forEach trong Javascript,Thực hành,"Cho một mảng hai chiều, hãy chuyển mảng đó thành mảng một chiều, ví dụ:

```js
let arrays = [[1, 2, 3], [4, 5], [6]];
/*
 * Code xử lý
 *
 * Đáp án: [1, 2, 3, 4, 5, 6]
 */
```
`let arrays = [[1, 2, 3], [4, 5], [6]];
/*
 * Code xử lý
 *
 * Đáp án: [1, 2, 3, 4, 5, 6]
 */` ► Sử dụng phương thứcarr.reduce()vàarr.concat().
`arr.reduce()` `arr.concat()` Đáp án

```js
const arrays = [[1, 2, 3], [4, 5], [6]];
const newArray = arrays.reduce(function (a, b) {
  return a.concat(b);
});
console.log(newArray);
// => [1, 2, 3, 4, 5, 6]
```
`const arrays = [[1, 2, 3], [4, 5], [6]];
const newArray = arrays.reduce(function (a, b) {
  return a.concat(b);
});
console.log(newArray);
// => [1, 2, 3, 4, 5, 6]` ► Sử dụng vòng lặp for, while thông thường.

```js
const arrays = [[1, 2, 3], [4, 5], [6]];
const newArray = [];
for (let i = 0; i < arrays.length; i++) {
  const subArray = arrays[i];
  for (let j = 0; j < subArray.length; j++) newArray.push(subArray[j]);
}
console.log(newArray);
// => [1, 2, 3, 4, 5, 6]
```
`const arrays = [[1, 2, 3], [4, 5], [6]];
const newArray = [];
for (let i = 0; i < arrays.length; i++) {
  const subArray = arrays[i];
  for (let j = 0; j < subArray.length; j++) newArray.push(subArray[j]);
}
console.log(newArray);
// => [1, 2, 3, 4, 5, 6]` Hãy viết hàmevery()vàsome()thoả mãn:
`every()` `some()` `every(arr, func)` `true` `arr` `func` `true` `false` `some(arr, func)` `true` `arr` `func` `true` `false` 
```js
console.log(every([NaN, NaN, NaN], isNaN));
// true
console.log(every([NaN, NaN, 4], isNaN));
// false
console.log(some([NaN, 3, 4], isNaN));
// true
console.log(some([2, 3, 4], isNaN));
// false
```
`console.log(every([NaN, NaN, NaN], isNaN));
// true
console.log(every([NaN, NaN, 4], isNaN));
// false
console.log(some([NaN, 3, 4], isNaN));
// true
console.log(some([2, 3, 4], isNaN));
// false` Xem đáp án:

```js
function every(array, action) {
  for (let i = 0; i < array.length; i++) if (!action(array[i])) return false;
  return true;
}

console.log(every([NaN, NaN, NaN], isNaN));
// => true
console.log(every([NaN, NaN, 4], isNaN));
// => false
```
`function every(array, action) {
  for (let i = 0; i < array.length; i++) if (!action(array[i])) return false;
  return true;
}

console.log(every([NaN, NaN, NaN], isNaN));
// => true
console.log(every([NaN, NaN, 4], isNaN));
// => false` 
```js
function some(array, action) {
  for (let i = 0; i < array.length; i++) if (action(array[i])) return true;
  return false;
}

console.log(some([NaN, 3, 4], isNaN));
// => true
console.log(some([2, 3, 4], isNaN));
// => false
```
`function some(array, action) {
  for (let i = 0; i < array.length; i++) if (action(array[i])) return true;
  return false;
}

console.log(some([NaN, 3, 4], isNaN));
// => true
console.log(some([2, 3, 4], isNaN));
// => false`"
609,Tìm hiểu về forEach trong Javascript,Tổng kết,"Trên đây là một số kiến thức cơ bản về forEach trong JavaScript.
Hy vọng qua bài viết này bạn hiểu được forEach JavaScript là gì? Cách sử dụng forEach và khi nào nên sử dụng forEach JS.
Tham khảo:Higher-Order Functions"
610,Toán tử logic trong Javascript,Giới thiệu,"JavaScript có bốn toán tử logic là: OR||, AND&&, NOT!và ""Nullish Coalescing""??. Trong đó, ba toán tử OR, AND và NOT là ba toán tử logic cơ bản mà hầu như ngôn ngữ lập trình nào cũng có.
`||` `&&` `!` `??` Vì vậy, bài viết này sẽ tập trung vào tìm hiểu về ba toán tử OR, AND và NOT. Còn toán tử ""Nullish Coalescing"" sẽ được giới thiệu ở bài viết sau."
611,Toán tử logic trong Javascript,Toán tử logic là gì?,"Toán tử logiclàtoán tửkết nối hai hay nhiều biểu thức, dùng để kiểm tra mối quan hệ logic giữa các biểu thức. Kết quả cuối cùng phụ thuộc vào giá trị của từng biểu thức và loại toán tử logic.
Theo định nghĩa thông thường, toán tử logic chỉ áp dụng chokiểu dữ liệu booleanvà kết quả trả về cũng là giá trịboolean.
Nhưng với JavaScript thì khác, toán tử logic áp dụng chobất kỳ kiểu dữ liệu nàovà kết quả trả về cũng làbất kỳ kiểu dữ liệu nào. Để làm được điều này, các toán hạng tham gia đều được chuyển về kiểu dữ liệu boolean để kiểm tra tính logic.
Trước khi tìm hiểu kỹ hơn về các toán tử logic, bạn cần biết hai khái niệm:truthyvàfalsy."
612,Toán tử logic trong Javascript,Truthy và falsy trong JavaScript là gì?,"Như bạn đã biết thì kiểu dữ liệu boolean chỉ có hai giá trị là:truevàfalse. Vì vậy, khi một giá trị được chuyển về kiểu dữ liệu boolean, kết quả sẽ làtruehoặcfalse.
`true` `false` `true` `false` Những giá trị mà khi chuyển về kiểu dữ liệu boolean ra giá trịtruegọi làtruthy.
`true` Tương tự, những giá trị mà khi chuyển về kiểu dữ liệu boolean ra giá trịfalsegọi làfalsy.
`false` Để chuyển một giá trị về kiểu dữ liệu boolean, bạn có thể dùng hàmBoolean().
`Boolean()` Ví dụ các giá trịtruthy:

```js
console.log(Boolean(true)); // true (giá trị true)
console.log(Boolean(1)); // true (số nguyên dương)
console.log(Boolean(-1)); // true (số nguyên âm)
console.log(Boolean(100n)); // true (số BigInt khác 0)
console.log(Boolean(1.5)); // true (số thực dương)
console.log(Boolean(-1.5)); // true (số thực âm)
console.log(Boolean(""0"")); // true (string khác rỗng)
console.log(Boolean(""abc"")); // true (string khác rỗng)
console.log(Boolean([])); // true (mảng - array)
console.log(Boolean({ x: 1 })); // true (đối tượng - object)
console.log(Boolean(Infinity)); // true (số dương vô cùng)
console.log(Boolean(-Infinity)); // true (số âm vô cùng)
console.log(Boolean(alert)); // true (hàm)
```
`console.log(Boolean(true)); // true (giá trị true)
console.log(Boolean(1)); // true (số nguyên dương)
console.log(Boolean(-1)); // true (số nguyên âm)
console.log(Boolean(100n)); // true (số BigInt khác 0)
console.log(Boolean(1.5)); // true (số thực dương)
console.log(Boolean(-1.5)); // true (số thực âm)
console.log(Boolean(""0"")); // true (string khác rỗng)
console.log(Boolean(""abc"")); // true (string khác rỗng)
console.log(Boolean([])); // true (mảng - array)
console.log(Boolean({ x: 1 })); // true (đối tượng - object)
console.log(Boolean(Infinity)); // true (số dương vô cùng)
console.log(Boolean(-Infinity)); // true (số âm vô cùng)
console.log(Boolean(alert)); // true (hàm)` Ví dụ về các giá trịfalsy:

```js
console.log(Boolean(false)); // false
console.log(Boolean(0)); // false
console.log(Boolean("""")); // false (string rỗng)
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(NaN)); // false
```
`console.log(Boolean(false)); // false
console.log(Boolean(0)); // false
console.log(Boolean("""")); // false (string rỗng)
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(NaN)); // false`"
613,Toán tử logic trong Javascript,Các toán tử logic trong JavaScript,"Sau đây là những kiến thức cơ bản cần biết về toán tử logic OR (||), AND (&&) và NOT (!) trong JavaScript.
`||` `&&` `!` `||` Toán tử OR trong JavaScript kí hiệu là||(tạm dịch là toán tử ""hoặc"").
`||` Trong lập trình nói chung, toán tử OR trả về giá trịtruenếu có ít nhất một toán hạng làtrue, ngược lại sẽ trả vềfalse.
`true` `true` `false` 
```js
console.log(true || true); // true
console.log(true || false); // true
console.log(false || true); // true
console.log(false || false); // false
```
`console.log(true || true); // true
console.log(true || false); // true
console.log(false || true); // true
console.log(false || false); // false` Ngoài ra, bạn cũng có thể kết hợp nhiều toán tử OR:

```js
console.log(true || true || true); // true
console.log(true || false || true); // true
console.log(false || true || false); // true
console.log(false || false || false); // false
```
`console.log(true || true || true); // true
console.log(true || false || true); // true
console.log(false || true || false); // true
console.log(false || false || false); // false` Đó là với logic thông thông thường, còn JavaScript thì phức tạp hơn một chút.
`||` Toán tử OR trong JavaScript sẽ tìm và trả về giá trịtruthyđầu tiên. Nếu không có giá trịtruthynào thì kết quả sẽ là giá trị của toán hạng cuối cùng.
Quá trình xử lý như sau:
`true` `false` 
```js
console.log(1 || 0); // 1 (giá trị truthy đầu tiên là 1)
console.log(null || 2); // 2 (giá trị truthy đầu tiên là 2)
console.log("""" || undefined || 0 || 10); // 10 (giá trị truthy đầu tiên là 10)
console.log(null || 100 || 5 || undefined); // 100 (giá trị truthy đầu tiên là 100)
console.log("""" || 0 || null); // null (không có giá trị truthy, trả về giá trị cuối cùng)
```
`console.log(1 || 0); // 1 (giá trị truthy đầu tiên là 1)
console.log(null || 2); // 2 (giá trị truthy đầu tiên là 2)
console.log("""" || undefined || 0 || 10); // 10 (giá trị truthy đầu tiên là 10)
console.log(null || 100 || 5 || undefined); // 100 (giá trị truthy đầu tiên là 100)
console.log("""" || 0 || null); // null (không có giá trị truthy, trả về giá trị cuối cùng)` `if` Nếu bạn chưa biết câu lệnhiflà gì, thì đơn giản câu lệnhifdùng để kiểm tra điều kiện, nếuđúngsẽ thực hiện một hành động (mình sẽ có bài viết chi tiết vềifsau).
`if` `if` `if` 
```js
if (/* true */) {
      // làm gì đó ở đây
    }
```
`if (/* true */) {
      // làm gì đó ở đây
    }` 
```js
const a = 1;
const b = 0;

if (a || b) {
  console.log(""truthy!""); // câu lệnh này được thực hiện vì 1 || 0 trả về 1 - là truthy.
}
```
`const a = 1;
const b = 0;

if (a || b) {
  console.log(""truthy!""); // câu lệnh này được thực hiện vì 1 || 0 trả về 1 - là truthy.
}` Ví dụ kết hợp với toán tử so sánh

```js
const hour = 20;

if (hour < 9 || hour > 17) {
  console.log(""Ngoài giờ làm việc""); // câu lệnh này được thực hiện
}
```
`const hour = 20;

if (hour < 9 || hour > 17) {
  console.log(""Ngoài giờ làm việc""); // câu lệnh này được thực hiện
}` Có thể bạn chưa biết
toán tử so sánh có độ ưu tiên cao hơn toán tử logic, nên toán tử so sánh được thực hiện trước toán tử OR.
Vìhourbằng20nênhour < 9làfalsevàhour > 17làtrue. Nghĩa làhour < 9 || hour > 17có thể quy đổi thànhfalse || true. Suy ra, kết quả cuối cùng làtrue.
`hour` `20` `hour < 9` `false` `hour > 17` `true` `hour < 9 || hour > 17` `false || true` `true` Do đó, câu lệnhconsole.log(""Ngoài giờ làm việc"")được thực hiện.
`console.log(""Ngoài giờ làm việc"")` Ví dụ bài toán hiển thị tên người dùng trên trang web, biết thông tin người dùng có hai trường liên quan đến tên làfullNamevànickName.
`fullName` `nickName` Ưu tiên hiển thị tênfullNametrước. NếufullNamerỗng thì hiển thịnickName. NếunickNamecũng rỗng thì hiển thị ""Người dùng ẩn danh"".
`fullName` `fullName` `nickName` `nickName` Với bài toán này, bạn có thể sử dụng toán tử OR như sau:

```js
const fullName = """";
const nickName = ""jsDev"";

const displayName = fullName || nickName || ""Người dùng ẩn danh"";
console.log(displayName); // jsDev
```
`const fullName = """";
const nickName = ""jsDev"";

const displayName = fullName || nickName || ""Người dùng ẩn danh"";
console.log(displayName); // jsDev` Đặc điểm của toán tử OR trong JavaScript là sẽ xử lý các toán hạng cho đến khi tìm được giá trịtruthymới thôi.
Nhưng bạn cần chú ý,toán hạngở đây không chỉ là giá trị, mà còn có thể là một biểu thức gán, hàm hoặc một câu lệnh,...
Ví dụ:

```js
true || console.log(""Câu lệnh này không được thực hiện""); // (1)
false || console.log(""Câu lệnh này được thực hiện""); // (2)
```
`true || console.log(""Câu lệnh này không được thực hiện""); // (1)
false || console.log(""Câu lệnh này được thực hiện""); // (2)` Câu lệnhconsole.log(1) không được thực hiện. Vì toán tử OR gặp giá trịtrueđầu tiên, sẽ dừng lại và trả về giá trịtrueluôn, không xử lý gì toán hạng tiếp theo.
`console.log` `true` `true` Câu lệnhconsole.log(2) được thực hiện. Vì toán tử OR gặp giá trịfalseđầu tiên. Đây là giá trịfalsynên toán tử OR tiếp tục xử lý toán hạng thứ hai.
`console.log` `false` Vì vậy, câu lệnhconsole.log(""Câu lệnh này được thực hiện"")được thực hiện.
`console.log(""Câu lệnh này được thực hiện"")` 💡 Tổng quát, tính năng này được dùng để thực hiện một hành động nếu điều kiện bên trái làfalsy.
Tuy nhiên để dễ theo dõi code hơn, mình khuyên bạn nên sử dụngifthay vì dùng toán tử OR làm ""short-circuit evaluation"".
`if` `&&` Toán tử AND trong JavaScript kí hiệu là&&(tạm dịch là toán tử ""và"").
`&&` Trong lập trình nói chung, toán tử AND trả về giá trịtruenếu cả hai toán hạng làtrue, ngược lại sẽ trả vềfalse.
`true` `true` `false` 
```js
console.log(true && true); // true
console.log(true && false); // false
console.log(false && true); // false
console.log(false && false); // false
```
`console.log(true && true); // true
console.log(true && false); // false
console.log(false && true); // false
console.log(false && false); // false` Ngoài ra, bạn cũng có thể kết hợp nhiều toán tử AND:

```js
console.log(true && true && true); // true
console.log(true && false && true); // false
console.log(false && true && false); // false
console.log(false && false && false); // false
```
`console.log(true && true && true); // true
console.log(true && false && true); // false
console.log(false && true && false); // false
console.log(false && false && false); // false` `&&` Toán tử AND trong JavaScript sẽ tìm và trả về giá trịfalsyđầu tiên. Nếu không có giá trịfalsynào thì kết quả sẽ là giá trị của toán hạng cuối cùng.
Quá trình xử lý như sau:
`false` `true` Ví dụ:

```js
console.log(1 && 0); // 0 (giá trị falsy đầu tiên là 0)
console.log(null && 2); // null (giá trị falsy đầu tiên là null)
console.log(10 && """" && undefined && 0); // """" (giá trị falsy đầu tiên là """")
console.log(""n"" && undefined && 10); // undefined (giá trị falsy đầu tiên là undefined)
console.log(10 && ""a""); // ""a"" (không có giá trị falsy, trả về giá trị cuối cùng)
```
`console.log(1 && 0); // 0 (giá trị falsy đầu tiên là 0)
console.log(null && 2); // null (giá trị falsy đầu tiên là null)
console.log(10 && """" && undefined && 0); // """" (giá trị falsy đầu tiên là """")
console.log(""n"" && undefined && 10); // undefined (giá trị falsy đầu tiên là undefined)
console.log(10 && ""a""); // ""a"" (không có giá trị falsy, trả về giá trị cuối cùng)` `if` Tương tự như toán tử OR ở trên, toán tử AND cũng hay dùng với câu lệnhif
`if` 
```js
const a = 1;
const b = ""hello"";

if (a && b) {
  console.log(""truthy!"");
  // câu lệnh trên được thực hiện vì 1 && ""hello"" trả về ""hello"" - là truthy.
}
```
`const a = 1;
const b = ""hello"";

if (a && b) {
  console.log(""truthy!"");
  // câu lệnh trên được thực hiện vì 1 && ""hello"" trả về ""hello"" - là truthy.
}` Ví dụ kết hợp toán tử so sánh

```js
const hour = 12;

if (hour >= 9 && hour <= 17) {
  console.log(""Trong giờ làm việc""); // câu lệnh này được thực hiện
}
```
`const hour = 12;

if (hour >= 9 && hour <= 17) {
  console.log(""Trong giờ làm việc""); // câu lệnh này được thực hiện
}` Có thể bạn chưa biết
toán tử so sánh có độ ưu tiên cao hơn toán tử logic, nên toán tử so sánh được thực hiện trước toán tử AND.
Vìhourbằng12nênhour >= 9làtruevàhour <= 17làtrue. Nghĩa làhour >= 9 && hour <= 17có thể quy đổi thànhtrue && true. Suy ra, kết quả cuối cùng làtrue.
`hour` `12` `hour >= 9` `true` `hour <= 17` `true` `hour >= 9 && hour <= 17` `true && true` `true` Do đó, câu lệnhconsole.log(""Trong giờ làm việc"")được thực hiện.
`console.log(""Trong giờ làm việc"")` Tương tự như toán tử OR, toán tử AND cũng có thể dùng cho ""short-circuit evaluation"".
Vì đặc điểm của toán tử AND trong JavaScript là sẽ xử lý các toán hạng cho đến khi tìm được giá trịfalsymới thôi.

```js
true && console.log(""Câu lệnh này được thực hiện""); // (1)
false && console.log(""Câu lệnh này không được thực hiện""); // (2)
```
`true && console.log(""Câu lệnh này được thực hiện""); // (1)
false && console.log(""Câu lệnh này không được thực hiện""); // (2)` Câu lệnhconsole.log(1) được thực hiện. Vì toán tử AND gặp giá trịtrueđầu tiên. Đây là giá trịtruthynên toán tử AND tiếp tục xử lý toán hạng thứ hai. Vì vậy, câu lệnhconsole.log(1) được thực hiện.
`console.log` `true` `console.log` Câu lệnhconsole.log(2) không được thực hiện. Vì toán tử AND gặp giá trịfalsyđầu tiên. Nên dừng lại luôn và không xử lý toán tử thứ hai.
`console.log` 💡 Tổng quát, tính năng này được dùng để thực hiện một hành động nếu điều kiện bên trái làtruthy.
Để dễ theo dõi code hơn thì mình khuyên bạn nên sử dụngifthay vì dùng toán tử AND làm ""short-circuit evaluation"".
`if` `!` Toán tử NOT trong JavaScript kí hiệu là!(tạm dịch là toán tử ""phủ định"").
`!` Trong lập trình nói chung, toán tử NOT trả về giá trịtruenếu toán hạng làfalsevà trả vềfalsenếu toán hạng làtrue.
`true` `false` `false` `true` Vì là toán tử một ngôi, nên toán tử NOT chỉ chứa một toán hạng, ví dụ:

```js
console.log(!true); // false
console.log(!false); // true
```
`console.log(!true); // false
console.log(!false); // true` Quá trình xử lý của toán tử NOT như sau:
`true` `false` 
```js
console.log(!""hello""); // false (""hello"" là truthy)
console.log(!100); // false (100 là truthy)
console.log(!""""); // true ("""" là falsy)
console.log(!0); // true (0 là falsy)
console.log(!null); // true (null là falsy)
console.log(!undefined); // true (undefined là falsy)
```
`console.log(!""hello""); // false (""hello"" là truthy)
console.log(!100); // false (100 là truthy)
console.log(!""""); // true ("""" là falsy)
console.log(!0); // true (0 là falsy)
console.log(!null); // true (null là falsy)
console.log(!undefined); // true (undefined là falsy)` Nếu bạn sử dụng hai toán tử NOT!!thì nó sẽ có tác dụng chuyển đổi kiểu dữ liệu về giá trị boolean, giống hàmBoolean()mà mình đã nhắc ở đầu.
`!!` `Boolean()` 
```js
console.log(!!""hello""); // true
console.log(!!null); // false
```
`console.log(!!""hello""); // true
console.log(!!null); // false` Bởi vì toán tử NOT đầu tiên!đã chuyển giá trị về boolean rồi trả về giá trị ngược lại. Toán tử NOT thứ hai!lại trả về giá trị ngược lại một lần nữa. Kết hợp lại thì sẽ tương đương với chuyển giá trị ban đầu về boolean.
`!` `!` Hay nói gắn gọn lại là: ""phủ định của phủ định thành khẳng định"".
Nếu so sánh với các toán tử đã học nhưtoán tử số họcvàtoán tử so sánhthì toán tử logic trong JavaScript có độ ưu tiên thấp hơn.
Nếu so sánh thứ tự ưu tiên của các toán tử logic trong JavaScript với nhau thì toán tử NOT (!) có độ ưu tiên cao nhất. Xếp thứ hai là toán tử AND (&&). Và cuối cùng là toán tử OR (||).
`!` `&&` `||` 
```js
console.log(1 + 2 || (!""javascript"" && 4 > 5));
```
`console.log(1 + 2 || (!""javascript"" && 4 > 5));` Dựa theo độ ưu tiên thì quá trình thực hiện sẽ như sau (mình sử dụng cặp dấu ngoặc đơn()để biểu thị phần được xử lý trước):
`()` 
```js
1 + 2 || !""javascript"" && 4 > 5;
    -> (1 + 2) || !""javascript"" && 4 > 5; // toán tử số học có độ ưu tiên cao nhất
    -> 3 || !""javascript"" && 4 > 5;
    -> 3 || !""javascript"" && (4 > 5); // toán tử so sánh ưu tiên cao hơn toán tử logic
    -> 3 || !""javascript"" && false;
    -> 3 || (!""javascript"") && false; // toán tử NOT có độ ưu tiên cao hơn AND và OR
    -> 3 || false && false;
    -> 3 || (false && false); // toán tử AND có độ ưu tiên cao hơn OR
    -> 3 || false;
    -> 3 // giá trị truthy đầu tiên là 3
```
`1 + 2 || !""javascript"" && 4 > 5;
    -> (1 + 2) || !""javascript"" && 4 > 5; // toán tử số học có độ ưu tiên cao nhất
    -> 3 || !""javascript"" && 4 > 5;
    -> 3 || !""javascript"" && (4 > 5); // toán tử so sánh ưu tiên cao hơn toán tử logic
    -> 3 || !""javascript"" && false;
    -> 3 || (!""javascript"") && false; // toán tử NOT có độ ưu tiên cao hơn AND và OR
    -> 3 || false && false;
    -> 3 || (false && false); // toán tử AND có độ ưu tiên cao hơn OR
    -> 3 || false;
    -> 3 // giá trị truthy đầu tiên là 3`"
614,Toán tử logic trong Javascript,Tổng kết,"Sau đây là một số kiến thức cơ bản cần nhớ về các toán tử logic trong JavaScript:
`||` `&&` `!` `??` `true` `false`"
615,Toán tử logic trong Javascript,Thực hành,"Kết quả của các biểu thức sau là gì?

```js
console.log("""" || ""0"" || 99); // (1)
console.log(null || 0 || NaN); // (2)
console.log(100n && """" && true); // (3)
console.log(false && null && """"); // (4)
console.log(3 > ""0"" && null == 1); // (5)
console.log(null == undefined || 0 === ""0""); // (6)
console.log(!""hello"" && ""apple"" < ""appLE""); // (7)
```
`console.log("""" || ""0"" || 99); // (1)
console.log(null || 0 || NaN); // (2)
console.log(100n && """" && true); // (3)
console.log(false && null && """"); // (4)
console.log(3 > ""0"" && null == 1); // (5)
console.log(null == undefined || 0 === ""0""); // (6)
console.log(!""hello"" && ""apple"" < ""appLE""); // (7)` Xem đáp án

```js
console.log("""" || ""0"" || 99); // ""0"" (1)
console.log(null || 0 || NaN); // NaN (2)
console.log(100n && """" && true); // """" (3)
console.log(false && null && """"); // false (4)
console.log(3 > ""0"" && null == 1); // false (5)
console.log(null == undefined || 0 === ""0""); // true (6)
console.log(!!""hello"" && ""apple"" < ""appLE""); // false (7)
```
`console.log("""" || ""0"" || 99); // ""0"" (1)
console.log(null || 0 || NaN); // NaN (2)
console.log(100n && """" && true); // """" (3)
console.log(false && null && """"); // false (4)
console.log(3 > ""0"" && null == 1); // false (5)
console.log(null == undefined || 0 === ""0""); // true (6)
console.log(!!""hello"" && ""apple"" < ""appLE""); // false (7)` Giải thích:
`""0""` `NaN` `""""` `3 > ""0""` `true` `""0""` `0` `null == 1` `false` `null` `undefined` `true && false` `false` `null == undefined` `true` `0 === ""0""` `false` `true || false` `true` `""apple"" < ""appLE""` `""app""` `""l""` `""L""` `""apple"" < ""appLE""` `!!""hello""` `!!""hello""` `true` `true && false` `false`"
616,Toán tử ?? trong JavaScript,Giới thiệu,"Toán tử Nullish Coalescing ký hiệu??(toán tử hai dấu chấm hỏi) là toán tử mới trong JavaScript.
`??` Sau đây, mình sẽ cùng tìm hiểu xem toán tử Nullish Coalescing là gì và ứng dụng của toán tử này trong JavaScript như thế nào."
617,Toán tử ?? trong JavaScript,Toán tử Nullish Coalescing là gì?,"Toán tử Nullish Coalescing là toán tử hai ngôia ?? b, với định nghĩa là:
`a ?? b` `a` `null` `undefined` `a ?? b` `a` `a` `null` `undefined` `a ?? b` `b` 
```js
result = a ?? b;
```
`result = a ?? b;` Nếu a khácnullvàundefinedthìrsẽ bằnga. Ngược lại,rbằngb.
`null` `undefined` `r` `a` `r` `b` Đọc đến đây chắc bạn có liên tưởng đếntoán tử?. Vì mình có thể viết lạiresult = a ?? bbằng cách sử dụng toán tử?như sau:
`?` `result = a ?? b` `?` 
```js
result = a !== null && a !== undefined ? a : b;
```
`result = a !== null && a !== undefined ? a : b;` Tuy nhiên, nếu so sánh đoạn code này với đoạn code trên (sử dụng toán tử??) thì rõ ràng việc sử dụng toán tử??là ngắn gọn hơn.
`??` `??`"
618,Toán tử ?? trong JavaScript,Ứng dụng của toán tử Nullish Coalescing,"Toán tử Nullish Coalescing thường dùng để cung cấp giá trị mặc định cho một biến có thểnullhoặcundefined.
`null` `undefined` Ví dụ với biến có giá trịundefined:
`undefined` 
```js
let name;

console.log(name ?? ""Người dùng ẩn danh""); // Người dùng ẩn danh
```
`let name;

console.log(name ?? ""Người dùng ẩn danh""); // Người dùng ẩn danh` Ví dụ với biến có giá trị khácundefinedvànull:
`undefined` `null` 
```js
let name = ""jsDev"";

console.log(name ?? ""Người dùng ẩn danh""); // jsDev
```
`let name = ""jsDev"";

console.log(name ?? ""Người dùng ẩn danh""); // jsDev` Ngoài ra, bạn có thể sử dụng nhiều toán tử??liên tiếp nhau:
`??` 
```js
let fullName;
let nickName = ""jsDev"";

const displayName = fullName ?? nickName ?? ""Người dùng ẩn danh"";
console.log(displayName); // jsDev
```
`let fullName;
let nickName = ""jsDev"";

const displayName = fullName ?? nickName ?? ""Người dùng ẩn danh"";
console.log(displayName); // jsDev`"
619,Toán tử ?? trong JavaScript,So sánh toán tử??và toán tử||,"`??` `||` Trong bài viếttoán tử logic trong JavaScript, mình cũng đã giới thiệu về toán tử||với ứng dụng tương tự như ví dụ trên:
`||` 
```js
let fullName;
let nickName = ""jsDev"";

const displayName = fullName || nickName || ""Người dùng ẩn danh"";
console.log(displayName); // jsDev
```
`let fullName;
let nickName = ""jsDev"";

const displayName = fullName || nickName || ""Người dùng ẩn danh"";
console.log(displayName); // jsDev` Bạn thấy rằng kết quả là như nhau.
Vậy toán tử??khác với toán tử||như thế nào?
`??` `||` Cụ thể:
`??` `null` `undefined` `||` Hay nói cách khác, toán tử||không phân biệt được các giá trịfalse,0, string rỗng""""vớinull/undefined. Vì chúng đều là các giá trịfalsy.
`||` `false` `0` `""""` `null` `undefined` Đôi khi bạn chỉ muốn sử dụng giá trị mặc định khi biến có giá trịnullhoặcundefined, ví dụ:
`null` `undefined` 
```js
let length = 0;

console.log(length || 10); // 10
console.log(length ?? 10); // 0
```
`let length = 0;

console.log(length || 10); // 10
console.log(length ?? 10); // 0` Trong ví dụ trên:
`length = 0` `length` `console.log` `10` `length = 0` `length` `null` `undefined` `console.log` `0` 💡 Ví dụ trên sử dụng toán tử??phù hợp hơn. Vì thực tế, số0cũng là giá trị hợp lệ đối với biếnlength.
`??` `0` `length`"
620,Toán tử ?? trong JavaScript,Thứ tự ưu tiên của toán tử??,"`??` Toán tử??cóthứ tự ưu tiêngần tương đương (thấp hơn một chút) so với toán tử||.
`??` `||` Nghĩa là toán tử Nullish Coalescing được thực hiện trước toán tử gán=, toán tử dấu hỏi?và thực hiện sau so với các toán tử khác, như toán tử số học+,*,...
`=` `?` `+` `*` Nếu bạn không chắc chắn về thứ tự ưu tiên thì nên sử dụng cặp dấu ngoặc đơn(), ví dụ:
`()` 
```js
let x;
let y;

const sum = (x ?? 2) * (y ?? 3); // => 2 * 3console.log(sum); // 6
```
`let x;
let y;

const sum = (x ?? 2) * (y ?? 3); // => 2 * 3console.log(sum); // 6` Trong ví dụ trên, nếu bạn không sử dụng cặp dấu ngoặc đơn()thì kết quả sẽ khác:
`()` 
```js
let x;
let y;

const sum = x ?? 2 * y ?? 3;
console.log(sum); // NaN
```
`let x;
let y;

const sum = x ?? 2 * y ?? 3;
console.log(sum); // NaN` Bởi vì, toán tử*có độ ưu tiên cao hơn toán tử??nên phép tính2 * yđược thực hiện trước. Màycó giá trịundefinednên2 * ybằngNaN.
`*` `??` `2 * y` `y` `undefined` `2 * y` `NaN` MàNaNlại khácnullvàundefinednên kết quả củax ?? NaN ?? 3làNaN.
`NaN` `null` `undefined` `x ?? NaN ?? 3` `NaN`"
621,Toán tử ?? trong JavaScript,Sử dụng toán tử??cùng với toán tử&&hoặc||,"`??` `&&` `||` Vì lý do an toàn nên JavaScript cấm sử dụng toán tử??với toán tử&&hoặc||- trừ khi sử dụng cùng với cặp dấu ngoặc đơn().
`??` `&&` `||` `()` Ví dụ sau đây sẽ bị lỗi:

```js
let x = 1 && 2 ?? 3; // Uncaught SyntaxError: Unexpected token '??'
```
`let x = 1 && 2 ?? 3; // Uncaught SyntaxError: Unexpected token '??'` Để tránh lỗi, bạn phải sử dụng cặp dấu ngoặc đơn():
`()` 
```js
let x = (1 && 2) ?? 3; // => 2 ?? 3
console.log(x); // 2

let y = 1 && (2 ?? 3); // => 1 && 2
console.log(y); // 2
```
`let x = (1 && 2) ?? 3; // => 2 ?? 3
console.log(x); // 2

let y = 1 && (2 ?? 3); // => 1 && 2
console.log(y); // 2`"
622,Toán tử ?? trong JavaScript,Tổng kết,"Toán tử Nullish Coalescing??là toán tử hai ngôi, dùng để trả về giá trị khácnullvàundefinedđầu tiên.
`??` `null` `undefined` Toán tử??thường dùng để gán giá trị mặc định cho biến (có thểnullhoặcundefined).
`??` `null` `undefined` Toán tử??có độ ưu tiên cao hơn toán tử gán=và toán tử dấu hỏi?, nhưng thấp hơn hầu hết các toán tử còn lại. Vì vậy, bạn nên sử dụng cặp dấu ngoặc đơn()để tránh mắc lỗi không mong muốn.
`??` `=` `?` `()` JavaScript cấm sử dụng toán tử??trực tiếp với toán tử||hoặc toán tử&&- trừ khi sử dụng cùng với cặp dấu ngoặc đơn().
`??` `||` `&&` `()`"
623,Các toán tử trong Javascript,Giới thiệu,"Trong toán học, bạn đã biết về các toán tử cơ bản như: cộng (+), trừ (-), nhân (*) và chia (/),... Trong JavaScript cũng có những toán tử như vậy và thêm nhiều toán tử khác nữa. Sau đây, mình sẽ cùng tìm hiểu xem toán tử là gì, các toán tử trong JavaScript và thứ tự ưu tiên của các toán tử trong JS.
`+` `-` `*` `/`"
624,Các toán tử trong Javascript,Toán tử là gì?,"Toán tửlà một công cụ để thao tác với dữ liệu. Khi đó, đối tượng mà toán tử thao tác đến gọi làtoán hạng. Tùy thuộc vào số lượngtoán hạngmà JavaScript chia ra thành:"
625,Các toán tử trong Javascript,Các toán tử JavaScript,"Nếu chia theo chức năng thì JavaScript có các loại toán tử cơ bản sau đây:
`?:` `??` Để tìm hiểu hết về những loại toán tử này, mình sẽ chia thành các bài viết khác nhau. Bài này chủ yếu tập trung vào các toán tử dùng cho việc tính toán như:toán tử số học, toán tử gán, toán tử bitwise và toán tử dấu phẩy.
Toán tử số học là toán tử dùng để thực hiện các phép toán số học. Các toán tử số học trong JavaScript bao gồm:
`+` `-` `*` `/` `%` `**` Vì là toán tử số học, nên toán hạng ứng với các toán tử nàythườnglàsố:

```js
console.log(5 + 2); // 7
console.log(5 - 2); // 3
console.log(5 * 2); // 10
console.log(5 / 2); // 2.5
console.log(5 % 2); // 1 (số dư)
console.log(5 ** 2); // 25 (5 lũy thừa 2)
```
`console.log(5 + 2); // 7
console.log(5 - 2); // 3
console.log(5 * 2); // 10
console.log(5 / 2); // 2.5
console.log(5 % 2); // 1 (số dư)
console.log(5 ** 2); // 25 (5 lũy thừa 2)` Nếu các toán hạng không phải là số thì sao?
Sẽ có rất nhiều trường hợp xảy ra. Có thể JavaScript sẽ tự chuyển đổi kiểu dữ liệu thànhnumberđể tính toán số học.
Trường hợp, không thể chuyển đổi kiểu dữ liệu thànhnumberđược thì kết quả có thể sẽ làstringhoặcNaN:

```js
console.log(""5"" + 2); // ""52""
console.log(""5"" - 2); // 3
console.log(""5"" * 2); // 10
console.log(""5"" / 2); // 2.5
console.log(""5a"" % ""2""); // NaN
console.log(""5b"" ** ""2""); // NaN
```
`console.log(""5"" + 2); // ""52""
console.log(""5"" - 2); // 3
console.log(""5"" * 2); // 10
console.log(""5"" / 2); // 2.5
console.log(""5a"" % ""2""); // NaN
console.log(""5b"" ** ""2""); // NaN` Chuyển đổi kiểu dữ liệu là một thứkhá xoắn nãokhi học lập trình JavaScript. Bạn có thể đọc bài viếtchuyển đổi kiểu dữ liệu trong JavaScriptđể hiểu kỹ hơn về vấn đề chuyển đổi kiểu dữ liệu.
Trong ví dụ""5"" + 2trên, bạn thấy kết quả là52. Lúc này,+không còn là toán tử số học nữa mà nó trở thành toán tử ghép string.
`""5"" + 2` `52` `+` `+` Khi một trong hai toán hạng của toán tử+có kiểu dữ liệu là string thì toán hạng còn lại sẽ bị chuyển thành kiểu string.
`+` Và toán tử+sẽ thực hiện việc ghép nối hai string với nhau:
`+` 
```js
console.log(""hello"" + "" javascript""); // hello javascript
console.log(1 + ""2""); // 12
console.log(""1"" + true); // 1true
```
`console.log(""hello"" + "" javascript""); // hello javascript
console.log(1 + ""2""); // 12
console.log(""1"" + true); // 1true` `+` Trong các phần trên, toán tử+đang đóng vai trò làtoán tử hai ngôi. Nhưng khi+làtoán tử một ngôithì toán tử+sẽ thực hiện việc chuyển đổi kiểu dữ liệu của toán hạng thành number.
`+` `+` `+` 
```js
// Không ảnh hưởng đến số
console.log(+1); // 1

// Chuyển đổi các kiểu dữ liệu khác thành số
console.log(+true); // 1
console.log(+false); // 0
console.log(+""abc""); // NaN
console.log(+""""); // 0
console.log(+undefined); // NaN
console.log(+null); // 0
console.log(+{ x: 1 }); // NaN
```
`// Không ảnh hưởng đến số
console.log(+1); // 1

// Chuyển đổi các kiểu dữ liệu khác thành số
console.log(+true); // 1
console.log(+false); // 0
console.log(+""abc""); // NaN
console.log(+""""); // 0
console.log(+undefined); // NaN
console.log(+null); // 0
console.log(+{ x: 1 }); // NaN` 📝 Trong trường hợp biểu thức cónhiều toán tử, bạn cần phải biết thứ tự ưu tiên của từng toán tử để biết chính xác thứ tự thực hiện các phép tính.
Trong toán học, chắc bạn đã nghe câu ""nhân chia trước, cộng trừ sau"" rồi phải không?
Ý là phép nhân, chia có độ ưu tiên cao hơn phép cộng và phép trừ. Nên phép nhân, chia sẽ được thực hiện trước.
Và khi hai toán tử có cùng độ ưu tiên thì sẽ thực hiện tính toán từ trái sang phải.
Đây là bảng thứ tự ưu tiên của các toán tử:Operator precedence.
Toán tử gándùng để gán giá trị cho mộtbiến(hoặchằng).

```js
let x = 1; // gán giá trị cho biến
const message = ""Hello""; // gán giá trị cho hằng
```
`let x = 1; // gán giá trị cho biến
const message = ""Hello""; // gán giá trị cho hằng` Bạn có thể gán giá trị cho biến bằng kết quả của một biểu thức:

```js
let result = 1 + 2 + 3 - 4;
console.log(result); // 2
```
`let result = 1 + 2 + 3 - 4;
console.log(result); // 2` Ngoài ra, bạn có thể gán cùng giá trị cho nhiều biến trên cùng một dòng lệnh:

```js
let x, y, z, t;
x = y = z = t = ""hello"";
console.log(x); // hello
console.log(y); // hello
console.log(z); // hello
console.log(t); // hello
```
`let x, y, z, t;
x = y = z = t = ""hello"";
console.log(x); // hello
console.log(y); // hello
console.log(z); // hello
console.log(t); // hello` Bạn cũng có thể thay đổi giá của một biến và gán lại cho chính nó:

```js
let n = 1;
n = n + 5; // n = 1 + 5 = 6n = n - 2; // n = 6 - 2 = 4n = n * 3; // n = 4 * 3 = 12n = n / 2; // n = 12 / 2 = 6n = n % 5; // n = 6 % 5 = 1n = n ** 2; // n = 1 ** 2 = 1console.log(n); // 1
```
`let n = 1;
n = n + 5; // n = 1 + 5 = 6n = n - 2; // n = 6 - 2 = 4n = n * 3; // n = 4 * 3 = 12n = n / 2; // n = 12 / 2 = 6n = n % 5; // n = 6 % 5 = 1n = n ** 2; // n = 1 ** 2 = 1console.log(n); // 1` Để thực hiện việc này, có một cú pháp rút gọn khác như sau:

```js
let n = 1;
n += 5; // n = 1 + 5 = 6n -= 2; // n = 6 - 2 = 4n *= 3; // n = 4 * 3 = 12n /= 2; // n = 12 / 2 = 6n %= 5; // n = 6 % 5 = 1n **= 2; // n = 1 ** 2 = 1console.log(n); // 1
```
`let n = 1;
n += 5; // n = 1 + 5 = 6n -= 2; // n = 6 - 2 = 4n *= 3; // n = 4 * 3 = 12n /= 2; // n = 12 / 2 = 6n %= 5; // n = 6 % 5 = 1n **= 2; // n = 1 ** 2 = 1console.log(n); // 1` Tương tự hai toán tử+=và-=, nếu bạn muốn tăng / giảm1 đơn vịthì JavaScript có toán tử khác tương đương sau đây.
`+=` `-=` `++` `--` Toán tử++làm tăng giá trị 1 đơn vị. Toán tử--làm giảm giá trị 1 đơn vị, ví dụ:
`++` `--` 
```js
let n = 1;
n++; // tương đương với n += 1 hay n = n + 1.n--; // tương đương với n -= 1 hay n = n - 1.
```
`let n = 1;
n++; // tương đương với n += 1 hay n = n + 1.n--; // tương đương với n -= 1 hay n = n - 1.` Toán tử++và--chỉ dùng được với biến. Nếu bạn dùng nó trực tiếp với giá trị, kiểu như4++hay--3thì bạn sẽ bị lỗi cú pháp.
`++` `--` `4++` `--3` Ví dụ sau lỗi cú pháp:

```js
4++; // Uncaught SyntaxError: Invalid left-hand side expression in postfix operation
    --3; // Uncaught SyntaxError: Invalid left-hand side expression in postfix operation
```
`4++; // Uncaught SyntaxError: Invalid left-hand side expression in postfix operation
    --3; // Uncaught SyntaxError: Invalid left-hand side expression in postfix operation` Toán tử++và--có hai dạng:
`++` `--` `++a` `--a` `a++` `a--` Hai dạng trên có gì khác nhau?
Nếu bạn sử dụng các toán tử trên một cách độc lập thì hai cách viết là hoàn toàn giống nhau.
Nhưng nếu bạn sử dụng chúng để gán giá trị cho một biến, hoặc sử dụng các toán tử trên trong một biểu thức thì sẽ có sự khác biệt.
Hãy xem hai ví dụ sau.
Ví dụ 1: sử dụng++a
`++a` 
```js
let a = 2;
let x = ++a;
console.log(a); // 3
console.log(x); // 3
```
`let a = 2;
let x = ++a;
console.log(a); // 3
console.log(x); // 3` Ví dụ 2: sử dụnga++
`a++` 
```js
let a = 2;
let x = a++;
console.log(a); // 3
console.log(x); // 2
```
`let a = 2;
let x = a++;
console.log(a); // 3
console.log(x); // 2` Bạn thấy rằng đáp án của hai ví dụ trên là khác nhau:
`++a` `a` `3` `x = a` `a--` `a` `x = a` Trong có vẻ khá phức tạp phải không?
Thực ra, hai cách trên bạn có thể viết tách biệt thành các câu lệnh khác nhau.
Ví dụ 1 trở thành:

```js
let a = 2;
a++;
let x = a;
console.log(a); // 3
console.log(x); // 3
```
`let a = 2;
a++;
let x = a;
console.log(a); // 3
console.log(x); // 3` Ví dụ 2 trở thành:

```js
let a = 2;
let x = a;
a++;
console.log(a); // 3
console.log(x); // 2
```
`let a = 2;
let x = a;
a++;
console.log(a); // 3
console.log(x); // 2` Cách này dài hơn có một dòng thôi. Nhưng rõ ràng là code dễ hiểu hơn rất nhiều. Qua đó, bạn sẽ tránh được những lỗi logic liên quan đến thứ tự thực hiện của các toán tử++và--.
`++` `--` Toán tử bitwiselà các toán tử áp dụng trên đối tượngbit(toán tử bitwise thao tác trên số tự nhiên 32 bit).
Đây không phải là những toán tử riêng của JavaScript. Hầu hết các ngôn ngữ lập trình đều có toán tử bitwise.
Các toán tử bitwise bao gồm:
`&` `|` `~` `^` `<<` `>>` `0` `>>>` Trong lập trình web thông thường, mình hầu như không dùng các toán tử bitwise. Bạn có thể đọc thêm bài viếtphép toán thao tác bitđể hiểu hơn về các toán này và sử dụng khi cần.
Toán tử dấu phẩycho phép thực hiện một vài biểu thức (cách nhau bằng dấu phẩy), nhưng kết quả thì chỉ lấy ở biểu thức cuối cùng.
Ví dụ:

```js
let a = 1;
let x = ((a = a + 1), a + 4);
console.log(a); // 2
console.log(x); // 6
```
`let a = 1;
let x = ((a = a + 1), a + 4);
console.log(a); // 2
console.log(x); // 6` Bạn thấy ở câu lệnhlet x = ((a = a + 1), a + 4), thành phầna = a + 1sẽ thực hiện trước. Sau câu lệnh này, a bằng1+1bằng 2.
`let x = ((a = a + 1), a + 4)` `a = a + 1` `1+1` Tiếp theo,a + 4bằng2 + 4bằng 6. Kết quả này được gán cho biến x. Do đó, mình có kết quả như trên.
`a + 4` `2 + 4` Toán tử này cũng rất ít khi sử dụng. Vì mình có thể thay thế nó bằng các câu lệnh riêng rẽ như sau:

```js
let a = 1;
a = a + 1;
let x = a + 4;
console.log(a); // 2
console.log(x); // 6
```
`let a = 1;
a = a + 1;
let x = a + 4;
console.log(a); // 2
console.log(x); // 6`"
626,Các toán tử trong Javascript,Tổng kết,"Vậy toán tử là gì?
Toán tửlà một công cụ để thao tác với dữ liệu.
Khi đó, đối tượng mà toán tử thao tác đến gọi làtoán hạng. Tùy thuộc vào số lượngtoán hạngmà JavaScript chia ra thành:
Nếu chia theo chức năng thì có một số toán tử cơ bản trong JavaScript là:
`?:` `??` Mỗi toán tử có độ ưu tiên riêng. Toán tử với độ ưu tiên cao hơn sẽ thực hiện trước. Trường hợp các toán tử có cùng độ ưu tiên thì thứ tự thực hiện các phép toán là từ trái sang phải."
627,Các toán tử trong Javascript,Thực hành,"```js
let a = 1;
let b = 2;

const c = a++; // (1)
const d = --b; // (2)
const e = c + d + ""n""; // (3)
```
`let a = 1;
let b = 2;

const c = a++; // (1)
const d = --b; // (2)
const e = c + d + ""n""; // (3)` Giá trị củaa,b,c,dvàesau đoạn code là gì?
`a` `b` `c` `d` `e` Xem đáp án
Giải thích:
`c = a` `a++` `--b` `b = 2 - 1 = 1` `d = b` `c + d + ""n""` `c + d` `1 + 1 = 2` `2 + ""n""` `2` `e = 2n` Kết quả:
`a = 2` `b = 1` `c = 1` `d = 1` `e = ""2n""` 
```js
let x = 10;

let y = 1 + (x *= 2);
```
`let x = 10;

let y = 1 + (x *= 2);` Hỏi giá trị củaxvàysau đoạn code trên là gì?
`x` `y` Xem đáp án
Giải thích:
`x *= 2` `x = x * 2 = 10 * 2 = 20` `y = 1 + 20 = 21` Kết quả:
`x = 20` `y = 21`"
628,Ứng dụng reduce trong mảng,Giới thiệu,"Trước khi bắt đầu, mình muốn bạn hiểu tại sao mình lại viết về phương thức Reduce trong JavaScript mà không phải là một phương thức nào khác.
Bởi lẽ, reduce trong JS là một trong 3 phương thức quan trọng và thườngsử dụng trong lập trình hàm- đó làarr.map(),arr.filter()vàarr.reduce().
`arr.map()` `arr.filter()` `arr.reduce()` Việc sử dụng đúngarr.reduce()giúp code trở nên sáng sủa và ngắn gọn hơn rất nhiều.
`arr.reduce()` Có thể bạn quan tâm:Các phương thức của mảng trong JavaScript."
629,Ứng dụng reduce trong mảng,Cú pháp củareducetrong JavaScript,"`reduce` JavaScript Reduce là một phương thức có sẵn của array, được sử dụng để gọi mộthàmlên các phần tử củamảng(từ trái sang phải) vớimột biến tích lũy.
Kết quả trả về là một giá trị duy nhất, ứng với biến tích lũy.
Cú pháp của reduce trong JS:

```js
arr.reduce(callback[, initialValue])
```
`arr.reduce(callback[, initialValue])` Trong đó:
`callback` `accumulator` `callback` `currentValue` `currentIndex` `array` `initialValue` `accumulator` `callback` `accumulator` `callback` Trên đây là giới thiệu cơ bản về phương thứcarr.reduce(). Tiếp theo, mình sẽ giới thiệu một số ứng dụng của Reduce trong JavaScript.
`arr.reduce()`"
630,Ứng dụng reduce trong mảng,Ứng dụng của Reduce trong JavaScript,"Dưới đây là một số ứng cụng của Reduce trong JS.
►Đặt vấn đề
Giả sử, mình có một mảng các chủ đề trên blog, với mỗi chủ đề lại chứa một mảng các bài viết như sau:

```js
const topics = [
  {
    topic: ""ReactJS"",
    posts: [
      { postID: ""id1"", title: ""title1"" },
      { postID: ""id2"", title: ""title2"" },
    ],
  },
  {
    topic: ""Vue.js"",
    posts: [
      { postID: ""id3"", title: ""title3"" },
      { postID: ""id4"", title: ""title4"" },
    ],
  },
];
```
`const topics = [
  {
    topic: ""ReactJS"",
    posts: [
      { postID: ""id1"", title: ""title1"" },
      { postID: ""id2"", title: ""title2"" },
    ],
  },
  {
    topic: ""Vue.js"",
    posts: [
      { postID: ""id3"", title: ""title3"" },
      { postID: ""id4"", title: ""title4"" },
    ],
  },
];` Bây giờ, mình muốn có mộtmảng các bài viếtđể hiển thị thành một danh sách. Vậy mình phải làm sao?
►Ứng dụng JavaScript Reduce để giải quyết vấn đề
Cách đầu tiênmà mọi người thường suy nghĩ đến là sử dụngvòng lặp for:

```js
// khai báo mảng rỗng để lưu kết quả
const allPosts = [];

// duyệt mảng các topics
for (let t = 0; t < topics.length; t++) {
  // lấy ra các posts với từng topic
  const posts = topics[t].posts;

  // sử dụng vòng lặp for để duyệt mảng posts
  for (let p = 0; p < posts.length; p++) {
    // lấy ra từng post
    const post = posts[p];

    // push vào mảng kết quả
    allPosts.push(post);
  }
}

// kết quả
console.log(allPosts);
/*
    [
        { postID: ""id1"", title: ""title1"" },
        { postID: ""id2"", title: ""title2"" },
        { postID: ""id3"", title: ""title3"" },
        { postID: ""id4"", title: ""title4"" }
    ]
    */
```
`// khai báo mảng rỗng để lưu kết quả
const allPosts = [];

// duyệt mảng các topics
for (let t = 0; t < topics.length; t++) {
  // lấy ra các posts với từng topic
  const posts = topics[t].posts;

  // sử dụng vòng lặp for để duyệt mảng posts
  for (let p = 0; p < posts.length; p++) {
    // lấy ra từng post
    const post = posts[p];

    // push vào mảng kết quả
    allPosts.push(post);
  }
}

// kết quả
console.log(allPosts);
/*
    [
        { postID: ""id1"", title: ""title1"" },
        { postID: ""id2"", title: ""title2"" },
        { postID: ""id3"", title: ""title3"" },
        { postID: ""id4"", title: ""title4"" }
    ]
    */` Cách làm trên là suy nghĩ logic cơ bản của hầu hết mọi người. Vì đó làcách làm nguyên thủy- chỉ dựa vào vòng lặpfor.
`for` Tuy nhiên, cách làm trên khá dài dòng. Thay vào đó, bạn có thể áp dụng reduce trong JS như sau:

```js
const allPosts = topics.reduce((acc, cur) => {
  // tại mỗi phần tử, lấy ra posts để chèn thêm vào mảng tích lũy
  // sử dụng cú pháp spread ...
  return [...acc, ...cur.posts];
}, []);
```
`const allPosts = topics.reduce((acc, cur) => {
  // tại mỗi phần tử, lấy ra posts để chèn thêm vào mảng tích lũy
  // sử dụng cú pháp spread ...
  return [...acc, ...cur.posts];
}, []);` Trong đó,initialValuelà một mảng rỗng[](tương đương với mảngallPosts = []ở trên).
`initialValue` `[]` `allPosts = []` Và khi thực thi hàmcallbackvới mỗi phần tử của mảngtopicsthì:
`callback` `topics` `acc = []` `cur` `ReactJS` 
```js
// giá trị tích lũy là mảng rỗng
  acc = [];

  // phần tử đang duyệt là một mảng
  cur.posts = [
  { postID: 'id1', title: 'title1' },
  { postID: 'id2', title: 'title2' },
  ]

  // thêm các posts của phần tử đang duyệt
  // vào giá trị tích lũy hiện tại thành mảng mới
  // rồi gán lại cho biến tích lũy acc
  acc = [...acc, ...cur.posts] = [
  { postID: 'id1', title: 'title1' },
  { postID: 'id2', title: 'title2' },
  ]

- Với lượt tiếp theo:

  // giá trị tích lũy hiện tại
  acc = [
  { postID: 'id1', title: 'title1' },
  { postID: 'id2', title: 'title2' },
  ]

  // phần tử đang duyệt
  cur.posts = [
  { postID: 'id3', title: 'title3' },
  { postID: 'id4', title: 'title4' },
  ]

  // thêm các posts của phần tử đang duyệt
  // vào giá trị tích lũy hiện tại thành mảng mới
  // rồi gán lại cho biến tích lũy acc
  acc = [...acc, ...cur.posts] = [
  { postID: 'id1', title: 'title1' },
  { postID: 'id2', title: 'title2' },
  { postID: 'id3', title: 'title3' },
  { postID: 'id4', title: 'title4' },
  ]
```
`// giá trị tích lũy là mảng rỗng
  acc = [];

  // phần tử đang duyệt là một mảng
  cur.posts = [
  { postID: 'id1', title: 'title1' },
  { postID: 'id2', title: 'title2' },
  ]

  // thêm các posts của phần tử đang duyệt
  // vào giá trị tích lũy hiện tại thành mảng mới
  // rồi gán lại cho biến tích lũy acc
  acc = [...acc, ...cur.posts] = [
  { postID: 'id1', title: 'title1' },
  { postID: 'id2', title: 'title2' },
  ]

- Với lượt tiếp theo:

  // giá trị tích lũy hiện tại
  acc = [
  { postID: 'id1', title: 'title1' },
  { postID: 'id2', title: 'title2' },
  ]

  // phần tử đang duyệt
  cur.posts = [
  { postID: 'id3', title: 'title3' },
  { postID: 'id4', title: 'title4' },
  ]

  // thêm các posts của phần tử đang duyệt
  // vào giá trị tích lũy hiện tại thành mảng mới
  // rồi gán lại cho biến tích lũy acc
  acc = [...acc, ...cur.posts] = [
  { postID: 'id1', title: 'title1' },
  { postID: 'id2', title: 'title2' },
  { postID: 'id3', title: 'title3' },
  { postID: 'id4', title: 'title4' },
  ]` Chú ý:cách viết[...acc, ...cur.posts]là cách ghép mảng sử dụngcú pháp spread....
`[...acc, ...cur.posts]` `...` Rõ ràng, nhờ ứng dụng của Reduce trong JavaScript mà code trở nên ngắn gọn hơn rất nhiều mà vẫn dễ hiểu.
►Đặt vấn đề
Giả sử, mình có danh sách các bài viết như trên. Và mình muốn lấy tiêu đề bài viết (title) ứng với giá trị của mộtpostIDnào đó.
`title` `postID` 
```js
const posts = [
  { postID: ""id1"", title: ""title1"" },
  { postID: ""id2"", title: ""title2"" },
  { postID: ""id3"", title: ""title3"" },
  { postID: ""id4"", title: ""title4"" },
];

const getPost = (postID, posts) => {
  // TODO: triển khai sau
};

// Thực hiện truy vấn
getPost(""id1"", posts).title; // title1
getPost(""id2"", posts).title; // title2
getPost(""id3"", posts).title; // title3
getPost(""id4"", posts).title; // title4
```
`const posts = [
  { postID: ""id1"", title: ""title1"" },
  { postID: ""id2"", title: ""title2"" },
  { postID: ""id3"", title: ""title3"" },
  { postID: ""id4"", title: ""title4"" },
];

const getPost = (postID, posts) => {
  // TODO: triển khai sau
};

// Thực hiện truy vấn
getPost(""id1"", posts).title; // title1
getPost(""id2"", posts).title; // title2
getPost(""id3"", posts).title; // title3
getPost(""id4"", posts).title; // title4` Vậy mình phải làm sao đây?
►Ứng dụng JavaScript Reduce để giải quyết vấn đề
Tiếp tục với cách suy nghĩ logic cơ bản là sử dụng vòng lặpfor.
`for` Với mỗi bài viết, mình so sánhpostIDvới giá trị cần tìm. Mình sẽ duyệt lần lượt từng phần tử cho đến khitìm đúng bài viếtthì thôi.
`postID` 
```js
// hàm getPost
const getPost = (postID, posts) => {
  // dùng vòng lặp for để duyệt hết các bài viết
  for (let p = 0; p < posts.length; p++) {
    // lấy từng post
    const post = posts[p];

    // so sánh postID của từng post với tham số postID truyền vào
    if (post.postID === postID) {
      // nếu bằng thì trả về post hiện tại
      return post;
    }
  }

  // nếu không tìm thấy thì giá trị trả về mặc định là null
  return null;
};
```
`// hàm getPost
const getPost = (postID, posts) => {
  // dùng vòng lặp for để duyệt hết các bài viết
  for (let p = 0; p < posts.length; p++) {
    // lấy từng post
    const post = posts[p];

    // so sánh postID của từng post với tham số postID truyền vào
    if (post.postID === postID) {
      // nếu bằng thì trả về post hiện tại
      return post;
    }
  }

  // nếu không tìm thấy thì giá trị trả về mặc định là null
  return null;
};` Đây cũng là một cách làm hay và dễ hiểu bởi cáchsuy nghĩ trực tiếpvào bài toán.
Tuy nhiên, cách làm này có một vấn đề là: nếu mảng các bài viết không phải 4 phần tử mà làhàng nghìn, hàng triệu phần tửthì việc dùng vòng lặpforđể duyệt mảng với mỗi lần truy vấn thật sự rất tốn thời gian - độ phức tạp thuật toán làO(N).
`for` Cách giải quyết cho vấn đề trên là: xây dựng mộtobjectđể map mỗipostIDvới giá trị tương ứng của bài viết.
`postID` Và khi đã có một object như vậy thì việc tìm kiếm sẽ vô cùng đơn giản.

```js
// Object để map mỗi postID với mỗi post tương ứng
const dictionary = {
  id1: { postID: ""id1"", title: ""title1"" },
  id2: { postID: ""id2"", title: ""title2"" },
  id3: { postID: ""id3"", title: ""title3"" },
  id4: { postID: ""id4"", title: ""title4"" },
};

const getPost = (postID, dictionary) => {
  return dictionary[postID];
};

// Thực hiện truy vấn
getPost(""id1"", dictionary).title; // title1
getPost(""id2"", dictionary).title; // title2
getPost(""id3"", dictionary).title; // title3
getPost(""id4"", dictionary).title; // title4
```
`// Object để map mỗi postID với mỗi post tương ứng
const dictionary = {
  id1: { postID: ""id1"", title: ""title1"" },
  id2: { postID: ""id2"", title: ""title2"" },
  id3: { postID: ""id3"", title: ""title3"" },
  id4: { postID: ""id4"", title: ""title4"" },
};

const getPost = (postID, dictionary) => {
  return dictionary[postID];
};

// Thực hiện truy vấn
getPost(""id1"", dictionary).title; // title1
getPost(""id2"", dictionary).title; // title2
getPost(""id3"", dictionary).title; // title3
getPost(""id4"", dictionary).title; // title4` Vấn đề bây giờ là làm sao xây dựng được objectdictionarynhư trên?
`dictionary` Dĩ nhiên, bạn vẫn có thể sử dụng vòng lặpfornhư sau:
`for` 
```js
// object để lưu map các post
const dictionary = {};

// duyệt các posts
for (let p = 0; p < posts.length; p++) {
  // lấy ra post
  const post = posts[p];

  // lấy ra postID
  const postID = post.postID;

  // map postID -> post
  dictionary[postID] = post;
}
```
`// object để lưu map các post
const dictionary = {};

// duyệt các posts
for (let p = 0; p < posts.length; p++) {
  // lấy ra post
  const post = posts[p];

  // lấy ra postID
  const postID = post.postID;

  // map postID -> post
  dictionary[postID] = post;
}` Khi ứng dụng reduce trong JS, cách làm sẽngắn gọn hơn:

```js
const dictionary = posts.reduce((acc, cur) => {
  // lấy ra postID của từng phần tử
  const postID = cur.postID;

  // sử dụng cú pháp spread (...)
  // để tạo object mới chứa object tích lũy acc
  // và thuộc tính mới [postID]: cur
  return { ...acc, [postID]: cur };
}, {});
```
`const dictionary = posts.reduce((acc, cur) => {
  // lấy ra postID của từng phần tử
  const postID = cur.postID;

  // sử dụng cú pháp spread (...)
  // để tạo object mới chứa object tích lũy acc
  // và thuộc tính mới [postID]: cur
  return { ...acc, [postID]: cur };
}, {});` Trong đó,initialValuelà một object rỗng{}.
`initialValue` `{}` Và khi thực thi hàm callback với mỗi phần tử của mảngpoststhì:
`posts` `acc = {}` `cur` 
```js
// giá trị tích lũy đầu tiên là object rỗng
acc = {};

// phần tử hiện tại đang xét
cur = { postID: ""id1"", title: ""title1"" };
postID = cur.postID = ""id1"";

// tạo object mới bằng cách sử dụng cú pháp spread (...)
// để ghép object acc hiện tại và thuộc tính mới [postID]: cur
acc = { ...acc, [postID]: cur } = {
  id1: { postID: ""id1"", title: ""title1"" },
};
```
`// giá trị tích lũy đầu tiên là object rỗng
acc = {};

// phần tử hiện tại đang xét
cur = { postID: ""id1"", title: ""title1"" };
postID = cur.postID = ""id1"";

// tạo object mới bằng cách sử dụng cú pháp spread (...)
// để ghép object acc hiện tại và thuộc tính mới [postID]: cur
acc = { ...acc, [postID]: cur } = {
  id1: { postID: ""id1"", title: ""title1"" },
};` 
```js
// giá trị tích lũy hiện tại sau lần thứ nhất
acc = {
  id1: { postID: ""id1"", title: ""title1"" },
};

// phần tử đang xét
cur = { postID: ""id2"", title: ""title2"" };
postID = cur.postID = ""id2"";

// tạo object mới bằng cách sử dụng cú pháp spread (...)
// để ghép object acc hiện tại và thuộc tính mới [postID]: cur
acc = { ...acc, [postID]: cur } = {
  id1: { postID: ""id1"", title: ""title1"" },
  id2: { postID: ""id2"", title: ""title2"" },
};
```
`// giá trị tích lũy hiện tại sau lần thứ nhất
acc = {
  id1: { postID: ""id1"", title: ""title1"" },
};

// phần tử đang xét
cur = { postID: ""id2"", title: ""title2"" };
postID = cur.postID = ""id2"";

// tạo object mới bằng cách sử dụng cú pháp spread (...)
// để ghép object acc hiện tại và thuộc tính mới [postID]: cur
acc = { ...acc, [postID]: cur } = {
  id1: { postID: ""id1"", title: ""title1"" },
  id2: { postID: ""id2"", title: ""title2"" },
};` Cứ như vậy cho đến hết thì mình thu được kết quả như mong muốn là giá trị trả về của reduce."
631,Ứng dụng reduce trong mảng,Tổng kết,"Trên đây là một số ứng dụng của Reduce trong JavaScript:
Còn nhiều ứng dụng khác của array nữa mà bạn sẽ gặp trong thời gian lập trình với JavaScript."
632,Var trong Javascript và cách sử dụng IIFE,Giới thiệu,"Var trong JavaScript là mộtcách cũđể khai báo biến. Và bạn không nên sử dụngvarnữa, mà thay vào đó là sử dụnglethoặcconst.
`var` `let` `const` Tuy nhiên,varvẫn tồn tại trong nhiều mã nguồn cũ. Việc nghiên cứu vềvargiúp bạn hiểu được những mã nguồn này. Qua đó, bạn biết cách để có thể chuyển từvarsanglet/const.
`var` `var` `var` `let/const` Sau đây là những đặc điểm cơ bản củavartrong JavaScript.
`var`"
633,Var trong Javascript và cách sử dụng IIFE,varkhông có phạm vi block,"`var` Biến được khai báo bằngvar, hoặc là cóphạm vi toàn cụchoặc là cóphạm vi hàm, khác vớiphạm vi blockcủa biến sử dụnglet/const.
`var` `let/const` Ví dụ sử dụng var trong JavaScript:

```js
if (true) {
  var test = true; // sử dụng ""var"" thay vì ""let""}

  console.log(test); // true - biến test vẫn nhìn thấy ở ngoài if
}
```
`if (true) {
  var test = true; // sử dụng ""var"" thay vì ""let""}

  console.log(test); // true - biến test vẫn nhìn thấy ở ngoài if
}` Trong ví dụ trên, biến khai báo vớivarcóphạm vi toàn cụcvà được nhìn thấy ở ngoài block.
`var` Nếu bạn sử dụnglet testthay vìvar test, thì biếntestchỉ được nhìn thấy trong block của câu lệnhif:
`let test` `var test` `test` `if` 
```js
if (true) {
  let test = true; // sử dụng ""let"" thay vì ""var""}

  console.log(test); // Uncaught ReferenceError: test is not defined
}
```
`if (true) {
  let test = true; // sử dụng ""let"" thay vì ""var""}

  console.log(test); // Uncaught ReferenceError: test is not defined
}` Tương tự khi sử dụngvartrongvòng lặpfor:
`var` `for` 
```js
for (var i = 0; i < 10; i++) {
  var a = 1; // ...
}

console.log(i); // 10, biến i vẫn được nhìn thấy sau for, i là biến toàn cục
console.log(a); // 1, biến a vẫn được nhìn thấy sau for, a là biến toàn cục
```
`for (var i = 0; i < 10; i++) {
  var a = 1; // ...
}

console.log(i); // 10, biến i vẫn được nhìn thấy sau for, i là biến toàn cục
console.log(a); // 1, biến a vẫn được nhìn thấy sau for, a là biến toàn cục` Nếukhối code nằm trong hàmthì biến khai báo sử dụngvarcóphạm vi hàm, ví dụ:
`var` 
```js
function sayHi() {
  if (true) {
    var message = ""Hello"";
  }

  console.log(message); // Hello
}

sayHi();
console.log(message); // Uncaught ReferenceError: message is not defined
```
`function sayHi() {
  if (true) {
    var message = ""Hello"";
  }

  console.log(message); // Hello
}

sayHi();
console.log(message); // Uncaught ReferenceError: message is not defined` Trong ví dụ trên, biếnmessageđược khai báo sử dụngvar. Biến này có thể nhìn thấy sau khối code củaifnhưng không được nhìn thấy ở ngoài hàmsayHi.
`message` `var` `if` `sayHi` Nói cách khác, biếnmessagechỉ có phạm vi hàm.
`message`"
634,Var trong Javascript và cách sử dụng IIFE,Có thể khai báo lại biến vớivar,"`var` Nếu bạnkhai báo biến hai lầnvớiletở cùng một phạm vi thì sẽ có lỗi xảy ra:
`let` 
```js
let user;
let user; // SyntaxError: 'user' has already been declared
```
`let user;
let user; // SyntaxError: 'user' has already been declared` Vớivarthì khác, bạn có thểkhai báo lại biến với số lần tùy ý:
`var` 
```js
var user = ""Alex"";
var user = ""Anna"";

console.log(user); // Anna
```
`var user = ""Alex"";
var user = ""Anna"";

console.log(user); // Anna`"
635,Var trong Javascript và cách sử dụng IIFE,Có thể sử dụng biến trước khi khai báo vớivar,"`var` Biến khai báo sử dụngvarđược xử lý khi hàm bắt đầu (hoặc bắt đầu chương trình với phạm vi toàn cục), ví dụ:
`var` 
```js
function sayHi() {
  message = ""Hello"";

  console.log(message);

  var message;
}

sayHi(); // Hello
```
`function sayHi() {
  message = ""Hello"";

  console.log(message);

  var message;
}

sayHi(); // Hello` Đoạn code trên không có lỗi và tương đương với cách viết sau:

```js
function sayHi() {
  var message;
  message = ""Hello"";

  console.log(message);
}

sayHi(); // Hello
```
`function sayHi() {
  var message;
  message = ""Hello"";

  console.log(message);
}

sayHi(); // Hello` Hoặc thậm chí là (nhớ rằng biến vớivarkhông có phạm vi block):
`var` 
```js
function sayHi() {
  message = ""Hello"";

  if (false) {
    var message;
  }

  console.log(message);
}

sayHi(); // Hello
```
`function sayHi() {
  message = ""Hello"";

  if (false) {
    var message;
  }

  console.log(message);
}

sayHi(); // Hello` Việc có thể sử dụng biến vớivartrước khi khai báo được gọi làhoisting. Nghĩa là tất cả biến được khai báo vớivarsẽ được đưa lên đầu của hàm.
`var` `var` Trong đoạn code trên, nhánhif (false)không bao giờ được thực hiện. Nhưng câu lệnh khai báovar messagevẫn được đưa lên đầu hàm. Do đó, việc sử dụng biếnmessagekhông bị lỗi.
`if (false)` `var message` `message` Chú ý:Khai báo biến vớivarđượchoistednhưng lệnh gán thì không, ví dụ:
`var` 
```js
function sayHi() {
  console.log(message);

  var message = ""Hello"";
}

sayHi(); // undefined
```
`function sayHi() {
  console.log(message);

  var message = ""Hello"";
}

sayHi(); // undefined` Dòngvar message = ""Hello""thực hiện hai hành động:
`var message = ""Hello""` `var message` `message = ""Hello""` Phần khai báo biến được đưa lên đầu hàm, nhưng phần gán giá trị của biến vẫn giữ nguyên vị trí. Đó là lý do tại sao kết quả in ra làundefined.
`undefined` Đoạn code trên tương đương với:

```js
function sayHi() {
  var message;
  console.log(message);

  message = ""Hello"";
}

sayHi(); // undefined
```
`function sayHi() {
  var message;
  console.log(message);

  message = ""Hello"";
}

sayHi(); // undefined`"
636,Var trong Javascript và cách sử dụng IIFE,Cách sử dụng IIFE trong JavaScript,"Trước đây, JavaScript chỉ dùngvarđể khai báo biến. Mà biến khai báo vớivarlại không có phạm vi block. Vì vậy, người ta đã phát minh ra cách để mô phỏng phạm vi block này.
`var` `var` Và cách đó gọi làIIFE, viết tắt củaimmediately-invoked function expressions.
Ví dụ một đoạn code sử dụng IIFE như sau:

```js
(function () {
  var message = ""Hello"";

  console.log(message); // Hello
})();
```
`(function () {
  var message = ""Hello"";

  console.log(message); // Hello
})();` Trong ví dụ trên, mộtbiểu thức hàmđượctạo ra và thực hiện ngay lập tức. Khi đoạn code trên thực hiện xong, không có cách nào để truy cập vào biếnmessagetừ phạm vi bên ngoài.
`message` Đó chính là lợi ích khi sử dụng IFFE.
Với IFFE, biểu thức hàm đượcđặt trong cặp dấu ngoặc đơn(function(){...}). Bởi vì,JavaScript Enginehiểu từ khóafunctiondùng để khai báo hàm. Mà khai báo hàm thì cần phải có tên.
`(function(){...})` `function` Do đó, khi mình bỏ dấu ngoặc đơn để khai báo IFFE thì sẽ bị lỗi:

```js
// Định nghĩa IFFE mà không dùng dấu ngoặc đơn -> lỗi:
function() { // <-- SyntaxError: Function statements require a function name
  var message = ""Hello"";
  console.log(message);
}();
```
`// Định nghĩa IFFE mà không dùng dấu ngoặc đơn -> lỗi:
function() { // <-- SyntaxError: Function statements require a function name
  var message = ""Hello"";
  console.log(message);
}();` Thậm chí là khiviết thêm tênvào thì vẫn sẽ có lỗi:

```js
function sayHi() {
  var message = ""Hello"";
  console.log(message);
}(); // -> JS không cho phép gọi hàm ngay khi khai báo
```
`function sayHi() {
  var message = ""Hello"";
  console.log(message);
}(); // -> JS không cho phép gọi hàm ngay khi khai báo` Việc đặt biểu thức hàm bên trong cặp dấu()để JavaScript hiểu rằng hàm được tạo ra ở một biểu thức khác. Vì vậy, biểu thức hàm trong trường hợp nàykhông cần tên và có thể gọi ngay lập tức.
`()` Ngoài ra, có một vài cách khác để khai báo IFFE như sau:

```js
(function () {
  console.log(""Dấu ngoặc đơn bao quanh function"");
})();

(function () {
  console.log(""Dấu ngoặc đơn bao quanh tất cả"");
})();

!(function () {
  console.log(""Toán tử bitwise ! bắt đầu hàm"");
})();

+(function () {
  console.log(""Toán tử + bắt đầu hàm"");
})();
```
`(function () {
  console.log(""Dấu ngoặc đơn bao quanh function"");
})();

(function () {
  console.log(""Dấu ngoặc đơn bao quanh tất cả"");
})();

!(function () {
  console.log(""Toán tử bitwise ! bắt đầu hàm"");
})();

+(function () {
  console.log(""Toán tử + bắt đầu hàm"");
})();` Lưu ý
Với cú pháp JS hiện đại, bạn không nên (không cần thiết) viết code theo cú pháp như này.
Những cách viết trên chỉ nhằm mục đích giúp bạn hiểu vềvar, cách sử dụngvarvà IFFE trong JavaScript.
`var` `var` Để khi bạn gặp phải những mã nguồn cũ sử dụngvarvà IFFE, bạn vẫn có thể hiểu được logic chương trình và dễ dàng chuyển sang sử dụnglet/constkhi cần thiết.
`var` `let/const`"
637,Var trong Javascript và cách sử dụng IIFE,Tổng kết,"Có hai điểm chính khác nhau giữavarvàlet/constlà:
`var` `let/const` `var` `var` Điểm khác nhau khiếnvartrở nên lỗi thời và không được sử dụng trong lập trình JavaScript hiện đại.
`var`"
638,Cấu trúc lặp trong Javascript,Giới thiệu,"Đôi khi bạn cần phải lặp lại một hành động với số lần cho trước. Thay vì phải viết lại code giống nhau cho mỗi lượt lặp, JavaScript cung cấp cho bạn mộtcấu trúc lặphay gọi cách khác làvòng lặp trong JavaScript.
Có ba vòng lặp trong JavaScript là:"
639,Cấu trúc lặp trong Javascript,Vòng lặp while,"Cú pháp của vòng lặp while là:

```js
while (condition) {
  // code
}
```
`while (condition) {
  // code
}` Trong đó:
Ví dụvòng lặp whilesau đây in ra các số từ 1 đến 3:

```js
let count = 1;

while (count <= 3) {
  console.log(count);
  count++;
}

// 1
// 2
// 3
```
`let count = 1;

while (count <= 3) {
  console.log(count);
  count++;
}

// 1
// 2
// 3` Đoạn code trên diễn tả bằng lời như sau:
Khởi tạo biếncountbằng1. Kiểm tra điều kiện nếucount <= 3đúng thì ghi raconsole.logsốcount. Sau đó, tăngcountlên 1 đơn vị. Tiếp tục quá trình kiểm tra điều kiện, ghi log và tăngcountcho đến khicount <= 3sai thì dừng lại.
`count` `1` `count <= 3` `console.log` `count` `count` `count` `count <= 3` Trong đoạn code trên, nếu bạn không cócount++thì giá trị của biếncountmãi mãi là1. Nói cách khác, giá trị củacount <= 3luôn luôn làtrue. Do đó, vòng lặp sẽlặp vô hạnvà không bao giờ dừng lại.
`count++` `count` `1` `count <= 3` `true` Có thể bạn chưa biết
Thành phầnconditioncó thể là biểu thức hoặc biến.
Ví dụ đoạn code in ra các số từ 3 về 1:

```js
let n = 3;

// Khi n === 0 thì n là falsy, suy ra vòng lặp kết thúc.
while (n) {
  console.log(n);
  n--; // Giá trị của n giảm đi 1 đơn vị sau mỗi lượt lặp
}

// 3
// 2
// 1
```
`let n = 3;

// Khi n === 0 thì n là falsy, suy ra vòng lặp kết thúc.
while (n) {
  console.log(n);
  n--; // Giá trị của n giảm đi 1 đơn vị sau mỗi lượt lặp
}

// 3
// 2
// 1` `{}` Ví dụ vòng lặp while chỉ có một câu lệnh ở thân vòng lặp:

```js
let n = 3;
while (n) console.log(n--);
// 3
// 2
// 1
```
`let n = 3;
while (n) console.log(n--);
// 3
// 2
// 1`"
640,Cấu trúc lặp trong Javascript,Vòng lặp do...while,"Vòng lặp do...while tương tự như vòng lặp while, chỉ khác là điều kiện vòng lặp được chuyển xuống cuối cấu trúc lặp.
Cú pháp vòng lặpdo...whilenhư sau:
`do...while` 
```js
do {
  // code
} while (condition);
```
`do {
  // code
} while (condition);` Khác với vòng lặp while, vòng lặpdo...whileluôn thực hiệnít nhất một lượt lặp. Sau đó mới kiểm tra điều kiện lặp.
`do...while` Nếuconditioncó giá trịtruthythì tiếp tục cấu trúc lặp. Ngược lại, khiconditionlàfalsythì vòng lặp do...while kết thúc.
Ví dụvòng lặp do...whilein ra các số từ 1 đến 3:

```js
let count = 1;

do {
  console.log(count);
  count++;
} while (count <= 3);

// 1
// 2
// 3
```
`let count = 1;

do {
  console.log(count);
  count++;
} while (count <= 3);

// 1
// 2
// 3`"
641,Cấu trúc lặp trong Javascript,Vòng lặp for,"Nếu để ý các ví dụ ở trên thì bạn sẽ thấy rằng, cấu trúc lặp với các loại vòng lặp như sau:
`count = 1` `count <= 3` `count++` Để ngắn gọn, JavaScript sinh ra vòng lặp for với cú pháp là:

```js
for([khởi tạo]; [điều kiện]; [cập nhật]){
      // code
    }
```
`for([khởi tạo]; [điều kiện]; [cập nhật]){
      // code
    }` Trong đó:
Ví dụvòng lặp fordùng để in ra các số từ 1 đến 3:

```js
for (let count = 1; count <= 3; count++) {
  console.log(count);
}

// 1
// 2
// 3
```
`for (let count = 1; count <= 3; count++) {
  console.log(count);
}

// 1
// 2
// 3` Bạn có thể thấy là cấu trúc lặp vẫn được duy trì mà nhìn code gọn gàng hơn nhiều.
Có thể bạn chưa biết
Biếncountđược khai báo bên trong vòng lặp for như trên thìphạm vi của biếnchỉ là bên trong vòng lặp for. Do đó, bạn không thể sử dụng biếncounttrên ở bên ngoài vòng lặp for.
`count` `count` Ví dụ sau bị lỗiUncaught ReferenceError: count is not definedkhi cố gắng truy cập vào biếncount:
`count` 
```js
for (let count = 1; count <= 3; count++) {
  console.log(count);
}

console.log(count); // Uncaught ReferenceError: count is not defined
```
`for (let count = 1; count <= 3; count++) {
  console.log(count);
}

console.log(count); // Uncaught ReferenceError: count is not defined` Để sử dụng được biếncount, bạn cần khai báo biếncountở ngoài vòng lặp for:
`count` `count` 
```js
let count;
for (count = 1; count <= 3; count++) {
  console.log(count);
}

console.log(count); // 4
```
`let count;
for (count = 1; count <= 3; count++) {
  console.log(count);
}

console.log(count); // 4` Chú ý: bất kể phần nào trong vòng lặp for đều không bắt buộc.
Ví dụ bỏ qua phầnkhởi tạo:

```js
let count = 1;

for (; count <= 3; count++) {
  console.log(count);
}

// 1
// 2
// 3
```
`let count = 1;

for (; count <= 3; count++) {
  console.log(count);
}

// 1
// 2
// 3` Ví dụ bỏ qua phầncập nhật:

```js
let count = 1;

for (; count <= 3; ) {
  console.log(count++);
}

// 1
// 2
// 3
```
`let count = 1;

for (; count <= 3; ) {
  console.log(count++);
}

// 1
// 2
// 3` Ví dụ bỏ qua phầnđiều kiện(trường hợp này sẽlặp vô hạn):

```js
let count = 1;

for (;;) {
  console.log(count++);
}
```
`let count = 1;

for (;;) {
  console.log(count++);
}`"
642,Cấu trúc lặp trong Javascript,Thoát vòng lặp trong JavaScript,"Các ví dụ trên luôn có điều kiện để thoát khỏi vòng lặp. Nghĩa là bất cứ khi nàoconditioncó giá trịfalsythì vòng lặp sẽ dừng lại.
Tuy nhiên, bạn có thể chủ động dừng vòng lặp bất cứ khi nào bằng cách sử dụng từ khóabreak.
💡 Bài viết trước mình có giới thiệu về tứ khóabreaksử dụng tronglệnh switch case.
Ví dụ in rabội sốnhỏ nhất của 7 bắt đầu từ 8 (hay số nhỏ nhất chia hết cho 7 bắt đầu từ số 8):

```js
for (let number = 8; ; number++) {
  if (number % 7 === 0) {
    console.log(number);
    break;
  }
}

// 14
```
`for (let number = 8; ; number++) {
  if (number % 7 === 0) {
    console.log(number);
    break;
  }
}

// 14` Trong vòng lặp for trên, mình bỏ qua phần điều kiện. Nghĩa là không kiểm tra điều kiện trước khi thực hiện vòng lặp. Hay vòng lặp luôn luôn được thực hiện.
Trong mỗi vòng lặp, mình kiểm tra xem nếu giá trịnumberchia hết cho 7 (tức số dư củanumberkhi chia cho 7 bằng 0) thì đó chính là số cần tìm.
`number` `number` Cuối cùng, mình dùng từ khóabreakđể thoát khỏi vòng lặp.
`break` 💡 Tương tự, bạn cũng có thể sử dụng từ khoábreakđối với vòng lặp while và vòng lặp do...while.
`break`"
643,Cấu trúc lặp trong Javascript,Từ khóacontinuetrong JavaScript,"`continue` Từ khoácontinuegần giống từ khóabreak. Nếu như từ khóabreakdùng để thoát khỏi vòng lặp thì từ khóacontinuedùng để dừnglượt lặp hiện tạivà chuyển tới lượt lặp tiếp theo.
`continue` `break` `break` `continue` Ví dụ tìmsố lẻlà bội số nhỏ nhất của 7 và bắt đầu từ số 8:

```js
for (let number = 8; ; number++) {
  if (number % 2 === 0) continue;
  if (number % 7 === 0) {
    console.log(number);
    break;
  }
}

// 21
```
`for (let number = 8; ; number++) {
  if (number % 2 === 0) continue;
  if (number % 7 === 0) {
    console.log(number);
    break;
  }
}

// 21` Khác ví dụ trước, ví dụ này cần tìm ra bội số làsố lẻ. Do đó, mình phải kiểm tra xem số hiện tại là chẵn hay lẻ trước.
Nếunumber % 2 === 0làtruethì suy ra đó là số chẵn. Vì không phải là số lẻ, nên mình dừng lại lượt lặp này để chuyển sang lượt tiếp theo, bằng cách dùng từ khóacontinue.
`number % 2 === 0` `true` `continue` Cho đến khinumberbằng21. Đây là số lẻ nênnumber % 2 === 0làfalse. Mà21chia hết cho7. Nênnumber % 7 === 0trả vềtrue.
`number` `21` `number % 2 === 0` `false` `21` `7` `number % 7 === 0` `true` Vì vậy,21là số cần tìm và cuối cùng làbreak- dừng lại vòng lặp for.
`21` `break` 💡 Từ khóacontinuegiúp làm giảm mức độ code lồng nhau.
`continue` Ví dụ in ra các số chẵn trong đoạn từ 1 đến 5 màkhôngdùng từ khóacontinue:
`continue` 
```js
for (let number = 1; number <= 5; number++) {
  if (number % 2 === 0) {
    console.log(number);
  }
}

// 2
// 4
```
`for (let number = 1; number <= 5; number++) {
  if (number % 2 === 0) {
    console.log(number);
  }
}

// 2
// 4` Ví dụ in ra các số chẵn trong đoạn từ 1 đến 5códùng từ khóacontinue:
`continue` 
```js
for (let number = 1; number <= 5; number++) {
  if (number % 2 !== 0) continue;
  console.log(number);
}

// 2
// 4
```
`for (let number = 1; number <= 5; number++) {
  if (number % 2 !== 0) continue;
  console.log(number);
}

// 2
// 4` Bạn thấy rằng kết quả hai cách làm trên là như nhau, nhưng cách làm sử dụng từ khóacontinuegiúp làm giảm một mức độ code lồng nhau.
`continue` hóacontinue(và từ khóabreak) không thể dùng trong toán tử?.!!!
`continue` `break` `?` Ví dụ sau bị lỗi cú pháp:

```js
for (let number = 1; number <= 5; number++) {
      number % 2 === 0 ? console.log(number) : continue;}

    // Uncaught SyntaxError: Unexpected token 'continue'
```
`for (let number = 1; number <= 5; number++) {
      number % 2 === 0 ? console.log(number) : continue;}

    // Uncaught SyntaxError: Unexpected token 'continue'`"
644,Cấu trúc lặp trong Javascript,Sử dụng label vớibreakvàcontinue,"`break` `continue` Nhiều khi mình cần phải thoát khỏi nhiều vòng lặp lồng nhau, ví dụ:

```js
let done = false;

for (let i = 0; i < 3; i++) {
  if (done) {
    break;
  }
  for (let j = 0; j < 3; j++) {
    if (i * j >= 4) {
      done = true;
      break;
    }

    console.log(i, j);
  }
}
```
`let done = false;

for (let i = 0; i < 3; i++) {
  if (done) {
    break;
  }
  for (let j = 0; j < 3; j++) {
    if (i * j >= 4) {
      done = true;
      break;
    }

    console.log(i, j);
  }
}` Trong đoạn trên, mình cần sử dụng thêm biếndoneđể kiểm tra điều kiện kết thúc.
`done` Vì một từ khóabreakchỉ có tác dụng trong phạm vi một vòng lặp, nên mình cần gán giá trịtruecho biếndoneở vòng lặp bên trong.
`break` `true` `done` Rồi ở vòng lặp ngoài, kiểm tra khi nàodonelàtruethìbreakluôn khỏi vòng lặp ngoài.
`done` `true` `break` Rõ ràng, code trên khá dài dòng. Để giải quyết vấn đề này, bạn có thể dùng ""label"", với cú pháp như sau:

```js
labelName: for (...) {
      // code
      break labelName;
    }
```
`labelName: for (...) {
      // code
      break labelName;
    }` Câu lệnhbreak labelNamegiúp ""thoát khỏi code"" ứng với label.
`break labelName` Đoạn code trên viết lại với label như sau:

```js
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i * j >= 4) {
      break outer;
    }

    console.log(i, j);
  }
}
```
`outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i * j >= 4) {
      break outer;
    }

    console.log(i, j);
  }
}` Từ khóabreakphải nằm trong một ""khối code"" - ""block code"".
`break` Khối code có thể hiểu là đoạn code nằm trong cặp dấu{}ứng với các vòng lặp for, vòng lặp while, vòng lặp do...while, hàm,...).
`{}` Ví dụ sau bị lỗi cú pháp vì dùngbreakở ngoài khối code:
`break` 
```js
let x = 1;

    if (x === 1) {  break;}
    // Uncaught SyntaxError: Illegal break statement
```
`let x = 1;

    if (x === 1) {  break;}
    // Uncaught SyntaxError: Illegal break statement` Với từ khóacontinue, cách sử dụng từ label cũng giống từ khóabreak.
`continue` `break`"
645,Cấu trúc lặp trong Javascript,Tổng kết,"Vòng lặp trong JavaScript có ba loại là:
Nếu điều kiện lặp luôn có giá trịtruthythì cấu trúc lặp sẽ lặp vô hạn.
Để chủ động thoát khỏi vòng lặp, bạn dùng từ khóabreak. Và để thoát khỏi một lượt lặp, bạn dùng từ khóacontinue.
`break` `continue` Từ khóabreakvà từ khóacontinuecó hỗ trợ label, giúp thoát khỏi các vòng lặp lồng nhau dễ dàng hơn.
`break` `continue`"
646,Cấu trúc lặp trong Javascript,Thực hành,"Sử dụngconsole.logđể in ra hình tam giác như sau:
`console.log` 
```js
#
##
###
####
#####
######
#######
```
`#
##
###
####
#####
######
#######` Xem đáp án

```js
let row = """";
for (var i = 1; i <= 7; i++) {
  row += ""#"";
  console.log(row);
}
```
`let row = """";
for (var i = 1; i <= 7; i++) {
  row += ""#"";
  console.log(row);
}` Sử dụngpromptđể yêu cầu người dùng nhập vào một số.
`prompt` Xem đáp án

```js
while (true) {
  const input = prompt(""Enter a number:"");
  const number = Number(input);

  if (isNaN(number)) {
    alert(""It's not a number."");
  } else if (number < 10) {
    alert(""It's too small."");
  } else {
    break;
  }
}
```
`while (true) {
  const input = prompt(""Enter a number:"");
  const number = Number(input);

  if (isNaN(number)) {
    alert(""It's not a number."");
  } else if (number < 10) {
    alert(""It's too small."");
  } else {
    break;
  }
}` Trong đó, hàmisNaN(number)dùng để kiểm tra giá trị của biếnnumberxem có phải làNaNhay không. Nói cách khác, nếuisNaN(number)trả vềfalsethì giá trị củanumberlà số.
`isNaN(number)` `number` `NaN` `isNaN(number)` `false` `number` `console.log` 
```js
#_#_#_#_
_#_#_#_#
#_#_#_#_
_#_#_#_#
#_#_#_#_
_#_#_#_#
#_#_#_#_
_#_#_#_#
```
`#_#_#_#_
_#_#_#_#
#_#_#_#_
_#_#_#_#
#_#_#_#_
_#_#_#_#
#_#_#_#_
_#_#_#_#` Xem đáp án

```js
for (let row = 0; row < 8; row++) {
  let str = """";
  for (let col = 0; col < 8; col++) {
    if (row % 2 === col % 2) {
      str += ""#"";
    } else {
      str += ""_"";
    }
  }
  console.log(str);
}
```
`for (let row = 0; row < 8; row++) {
  let str = """";
  for (let col = 0; col < 8; col++) {
    if (row % 2 === col % 2) {
      str += ""#"";
    } else {
      str += ""_"";
    }
  }
  console.log(str);
}` Xem đáp án

```js
let size; // Nhập số dươngwhile (true) {  size = Number(prompt(""Enter a positive number:""));  if (!isNaN(size) && size > 0) break;}
// In ra màn hình
for (let row = 0; row < size; row++) {
  let str = """";
  for (let col = 0; col < size; col++) {
    if (row % 2 === col % 2) {
      str += ""#"";
    } else {
      str += ""_"";
    }
  }
  console.log(str);
}
```
`let size; // Nhập số dươngwhile (true) {  size = Number(prompt(""Enter a positive number:""));  if (!isNaN(size) && size > 0) break;}
// In ra màn hình
for (let row = 0; row < size; row++) {
  let str = """";
  for (let col = 0; col < size; col++) {
    if (row % 2 === col % 2) {
      str += ""#"";
    } else {
      str += ""_"";
    }
  }
  console.log(str);
}` Yêu cầu người dùng nhập vào một số. Nếu người dùng nhập vào một số dương thì hiển thị ra thông báo xem số đó có phải số nguyên tố hay không.
Xem đáp án

```js
let number;

// Nhập số dương
while (true) {
  number = Number(prompt(""Enter a positive number:""));
  if (!isNaN(number) && number > 0) break;
}

// Kiểm tra số nguyên tố
if (number < 2) {
  alert(""It's not a prime number."");
} else if (number === 2) {
  alert(""It's a prime number."");
} else {
  let isPrimeNumber = true;
  for (let i = 2; i < number; i++) {
    if (number % i === 0) {
      isPrimeNumber = false;
      break;
    }
  }
  if (isPrimeNumber) alert(""It's a prime number."");
  else alert(""It's not a prime number."");
}
```
`let number;

// Nhập số dương
while (true) {
  number = Number(prompt(""Enter a positive number:""));
  if (!isNaN(number) && number > 0) break;
}

// Kiểm tra số nguyên tố
if (number < 2) {
  alert(""It's not a prime number."");
} else if (number === 2) {
  alert(""It's a prime number."");
} else {
  let isPrimeNumber = true;
  for (let i = 2; i < number; i++) {
    if (number % i === 0) {
      isPrimeNumber = false;
      break;
    }
  }
  if (isPrimeNumber) alert(""It's a prime number."");
  else alert(""It's not a prime number."");
}` Có thể bạn chưa biết
Số nguyên tố là số nguyên dương lớn hơn hoặc bằng 2 thỏa mãn điều kiện chỉ chia hết cho 1 và chính nó."
647,Weakmap trong Javascript,Giới thiệu,"WeakMap trong JavaScript là cũng làmột loại object. WeakMap có những đặc điểm giống và khác Map như thế nào?
Sau đây, mình sẽ cùng tìm hiểu về WeakMap trong JavaScript."
648,Weakmap trong Javascript,WeakMap trong JavaScript là gì?,"WeakMap trong JavaScriptlà một cấu trúc cho phép lưu trữ dữ liệu theo kiểukey-valuetương tự nhưMap,Objectvới cú pháp khởi tạo là:

```js
new WeakMap([iterable]);
```
`new WeakMap([iterable]);` Trong đó:
`iterable` `[key, value]` `key` 
```js
let obj = { x: 1 };
let weakMap = new WeakMap();

weakMap.set(obj, 1); // OK - key là object
weakMap.set(""a"", 1); // Lỗi: Invalid value used as weak map key - key là string
```
`let obj = { x: 1 };
let weakMap = new WeakMap();

weakMap.set(obj, 1); // OK - key là object
weakMap.set(""a"", 1); // Lỗi: Invalid value used as weak map key - key là string`"
649,Weakmap trong Javascript,Các phương thức của WeakMap,"Sau đây là các phương thức của WeakMap trong JavaScript.
► Phương thứcweakMap.set(key, value):
`weakMap.set(key, value)` Dùng để lưu giá trịvaluebởi thuộc tínhkeyvà trả về chính WeakMap. Trong đó,keyphải là một object, ngược lại thì báo lỗi.
`value` `key` `key` 
```js
let obj1 = { x: 1 };
let obj2 = { x: 2 };

let weakMap = new WeakMap();
weakMap.set(obj1, 1).set(obj2, 2);
```
`let obj1 = { x: 1 };
let obj2 = { x: 2 };

let weakMap = new WeakMap();
weakMap.set(obj1, 1).set(obj2, 2);` ► Phương thứcweakMap.get(key):
`weakMap.get(key)` Trả về giá trị của thuộc tínhkey, nếukeykhông tồn tại thì trả vềundefined.
`key` `key` `undefined` 
```js
let obj1 = { x: 1 };
let obj2 = { x: 2 };

let weakMap = new WeakMap();
weakMap.set(obj1, 1).set(obj2, 2);

console.log(weakMap.get(obj1)); // 1console.log(weakMap.get({ x: 1 })); // undefined - vì {x:1} !== {x:1}
```
`let obj1 = { x: 1 };
let obj2 = { x: 2 };

let weakMap = new WeakMap();
weakMap.set(obj1, 1).set(obj2, 2);

console.log(weakMap.get(obj1)); // 1console.log(weakMap.get({ x: 1 })); // undefined - vì {x:1} !== {x:1}` ► Phương thứcweakMap.delete(key):
`weakMap.delete(key)` Xóa thuộc tínhkeytrong WeakMap, và trả vềtruenếukeytồn tại, ngược lại thì trả vềfalse.
`key` `true` `key` `false` 
```js
let obj1 = { x: 1 };
let obj2 = { x: 2 };

let weakMap = new WeakMap();
weakMap.set(obj1, 1).set(obj2, 2);

console.log(weakMap.delete(obj1)); // trueconsole.log(weakMap.delete({ x: 1 })); // false - vì {x:1} !== {x:1}
```
`let obj1 = { x: 1 };
let obj2 = { x: 2 };

let weakMap = new WeakMap();
weakMap.set(obj1, 1).set(obj2, 2);

console.log(weakMap.delete(obj1)); // trueconsole.log(weakMap.delete({ x: 1 })); // false - vì {x:1} !== {x:1}` ► Phương thứcweakMap.has(key):
`weakMap.has(key)` Trả vềtruenếukeytồn tại trong WeakMap, ngược lại thì trả vềfalse.
`true` `key` `false` 
```js
let obj1 = { x: 1 };
let obj2 = { x: 2 };

let weakMap = new WeakMap();
weakMap.set(obj1, 1).set(obj2, 2);

console.log(weakMap.has(obj1)); // trueconsole.log(weakMap.has({ x: 1 })); // false - vì {x:1} !== {x:1}
```
`let obj1 = { x: 1 };
let obj2 = { x: 2 };

let weakMap = new WeakMap();
weakMap.set(obj1, 1).set(obj2, 2);

console.log(weakMap.has(obj1)); // trueconsole.log(weakMap.has({ x: 1 })); // false - vì {x:1} !== {x:1}`"
650,Weakmap trong Javascript,So sánh WeakMap và Map,"Sau đây là một số đặc điểm khác nhau giữa WeakMap và Map.
Đối với Map, key có thể thuộc bất kỳ kiểu dữ liệu nào. Nhưng đối với WeakMap thì ngược lại, key chỉ có thể là object.

```js
let map = new Map();
let weakMap = new WeakMap();

map.set(1, ""one""); // OK
weakMap.set(1, ""one""); // Lỗi - Invalid value used as weak map key
```
`let map = new Map();
let weakMap = new WeakMap();

map.set(1, ""one""); // OK
weakMap.set(1, ""one""); // Lỗi - Invalid value used as weak map key` Map là iterable object. Do đó, bạn có thể duyệt qua hết tất cả các phần tử trong Map.
WeakMap không phải là iterable object. Bạn không có cách nào để duyệt hết tất cả các phần tử của WeakMap.

```js
// khởi tạo map
let map = new Map();
map.set(1, ""a"").set(2, ""b"");

// duyệt qua các phần tử của map
for (let item of map) {
  console.log(item);
  /**
   * [1, 'a']
   * [2, 'b']
   */
}

// khởi tạo weakmap
let obj1 = { x: 1 };
let obj2 = { x: 2 };
let weakMap = new WeakMap();
weakMap.set(obj1, ""a"").set(obj2, ""b"");

// duyệt qua các phần tử của weakmap
for (let item of weakMap) {
  console.log(item);
}
/**
 * Lỗi: weakMap is not iterable
 */
```
`// khởi tạo map
let map = new Map();
map.set(1, ""a"").set(2, ""b"");

// duyệt qua các phần tử của map
for (let item of map) {
  console.log(item);
  /**
   * [1, 'a']
   * [2, 'b']
   */
}

// khởi tạo weakmap
let obj1 = { x: 1 };
let obj2 = { x: 2 };
let weakMap = new WeakMap();
weakMap.set(obj1, ""a"").set(obj2, ""b"");

// duyệt qua các phần tử của weakmap
for (let item of weakMap) {
  console.log(item);
}
/**
 * Lỗi: weakMap is not iterable
 */` Như mình đã đề cập ở bài viếtgarbage collection trong JavaScriptthì JavaScript engine giữ một giá trị trong bộ nhớ khi giá trị đó ""có thể tiếp cận"".
Ví dụ về garbage collection:

```js
let alex = { name: ""Alex"" };

// object { name: ""Alex"" } có thể được truy cập bởi biến alex

// ghi đè giá trị của biến alex
alex = null;

// object bị hủy vì không có tham chiếu tới nó
```
`let alex = { name: ""Alex"" };

// object { name: ""Alex"" } có thể được truy cập bởi biến alex

// ghi đè giá trị của biến alex
alex = null;

// object bị hủy vì không có tham chiếu tới nó` Thông thường, thuộc tính của object hoặc phần tử trong mảng,... được coi là ""có thể tiếp cận"" và giữ lại trong bộ nhớ nếu object hoặc mảng chứa chúng vẫn tồn tại.
Ví dụ, mình đẩy một object vào mảng. Và khi mảng đó vẫn tồn tại thì object trong mảng cũng sẽ tồn tại, mặc dù không còn biến tham chiếu đến object.

```js
let alex = { name: ""Alex"" };

// đẩy object vào mảng
let arr = [alex];

// ghi đè giá trị của biến alex
alex = null;

// mặc dù alex bị gán bằng null, nhưng object vẫn tồn tại trong mảng
console.log(arr[0]); // {name: ""Alex""}
```
`let alex = { name: ""Alex"" };

// đẩy object vào mảng
let arr = [alex];

// ghi đè giá trị của biến alex
alex = null;

// mặc dù alex bị gán bằng null, nhưng object vẫn tồn tại trong mảng
console.log(arr[0]); // {name: ""Alex""}` Tương tự, nếu mình sử dụngobjectlàm key cho Map thì khi Map tồn tại,objectcũng sẽ tồn tại và không bị giải phóng.

```js
let alex = { name: ""Alex"" };

// khai báo map và sử dụng biến alex làm key cho map
let map = new Map();
map.set(alex, ""1"");

// ghi đè giá trị của biến alex
alex = null;

// mặc dù biến alex bị gán bằng null, nhưng object alex vẫn tồn tại trong map
console.log(map.size); // 1
for (let item of map) {
  console.log(item);
  /**
   * [{name: 'Alex'}, '1']
   */
}
```
`let alex = { name: ""Alex"" };

// khai báo map và sử dụng biến alex làm key cho map
let map = new Map();
map.set(alex, ""1"");

// ghi đè giá trị của biến alex
alex = null;

// mặc dù biến alex bị gán bằng null, nhưng object alex vẫn tồn tại trong map
console.log(map.size); // 1
for (let item of map) {
  console.log(item);
  /**
   * [{name: 'Alex'}, '1']
   */
}` Nhưng vớiWeakMap thì khác, khi không còn biến tham chiếu đến object thì object đó sẽ bị hủy, ví dụ:

```js
let alex = { name: ""Alex"" };

// khai báo map và sử dụng biến alex làm key cho weakMap
let weakMap = new WeakMap();
weakMap.set(alex, ""1"");

// ghi đè giá trị của biến alex
alex = null;
```
`let alex = { name: ""Alex"" };

// khai báo map và sử dụng biến alex làm key cho weakMap
let weakMap = new WeakMap();
weakMap.set(alex, ""1"");

// ghi đè giá trị của biến alex
alex = null;` Sau khi biếnalexbị gán bằngnull, không còn cách nào có thể truy cập vào phần tử với key làalextrước đó. Vì vậy, object vớialexsẽ bị hủy.
`alex` `null` `alex` `alex` Trên đây là một số điểm khác nhau khi so sánh Map và WeakMap trong JavaScript. Tiếp theo, mình sẽ tìm hiểu một ứng dụng thực tế của WeakMap."
651,Weakmap trong Javascript,Ứng dụng của WeakMap trong lưu trữ dữ liệu,"Ví dụ bạn muốn lưu thông tinsố lần truy cậpcủa một đối tượnguser. Thông tin này được lưu trữ trong mộtmapvới key là đối tượnguservà giá trị là số lượt truy cập.
`user` `user` Khi user rời đi, đối tượnguserbị giải phóng và mong muốn làkhông lưu trữthông tin số lần truy cập với đối tượngusernữa.
`user` `user` Ví dụ module dùng để lưu trữ và xử lý số lượt truy cập nằm trong file thư việnlibrary.js:
`library.js` library.js

```js
// khai báo Map để lưu trữ thông tin số lượt truy cập
let visitsCountMap = new Map();

// tăng số lượt truy cập với tham số user
function countUser(user) {
  // lấy số lượt truy cập hiện tại
  // nếu user chưa có trong map thì visitsCountMap.get(user) trả về undefined
  // khi đó, giá trị mặc định là 0
  let count = visitsCountMap.get(user) || 0;

  // tăng giá trị count lên 1 đơn vị và lưu lại vào thuộc tính user
  visitsCountMap.set(user, count + 1);
}
```
`// khai báo Map để lưu trữ thông tin số lượt truy cập
let visitsCountMap = new Map();

// tăng số lượt truy cập với tham số user
function countUser(user) {
  // lấy số lượt truy cập hiện tại
  // nếu user chưa có trong map thì visitsCountMap.get(user) trả về undefined
  // khi đó, giá trị mặc định là 0
  let count = visitsCountMap.get(user) || 0;

  // tăng giá trị count lên 1 đơn vị và lưu lại vào thuộc tính user
  visitsCountMap.set(user, count + 1);
}` Đoạn code sử dụng:
main.js

```js
let alex = { name: ""Alex"" };

// Cập nhật số lượt truy cập với biến alex
countUser(alex);
// Khi user rời đi, gán biến alex = null
alex = null;
```
`let alex = { name: ""Alex"" };

// Cập nhật số lượt truy cập với biến alex
countUser(alex);
// Khi user rời đi, gán biến alex = null
alex = null;` Khialexgán bằngnull, object{ name: ""Alex"" }nên được giải phòng. Nhưng thực tế thì objectalexvẫn tồn tại trong mapvisitsCountMap.
`alex` `null` `{ name: ""Alex"" }` `alex` `visitsCountMap` Để giải phòng bộ nhớ, bạn cần chủ động gọivisitsCountMap.delete(alex)để xóa thuộc tínhalexkhỏi map, ngược lại objectalexvẫn sẽ được giữ lại.
`visitsCountMap.delete(alex)` `alex` `alex` Tuy nhiên, việc gọideletelà khó khăn vì code xử lý đang nằm trong một file khác. Để tránh việc này, bạn chỉ cần chuyển Map thành WeakMap trong filelibrary.jslà xong:
`delete` `library.js` library.js

```js
// khai báo WeakMap để lưu trữ thông tin số lượt truy cập
let visitsCountMap = new WeakMap();
// tăng số lượt truy cập với tham số user
function countUser(user) {
  // lấy số lượt truy cập hiện tại
  // nếu user chưa có trong map thì visitsCountMap.get(user) trả về undefined
  // khi đó, giá trị mặc định là 0
  let count = visitsCountMap.get(user) || 0;

  // tăng giá trị count lên 1 đơn vị và lưu lại vào thuộc tính user
  visitsCountMap.set(user, count + 1);
}
```
`// khai báo WeakMap để lưu trữ thông tin số lượt truy cập
let visitsCountMap = new WeakMap();
// tăng số lượt truy cập với tham số user
function countUser(user) {
  // lấy số lượt truy cập hiện tại
  // nếu user chưa có trong map thì visitsCountMap.get(user) trả về undefined
  // khi đó, giá trị mặc định là 0
  let count = visitsCountMap.get(user) || 0;

  // tăng giá trị count lên 1 đơn vị và lưu lại vào thuộc tính user
  visitsCountMap.set(user, count + 1);
}` Lúc này, khi biếnalexđược gán bằngnullthì object{ name: ""Alex"" }cũng sẽ bị hủy, vì không có cách nào truy cập đến object đó nữa.
`alex` `null` `{ name: ""Alex"" }`"
652,Weakmap trong Javascript,Ứng dụng của WeakMap trong caching,"Ví dụ bạn muốnlưu kết quả của một lần gọi hàmđể lần sau nếu có gọi lại thì trả về luôn kết quả trước đó.
Cách sử dụng Map thông thường:
cache.js

```js
// khởi tạo Map để làm cache
let cache = new Map();

// tính toán và lưu lại kết quả
function process(obj) {
  // kiểm tra xem trong cache đã có obj chưa
  if (!cache.has(obj)) {
    // nếu chưa có thì tính toán để ra kết quả
    let result = /* tính toán để ra kết quả với obj */ obj;

    // lưu lại kết quả vào cache với key là obj và value là result
    cache.set(obj, result);
  }

  // trả về kết quả ứng với key là obj trong cache
  return cache.get(obj);
}
```
`// khởi tạo Map để làm cache
let cache = new Map();

// tính toán và lưu lại kết quả
function process(obj) {
  // kiểm tra xem trong cache đã có obj chưa
  if (!cache.has(obj)) {
    // nếu chưa có thì tính toán để ra kết quả
    let result = /* tính toán để ra kết quả với obj */ obj;

    // lưu lại kết quả vào cache với key là obj và value là result
    cache.set(obj, result);
  }

  // trả về kết quả ứng với key là obj trong cache
  return cache.get(obj);
}` Sử dụng trong filemain.js:
`main.js` main.js

```js
// objec bất kỳ
let obj = {};

// tính toán với obj được kết quả result1
let result1 = process(obj);

// sau đó ở một đoạn code khác, tính toán với obj để được result2
let result2 = process(obj);

// khi không dùng obj nữa thì gán obj bằng null
obj = null;

// tuy nhiên, kích thước của cache vẫn là 1
// vì object lưu vào cache chưa bị giải phòng
console.log(cache.size); // 1
```
`// objec bất kỳ
let obj = {};

// tính toán với obj được kết quả result1
let result1 = process(obj);

// sau đó ở một đoạn code khác, tính toán với obj để được result2
let result2 = process(obj);

// khi không dùng obj nữa thì gán obj bằng null
obj = null;

// tuy nhiên, kích thước của cache vẫn là 1
// vì object lưu vào cache chưa bị giải phòng
console.log(cache.size); // 1` Để giải phóngcache, bạn phải chủ động gọicache.delete(obj). Tuy nhiên để đơn giản, bạn chỉ cần chuyển Map thành WeakMap đối với biếncachelà xong:
`cache` `cache.delete(obj)` `cache` cache.js

```js
// khởi tạo WeakMap để làm cache
let cache = new WeakMap();
// tính toán và lưu lại kết quả
function process(obj) {
  // kiểm tra xem trong cache đã có obj chưa
  if (!cache.has(obj)) {
    // nếu chưa có thì tính toán để ra kết quả
    let result = /* tính toán để ra kết quả với obj */ obj;

    // lưu lại kết quả vào cache với key là obj và value là result
    cache.set(obj, result);
  }

  // trả về kết quả ứng với key là obj trong cache
  return cache.get(obj);
}
```
`// khởi tạo WeakMap để làm cache
let cache = new WeakMap();
// tính toán và lưu lại kết quả
function process(obj) {
  // kiểm tra xem trong cache đã có obj chưa
  if (!cache.has(obj)) {
    // nếu chưa có thì tính toán để ra kết quả
    let result = /* tính toán để ra kết quả với obj */ obj;

    // lưu lại kết quả vào cache với key là obj và value là result
    cache.set(obj, result);
  }

  // trả về kết quả ứng với key là obj trong cache
  return cache.get(obj);
}` Khi đó, nếuobjbị gán bằngnullthì không còn cách nào để truy cập vào object trongcache, nên object đó sẽ bị giải phóng.
`obj` `null` `cache`"
653,Weakmap trong Javascript,Tổng kết,"WeakMap trong JavaScript tương tự như Map, cho phép lưu trữ dữ liệu theo kiểukey-value. Tuy nhiên, WeakMap chỉ chấp nhận object làm key.
`key-value` Và khi object bị hủy, object tương ứng trong WeakMap sẽ bị giải phóng vì không còn cách nào để truy cập vào object đó nữa.
Các phương thức của WeakMap là:
`weakMap.set(key, value)` `value` `key` `weakMap.get(key)` `key` `key` `undefined` `weakMap.delete(key)` `key` `key` `true` `false` `weakMap.has(key)` `true` `key` `weakMap` `false` WeakMap không phải iterable object nên không có cách nào để duyệt hết các phần tử trong WeakMap (như cách dùngfor...ofvới Map).
`for...of` Tham khảo:"
654,Weakset trong Javascript,Giới thiệu,"WeakSet trong JavaScript cũng là một loại object đặc biệt, dùng đểlưu trữ dữ liệu một cách duy nhất, không trùng lặp - tương tự nhưSet.
Tuy nhiên, cũng giống nhưWeakMap, WeakSet chỉ cho phép lưu trữ dữ liệu kiểuobject(không chấp nhận kiểu nguyên thủy)."
655,Weakset trong Javascript,Cú pháp khởi tạo WeakSet,"Để khởi tạo WeakSet trong JavaScript, bạn sử dụng hàm khởi tạo như sau:

```js
new WeakSet([iterable]);
```
`new WeakSet([iterable]);` Trong đó:
`iterable` Ví dụ:

```js
// khởi tạo WeakSet rỗng
let ws1 = new WeakSet(); // OK

// khởi tạo WeakSet với iterable object với mỗi phần tử là object
let obj1 = { x: 1 };
let ws2 = new WeakSet([obj1]); // OK

// khởi tạo WeakSet với iterable object nhưng mỗi phần tử không phải object
let ws3 = new WeakSet([1, ""2""]); // Lỗi: Invalid value used in weak set
```
`// khởi tạo WeakSet rỗng
let ws1 = new WeakSet(); // OK

// khởi tạo WeakSet với iterable object với mỗi phần tử là object
let obj1 = { x: 1 };
let ws2 = new WeakSet([obj1]); // OK

// khởi tạo WeakSet với iterable object nhưng mỗi phần tử không phải object
let ws3 = new WeakSet([1, ""2""]); // Lỗi: Invalid value used in weak set`"
656,Weakset trong Javascript,Các phương thức của WeakSet,"Sau đây là các phương thức của WeakSet trong JavaScript.
► Phương thứcweakSet.add(value):
`weakSet.add(value)` Thêm giá trịvaluevào WeakSet và trả về chính WeakSet đó.
`value` 
```js
let obj1 = { x: 1 };
let obj2 = { x: 2 };

let ws = new WeakSet();
ws.add(obj1).add(obj2).add(obj1); // OK
// Add value không phải là object vào set
ws.add(1); // Lỗi: Invalid value used in weak set
```
`let obj1 = { x: 1 };
let obj2 = { x: 2 };

let ws = new WeakSet();
ws.add(obj1).add(obj2).add(obj1); // OK
// Add value không phải là object vào set
ws.add(1); // Lỗi: Invalid value used in weak set` ► Phương thứcweakSet.has(value):
`weakSet.has(value)` Trả vềtruenếu giá trịvaluecó tồn tại trong WeakSet, ngược lại thì trả vềfalse.
`true` `value` `false` 
```js
let obj1 = { x: 1 };
let obj2 = { x: 2 };

let ws = new WeakSet();
ws.add(obj1).add(obj2).add(obj1);

console.log(ws.has(obj1)); // trueconsole.log(ws.has(obj2)); // trueconsole.log(ws.has({ x: 1 })); // false
```
`let obj1 = { x: 1 };
let obj2 = { x: 2 };

let ws = new WeakSet();
ws.add(obj1).add(obj2).add(obj1);

console.log(ws.has(obj1)); // trueconsole.log(ws.has(obj2)); // trueconsole.log(ws.has({ x: 1 })); // false` Vì object là kiểu dữ liệu tham chiếu nên{x: 1} !== {x: 1}. Do đó, câu lệnhws.has({ x: 1 })trả vềfalse.
`{x: 1} !== {x: 1}` `ws.has({ x: 1 })` `false` ► Phương thứcweakSet.delete(value):
`weakSet.delete(value)` Xóa giá trịvaluekhỏi WeakSet và trả vềtruenếu giá trị đó tồn tại, ngược lại thì trả vềfalse.
`value` `true` `false` 
```js
let obj1 = { x: 1 };
let obj2 = { x: 2 };

let ws = new WeakSet();
ws.add(obj1).add(obj2).add(obj1);

console.log(ws.delete(obj1)); // trueconsole.log(ws.delete(obj2)); // trueconsole.log(ws.delete({ x: 1 })); // falseconsole.log(ws.delete(obj1)); // false
```
`let obj1 = { x: 1 };
let obj2 = { x: 2 };

let ws = new WeakSet();
ws.add(obj1).add(obj2).add(obj1);

console.log(ws.delete(obj1)); // trueconsole.log(ws.delete(obj2)); // trueconsole.log(ws.delete({ x: 1 })); // falseconsole.log(ws.delete(obj1)); // false` Tương tự như trên, vì object là kiểu dữ liệu tham chiếu nên{x: 1} !== {x: 1}. Do đó, câu lệnhws.delete({ x: 1 })trả vềfalse.
`{x: 1} !== {x: 1}` `ws.delete({ x: 1 })` `false` Câu lệnh cuối cùngws.delete(obj1)cũng trả vềfalsevì trước đó mình đã xóa giá trịobj1ra khỏiwsrồi.
`ws.delete(obj1)` `false` `obj1` `ws`"
657,Weakset trong Javascript,So sánh WeakSet và Set,"Sau đây là một số đặc điểm khác nhau giữa Set và WeakSet trong JavaScript.
Đối với Set, key có thể thuộc bất kỳ kiểu dữ liệu nào. Nhưng đối với WeakSet thì ngược lại, keychỉ có thể là object.

```js
let set = new Set();
let weakSet = new WeakSet();

set.add(1); // OK
weakSet.add(1); // Lỗi - Invalid value used in weak set
```
`let set = new Set();
let weakSet = new WeakSet();

set.add(1); // OK
weakSet.add(1); // Lỗi - Invalid value used in weak set` Set là iterable object. Do đó, bạn có thể duyệt qua hết tất cả các phần tử trong Set.
WeakSet không phải là iterable object. Bạn không có cách nào để duyệt hết tất cả các phần tử của WeakSet.

```js
// khởi tạo set
let set = new Set();
set.add(1).add(""b"");

// duyệt qua các phần tử của set
for (let item of set) {
  console.log(item);
  /**
   * 1
   * 'b'
   */
}

// khởi tạo weakSet
let obj1 = { x: 1 };
let obj2 = { x: 2 };
let weakSet = new WeakSet();
weakSet.add(obj1).add(obj2);

// duyệt qua các phần tử của weakSet
for (let item of weakSet) {
  console.log(item);
}
/**
 * Lỗi: weakSet is not iterable
 */
```
`// khởi tạo set
let set = new Set();
set.add(1).add(""b"");

// duyệt qua các phần tử của set
for (let item of set) {
  console.log(item);
  /**
   * 1
   * 'b'
   */
}

// khởi tạo weakSet
let obj1 = { x: 1 };
let obj2 = { x: 2 };
let weakSet = new WeakSet();
weakSet.add(obj1).add(obj2);

// duyệt qua các phần tử của weakSet
for (let item of weakSet) {
  console.log(item);
}
/**
 * Lỗi: weakSet is not iterable
 */` Khi một biến là object được lưu vào Set, dù biến đó có bị gán bằngnullthì object vẫn tồn tại trong Set.
`null` 
```js
// khởi tạo object
let obj1 = { x: 1 };

// khởi tạo set và thêm object trên vào set
let set = new Set();
set.add(obj1);

// gán obj1 bằng null
obj1 = null;

// mặc dù obj1 được gán thành null, nhưng object vẫn tồn tại trong set
console.log(set.size); // 1
for (let item of set) {
  console.log(item); // {x: 1}
}
```
`// khởi tạo object
let obj1 = { x: 1 };

// khởi tạo set và thêm object trên vào set
let set = new Set();
set.add(obj1);

// gán obj1 bằng null
obj1 = null;

// mặc dù obj1 được gán thành null, nhưng object vẫn tồn tại trong set
console.log(set.size); // 1
for (let item of set) {
  console.log(item); // {x: 1}
}` Đối với WeakSet thì ngược lại, một khi biến object được gán bằngnullthì không có cách nào truy cập vào phần tử đó trong Set. Do đó, object sẽ được giải phóng.
`null`"
658,Weakset trong Javascript,Tổng kết,"WeakSet trong JavaScript tương tự như Set, cho phéplưu trữ dữ liệu một cách duy nhất, không trùng lặp. Tuy nhiên, WeakSet chỉ chấp nhận phần tử kiểu object.
Và khi object bị hủy, object tương ứng trong WeakSet sẽ bị giải phóng vì không còn cách nào để truy cập vào object đó nữa.
Các phương thức của WeakSet là:
`weakSet.add(value)` `value` `weakSet.delete(value)` `value` `value` `true` `false` `weakSet.has(value)` `true` `value` `weakSet` `false` WeakSet không phải iterable object nên không có cách nào để duyệt hết các phần tử trong WeakSet (như cách dùngfor...ofvới Set).
`for...of` Tham khảo:WeakMap and WeakSet"
659,Javascript Web worker api là gì,Giới thiệu,"Có thể bạn thừa biết, JavaScript là một ngôn ngữ chạyđơn luồng. Điều đó có nghĩa là nếu bạn thực hiện một tác vụ quá lớn trên giao diện chính thì khả năng cao là giao diện sẽ bị đơ. Để giải quyết vấn đề này, JavaScript đã đưa ra một khái niệm là Worker. Vậy JavaScript Web Worker là gì và dùng nó như thế nào? Chúng ta sẽ cùng nhau tìm hiểu sau đây."
660,Javascript Web worker api là gì,JavaScript Web Worker là gì?,"Web Worker là một phương tiện đơn giản giúp cho trang web có thể chạy JavaScipt ở background. Luồng này có thể chạy mà không can thiệp gì đến giao diện chính. Một khi đã được khởi tạo, Worker có thể giao tiếp với luồng chính thông qua việc gửi và nhận message.
Vì vậy, khi áp dụng JavaScript Web Worker một cách chính xác và phù hợp, trang web của bạn sẽ hoạt động mượt mà hơn rất nhiều."
661,Javascript Web worker api là gì,Cách sử dụng JavaScript Web Worker,"Để kiểm tra xem trình duyệt bạn đang sử dụng có hỗ trợ JavaScript Web Worker hay không, bạn có thể sử dụngtypeof:

```js
if (typeof Worker !== ""undefined"") {
  // Có hỗ trợ JavaScript Web Worker
} else {
  // Không hỗ trợ JavaScript Web Worker
}
```
`if (typeof Worker !== ""undefined"") {
  // Có hỗ trợ JavaScript Web Worker
} else {
  // Không hỗ trợ JavaScript Web Worker
}` Một ví dụ đơn giản cho file JavaScript Web Worker:

```js
for (var i = 0; i < 10000000000; i++) {
  if (i % 1000000000 == 0) postMessage(i);
}

self.onmessage = function (msg) {
  // Được gọi khi có message gửi từ luồng chính
};
```
`for (var i = 0; i < 10000000000; i++) {
  if (i % 1000000000 == 0) postMessage(i);
}

self.onmessage = function (msg) {
  // Được gọi khi có message gửi từ luồng chính
};` Giả sử bạn đã tạo một fileweb_worker.js. Để khởi tạo Web Worker, bạn làm như sau:

```js
var w;

function startWorker() {
  // Kiểm tra xem trình duyệt có hỗ trợ JavaScript Web Worker
  if (typeof Worker !== ""undefined"") {
    // Kiểm tra đối tượng Web Worker đã được khởi tạo hay chưa
    if (typeof w == ""undefined"") {
      // Khởi tạo Web Worker
      w = new Worker(""web_worker.js"");
    }
    w.onmessage = function (event) {
      // Được gọi khi có message từ Web Worker gửi đến
    };
    w.onerror = function () {
      // Khi có lỗi xảy ra với Web Worker
    };
  } else {
    // Trình duyệt không hỗ trợ JavaScript Web Worker
  }
}
```
`var w;

function startWorker() {
  // Kiểm tra xem trình duyệt có hỗ trợ JavaScript Web Worker
  if (typeof Worker !== ""undefined"") {
    // Kiểm tra đối tượng Web Worker đã được khởi tạo hay chưa
    if (typeof w == ""undefined"") {
      // Khởi tạo Web Worker
      w = new Worker(""web_worker.js"");
    }
    w.onmessage = function (event) {
      // Được gọi khi có message từ Web Worker gửi đến
    };
    w.onerror = function () {
      // Khi có lỗi xảy ra với Web Worker
    };
  } else {
    // Trình duyệt không hỗ trợ JavaScript Web Worker
  }
}` Bạn thấy sau khi khởi tạo JavaScript Web Worker, ta có thể implement haifunctionquan trọng làWorker.onmessagevàWorker.onerrorđể xử lýevent.
Trong đó,Worker.onerrorđược gọi khi có lỗi với Web Worker sau khi khởi tạo. VàWorker.onmessageđược gọi khi có message từ Worker Thread lên giao diện chính.
Sau khi khởi tạo Web Worker thì code JavaScript ở background sẽ chạy. Để dừng Web Worker lại, bạn có thể sử dụng phương thứcterminate().

```js
w.terminate();
```
`w.terminate();` Để có thể thực hiện được điều này, bạn có thể sử dụng phương thứcpostMessage(), ở cả hai phía luồng chính và background. Khi đó, hàmonmessage()sẽ được gọi ở đầu còn lại.
Đối với hàmpostMessage()sẽ có hai cách sử dụng:
Trong phương pháp này, tham số truyền vào sẽ là mộtobject. Dữ liệu sẽ được copy từ phía gửi sang phía nhận.
Ví dụ như sau:

```js
function startWorker() {
  if (typeof myWorker != ""undefined"") {
    myWorker.postMessage({ cmd: ""start"", msg: ""hello"" });
  } else {
    console.log(""[Main]"", ""Worker is undefined."");
  }
}
```
`function startWorker() {
  if (typeof myWorker != ""undefined"") {
    myWorker.postMessage({ cmd: ""start"", msg: ""hello"" });
  } else {
    console.log(""[Main]"", ""Worker is undefined."");
  }
}` Ở đây object gửi đi sẽ là{cmd : 'start', msg : 'hello'}. Thực tế, object ở đây có thể là bất kì kiểu dữ liệu nào:Number, String, Boolean,Array.
Và ở Worker Thread, hàmonmessagesẽ được gọi:

```js
self.onmessage = function (event) {
  handleMessage(event);
};

function handleMessage(event) {
  console.log(
    ""[Worker]"",
    ""Worker Thread receives command: "",
    event.data.cmd,
    event.data.msg
  );
  if (event.data.cmd == ""start"") {
    for (var i = 0; i <= 10000000000; i++) {
      if (i % 1000000000 == 0) postMessage({ cmd: ""resp"", msg: i });
    }
  } else if (event.data.cmd == ""stop"") {
    postMessage({ cmd: ""stop"", msg: ""Good Bye!"" });
    self.close();
  }
}
```
`self.onmessage = function (event) {
  handleMessage(event);
};

function handleMessage(event) {
  console.log(
    ""[Worker]"",
    ""Worker Thread receives command: "",
    event.data.cmd,
    event.data.msg
  );
  if (event.data.cmd == ""start"") {
    for (var i = 0; i <= 10000000000; i++) {
      if (i % 1000000000 == 0) postMessage({ cmd: ""resp"", msg: i });
    }
  } else if (event.data.cmd == ""stop"") {
    postMessage({ cmd: ""stop"", msg: ""Good Bye!"" });
    self.close();
  }
}` Object nhận được từ phía giao diện chính sẽ được lấy từdatatrongevent.

```js
console.log(
  ""[Worker]"",
  ""Worker Thread receives command: "",
  event.data.cmd,
  event.data.msg
);
// => [Worker] Worker Thread receives command: start hello
```
`console.log(
  ""[Worker]"",
  ""Worker Thread receives command: "",
  event.data.cmd,
  event.data.msg
);
// => [Worker] Worker Thread receives command: start hello` Để test chức năng này, mình có chuẩn bị một ví dụ nhỏ trênGithubvàcodepenmà bạn có thể tham khảo.
Cách này có một nhược điểm là nếu như bạn gửi dữ liệu lớn, chẳng hạn 500MB, thì sau khi gửi đi, nó sẽ được sao chép. Vì vậy, tổng dữ liệu chiếm sẽ là 500MB + 500MB = 1GB. Điều đó có thể dẫn đến hết bộ nhớ cho phép. Để khắc phục tình trạng này, ta có thể sử dụng Transferable Object như sau.
Khi sử dụngTransferable Object, dữ liệu được chuyển toàn bộ từ phía gửi sang phía nhận. Dung lượng dữ liệu phía gửi sẽ bị xóa về 0.
Ví dụ:
Phía Main Thread:

```js
function startWorker() {
  if (typeof myWorker != ""undefined"") {
    var arrBuf1 = new ArrayBuffer(1000);
    var arrBuf2 = new ArrayBuffer(100000);

    console.log(""[Main]"", ""Before Transfering:"");
    console.log(""[Main]"", ""Length of Array Buffer 1:"", arrBuf1.byteLength);
    console.log(""[Main]"", ""Length of Array Buffer 2:"", arrBuf2.byteLength);

    myWorker.postMessage({ cmd: ""start"", buf1: arrBuf1, buf2: arrBuf2 }, [
      arrBuf1,
      arrBuf2,
    ]);

    console.log(""[Main]"", ""After Transfering:"");
    console.log(""[Main]"", ""Length of Array Buffer 1:"", arrBuf1.byteLength);
    console.log(""[Main]"", ""Length of Array Buffer 2:"", arrBuf2.byteLength);
  } else {
    console.log(""[Main]"", ""Worker is undefined."");
  }
}
```
`function startWorker() {
  if (typeof myWorker != ""undefined"") {
    var arrBuf1 = new ArrayBuffer(1000);
    var arrBuf2 = new ArrayBuffer(100000);

    console.log(""[Main]"", ""Before Transfering:"");
    console.log(""[Main]"", ""Length of Array Buffer 1:"", arrBuf1.byteLength);
    console.log(""[Main]"", ""Length of Array Buffer 2:"", arrBuf2.byteLength);

    myWorker.postMessage({ cmd: ""start"", buf1: arrBuf1, buf2: arrBuf2 }, [
      arrBuf1,
      arrBuf2,
    ]);

    console.log(""[Main]"", ""After Transfering:"");
    console.log(""[Main]"", ""Length of Array Buffer 1:"", arrBuf1.byteLength);
    console.log(""[Main]"", ""Length of Array Buffer 2:"", arrBuf2.byteLength);
  } else {
    console.log(""[Main]"", ""Worker is undefined."");
  }
}` Phía Worker Thread:

```js
self.onmessage = function (event) {
  handleMessage(event);
};

function handleMessage(event) {
  console.log(""[Worker]"", ""Worker Thread receives command: "", event.data.cmd);

  if (event.data.cmd == ""start"") {
    console.log(
      ""[Worker]"",
      ""Length of Array Buffer 1:"",
      event.data.buf1.byteLength
    );

    console.log(
      ""[Worker]"",
      ""Length of Array Buffer 2:"",
      event.data.buf2.byteLength
    );
  }
}
```
`self.onmessage = function (event) {
  handleMessage(event);
};

function handleMessage(event) {
  console.log(""[Worker]"", ""Worker Thread receives command: "", event.data.cmd);

  if (event.data.cmd == ""start"") {
    console.log(
      ""[Worker]"",
      ""Length of Array Buffer 1:"",
      event.data.buf1.byteLength
    );

    console.log(
      ""[Worker]"",
      ""Length of Array Buffer 2:"",
      event.data.buf2.byteLength
    );
  }
}` Ở đây, Transferable Object làArrayBuffer.
Kết quả:
Kết quả
[Main] Init Web Worker[Main] Before Transfering:[Main] Length of Array Buffer 1: 1000[Main] Length of Array Buffer 2: 100000[Main] After Transfering:[Main] Length of Array Buffer 1: 0[Main] Length of Array Buffer 2: 0// Độ dài của Array Buffer sau khi gửi sẽ là 0// vì nó được chuyển sang phía Worker Thread.
[Worker] Worker Thread receives command: start[Worker] Length of Array Buffer 1: 1000[Worker] Length of Array Buffer 2: 100000
Lưu ý
Bài viết hôm nay dừng lại tại đây. Để tìm hiểu thêm về JavaScript Web Worker thì bạn có thể tìm hiểu thêm ở những link phía dưới đây."
662,"Thuộc tính writable, enumerable và configurable của object trong Javascript",Giới thiệu,"Trong các bài viết trước, bạn mới chỉ biếtthuộc tính của objecttrong JavaScript có dạngkey-value. Thực tế thì thuộc tính trong object có nhiều tính chất khác nữa. Trong đó,writable, enumerable và configurablelà những cờ quan trọng để cấu hình cho thuộc tính."
663,"Thuộc tính writable, enumerable và configurable của object trong Javascript",Các cờ cho thuộc tính,"Writable, enumerable và configurable làba cờ đặc biệt trong object, trong đó:
`writable` `true` `value` `enumerable` `true` `configurable` `true` Khi bạnkhởi tạo đối tượng theo cách thông thườngthì các cờ nàykhông xuất hiệnvà có giá trị mặc định làtrue.
`true` Để lấy thông tin của các cờ này, bạn có thể dùng phương thứcObject.getOwnPropertyDescriptorvới cú pháp cơ bản là:
`Object.getOwnPropertyDescriptor` 
```js
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
```
`let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);` Trong đó:
`obj` `propertyName` Giá trị trả về của phương thức trên gọi là objectproperty descriptor(tạm hiểu là ""đối tượng mô tả thuộc tính"") - chứa thông tin vềvaluevà các cờwritable,enumerable,configurable, ví dụ:
`value` `writable` `enumerable` `configurable` 
```js
let user = {
  name: ""Alex"",
};

let descriptor = Object.getOwnPropertyDescriptor(user, ""name"");

console.log(JSON.stringify(descriptor, null, 2));

/*
    {
      ""value"": ""Alex"",
      ""writable"": true,
      ""enumerable"": true,
      ""configurable"": true
    }
    */
```
`let user = {
  name: ""Alex"",
};

let descriptor = Object.getOwnPropertyDescriptor(user, ""name"");

console.log(JSON.stringify(descriptor, null, 2));

/*
    {
      ""value"": ""Alex"",
      ""writable"": true,
      ""enumerable"": true,
      ""configurable"": true
    }
    */` Để thay đổi giá trị của các cờwritable,enumerable,configurable, bạn có thể sử dụng phương thứcObject.definePropertyvới cú pháp:
`writable` `enumerable` `configurable` `Object.defineProperty` 
```js
Object.defineProperty(obj, propertyName, descriptor);
```
`Object.defineProperty(obj, propertyName, descriptor);` Trong đó:
`obj` `propertyName` `descriptor` Nếu thuộc tínhpropertyNametồn tại thì phương thức trên sẽcập nhật giá trịcủa các cờ theodescriptor, ngược lại thì tạo thuộc tính mới. Trong trường hợp một cờ nào đó không được cung cấp thìgiá trị mặc địnhcủa cờ làfalse.
`propertyName` `descriptor` `false` Ví dụ sau tạo thuộc tínhnamevới các cờwritable,enumerable,configurableđều làfalse:
`name` `writable` `enumerable` `configurable` `false` 
```js
let user = {};

Object.defineProperty(user, ""name"", {
  value: ""Alex"",
});

let descriptor = Object.getOwnPropertyDescriptor(user, ""name"");

console.log(JSON.stringify(descriptor, null, 2));
/*
    {
      ""value"": ""Alex"",
      ""writable"": false,
      ""enumerable"": false,
      ""configurable"": false
    }
     */
```
`let user = {};

Object.defineProperty(user, ""name"", {
  value: ""Alex"",
});

let descriptor = Object.getOwnPropertyDescriptor(user, ""name"");

console.log(JSON.stringify(descriptor, null, 2));
/*
    {
      ""value"": ""Alex"",
      ""writable"": false,
      ""enumerable"": false,
      ""configurable"": false
    }
     */` Lưu ý
Đối với cách tạo object thông thường thì các cờwritable,enumerable,configurablecó giá trị mặc định làtrue.
`writable` `enumerable` `configurable` `true` Trên đây là kiến thức chung về các cờ. Tiếp theo mình sẽ xem xét ý nghĩa của từng cờ."
664,"Thuộc tính writable, enumerable và configurable của object trong Javascript",Thuộc tính chỉ đọc non-writable,"Giả sử, mình muốn tạo thuộc tínhuser.namelà thuộc tính chỉ đọc -non-writablehayread-onlybằng cách setwritable=falsenhư sau:
`user.name` `writable=false` 
```js
""use strict"";

let user = {
  name: ""Alex"",
};

Object.defineProperty(user, ""name"", { writable: false });
user.name = ""Anna"";
// Error: Cannot assign to read only property 'name' of object '#<Object>'
```
`""use strict"";

let user = {
  name: ""Alex"",
};

Object.defineProperty(user, ""name"", { writable: false });
user.name = ""Anna"";
// Error: Cannot assign to read only property 'name' of object '#<Object>'` Rõ ràng là mình không thể thay đổi giá trị của thuộc tínhnamekhiwritable=false.
`name` `writable=false` Lưu ý
Lỗi trên chỉ được in ra khi sử dụng code ởstrict mode.
Đối với chế độ thông thường thì sẽ không có dòng lỗi trên, dù cho việc thay đổi giá trị của thuộc tínhnamevẫn không được phép.
`name` Tiếp theo là ví dụ tạo thuộc tính bằng phương thứcdefineProperty:
`defineProperty` 
```js
""use strict"";

let user = {};

Object.defineProperty(user, ""name"", {
  value: ""Alex"",
  enumerable: true,
  configurable: true,
});
console.log(user.name); // Alex
user.name = ""Anna""; // Error
```
`""use strict"";

let user = {};

Object.defineProperty(user, ""name"", {
  value: ""Alex"",
  enumerable: true,
  configurable: true,
});
console.log(user.name); // Alex
user.name = ""Anna""; // Error` Trong ví dụ trên, cờwritablekhông được khai báo thì giá trị mặc định của cờ này làfalse. Do đó, thuộc tínhuser.namecũng lànon-writable.
`writable` `false` `user.name`"
665,"Thuộc tính writable, enumerable và configurable của object trong Javascript",Thuộc tính non-enumerable,"Giả sử, mình thêm phương thứctoStringcho đối tượngusertrên. Mặc định thìtoStringsẽ xuất hiện trong vòng lặpfor...innhư sau:
`toString` `user` `toString` `for...in` 
```js
let user = {
  name: ""Alex"",
  toString() {
    return this.name;
  },
};

for (let key in user) console.log(key); // name, toString
```
`let user = {
  name: ""Alex"",
  toString() {
    return this.name;
  },
};

for (let key in user) console.log(key); // name, toString` Nếu mình không muốn phương thứctoStringxuất hiện trong vòng lặpfor...inthì có thể setenumerable=false:
`toString` `for...in` `enumerable=false` 
```js
let user = {
  name: ""Alex"",
  toString() {
    return this.name;
  },
};
Object.defineProperty(user, ""toString"", { enumerable: false });
for (let key in user) console.log(key); // name
```
`let user = {
  name: ""Alex"",
  toString() {
    return this.name;
  },
};
Object.defineProperty(user, ""toString"", { enumerable: false });
for (let key in user) console.log(key); // name` Bây giờ thìtoStringđã không xuất hiện trong vòng lặpfor...in. Nói cách khác,toStringtrở thành thuộc tínhnon-enumerable.
`toString` `for...in` `toString` Khi sử dụng phương thứcObject.keysđể lấytất cả keytrong object, các thuộc tínhnon-enumerablecũng được bỏ qua:
`Object.keys` 
```js
let user = {
  name: ""Alex"",
  toString() {
    return this.name;
  },
};

Object.defineProperty(user, ""toString"", {
  enumerable: false,
});

console.log(Object.keys(user)); // ['name']
```
`let user = {
  name: ""Alex"",
  toString() {
    return this.name;
  },
};

Object.defineProperty(user, ""toString"", {
  enumerable: false,
});

console.log(Object.keys(user)); // ['name']`"
666,"Thuộc tính writable, enumerable và configurable của object trong Javascript",Thuộc tính non-configurable,"Cờconfigurablevớiconfigurable=falsethường được set cho các thuộc tính của cácđối tượng sẵn cótrong JavaScript.
`configurable=false` Khi đó, thuộc tính gọi lànon-configurable- không thể xóa và các cờ khác không thể thay đổi.
Ví dụMath.PIlànon-writable, non-enumerable and non-configurable:
`Math.PI` 
```js
let descriptor = Object.getOwnPropertyDescriptor(Math, ""PI"");

console.log(JSON.stringify(descriptor, null, 2));
/*
{
  ""value"": 3.141592653589793,
  ""writable"": false,
  ""enumerable"": false,
  ""configurable"": false
}
*/
```
`let descriptor = Object.getOwnPropertyDescriptor(Math, ""PI"");

console.log(JSON.stringify(descriptor, null, 2));
/*
{
  ""value"": 3.141592653589793,
  ""writable"": false,
  ""enumerable"": false,
  ""configurable"": false
}
*/` Bạn không thể thay đổi giá trị củaPI:
`PI` 
```js
Math.PI = 3; // => Lỗi, giá trị của PI không thể thay đổi
```
`Math.PI = 3; // => Lỗi, giá trị của PI không thể thay đổi` Và bạn cũng không thể thay đổiPIthànhwritable:
`PI` 
```js
Object.defineProperty(Math, ""PI"", { writable: true });
// Lỗi: Cannot redefine property: PI
```
`Object.defineProperty(Math, ""PI"", { writable: true });
// Lỗi: Cannot redefine property: PI` Nghĩa là việc tạo ra thuộc tínhnon-configurablelà ""một chiều"". Bạn không thể thay đổi các cờ bằng phương thứcdefinePropertyđược nữa.
`defineProperty` Chú ý:việc gánconfigurable=falsechỉngăn chặnviệc thay đổi giá trị của các cờ và việc xóa thuộc tính. Tuy nhiên, giá trị của thuộc tính vẫn có thể thay đổi.
`configurable=false` 
```js
""use strict"";

let user = {
  name: ""Alex"",
};

Object.defineProperty(user, ""name"", {
  configurable: false,
});

user.name = ""Anna"";
console.log(user.name); // Anna

delete user.name;
// Lỗi: Cannot delete property 'name' of #<Object>
```
`""use strict"";

let user = {
  name: ""Alex"",
};

Object.defineProperty(user, ""name"", {
  configurable: false,
});

user.name = ""Anna"";
console.log(user.name); // Anna

delete user.name;
// Lỗi: Cannot delete property 'name' of #<Object>` Trong ví dụ trên, giá trị củauser.namecó thể thay đổi, nhưng không thể bị xóa. Để ngăn chặn việc thay đổi giá trị củauser.namegiống nhưMath.PI, bạn có thể gán thêmwritable=false:
`user.name` `user.name` `Math.PI` `writable=false` 
```js
""use strict"";

let user = {
  name: ""Alex"",
};

Object.defineProperty(user, ""name"", {
  writable: false,
  configurable: false,
});

user.name = ""Anna"";
// Lỗi: Cannot assign to read only property 'name' of object '#<Object>'

delete user.name;
// Lỗi: Cannot delete property 'name' of #<Object>
```
`""use strict"";

let user = {
  name: ""Alex"",
};

Object.defineProperty(user, ""name"", {
  writable: false,
  configurable: false,
});

user.name = ""Anna"";
// Lỗi: Cannot assign to read only property 'name' of object '#<Object>'

delete user.name;
// Lỗi: Cannot delete property 'name' of #<Object>`"
667,"Thuộc tính writable, enumerable và configurable của object trong Javascript",Phương thức Object.defineProperties,"Phương thứcObject.definePropertybên trên chỉ định nghĩa một thuộc tính.
`Object.defineProperty` Đểđịnh nghĩa nhiều thuộc tính cùng một lúc, bạn có thể sử dụng phương thứcObject.definePropertiesvới cú pháp là:
`Object.defineProperties` 
```js
Object.defineProperties(obj, {
  prop1: descriptor1,
  prop2: descriptor2,
  // ...
});
```
`Object.defineProperties(obj, {
  prop1: descriptor1,
  prop2: descriptor2,
  // ...
});` Ví dụ:

```js
Object.defineProperties(user, {
  name: { value: ""David"", writable: false },
  surname: { value: ""Walsh"", writable: false },
});
```
`Object.defineProperties(user, {
  name: { value: ""David"", writable: false },
  surname: { value: ""Walsh"", writable: false },
});`"
668,"Thuộc tính writable, enumerable và configurable của object trong Javascript",Phương thức Object.getOwnPropertyDescriptors,"Để lấy tất cả các đối tượng ""property descriptor"" của một object, bạn có thể sử dụng phương thứcObject.getOwnPropertyDescriptors(obj).
`Object.getOwnPropertyDescriptors(obj)` Và khi kết hợp phương thức trên vớiObject.defineProperties, bạn có một cách đểclone objectnhư sau:
`Object.defineProperties` 
```js
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
```
`let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));` Khiclone object, ta thường chỉcopy giá trị các thuộc tínhnhư sau:

```js
for (let key in user) {
  clone[key] = user[key];
}
```
`for (let key in user) {
  clone[key] = user[key];
}` Tuy nhiên, cách làm trên không thực hiện copy giá trị các cờwritable,enumerablevàconfigurable.
`writable` `enumerable` `configurable` Do đó, nếu bạn muốnclone objecttốt hơn (bao gồm giá trị của tất cả các cờ) thì cách làm trên là hoàn toàn phù hợp."
669,"Thuộc tính writable, enumerable và configurable của object trong Javascript",Các phương thức khác,"JavaScript cung cấp các phương thức giúp bạn thao tác với object giống như việc thay đổi giá trị cờwritable,enumerablevàconfigurablenhưng dễ dàng hơn.
`writable` `enumerable` `configurable` ►Object.preventExtensions(obj)
Giúp ngăn chặn việcthêm các thuộc tínhvào object.
►Object.seal(obj)
Giúp ngăn chặn việcthêm/xóacác thuộc tính. Tương đương với việc setconfigurable: falsecho tất cả các thuộc tính.
`configurable: false` ►Object.freeze(obj)
Giúp ngăn chặn việcthêm/xóa/thay đổi giá trịcác thuộc tính. Tương đương với việc setconfigurable: false, writable: falsecho tất cả các thuộc tính.
`configurable: false, writable: false` ►Object.isExtensible(obj)
Trả vềfalsenếu việcthêm các thuộc tínhvào object bị cấm, ngược lại trả vềtrue.
`false` `true` ►Object.isSealed(obj)
Trả vềtruenếu việcthêm/xóathuộc tính là bị cấm, ngược lại trả vềfalse.
`true` `false` ►Object.isFrozen(obj)
Trả vềtruenếu việcthêm/xóa/thay đổi giá trịcác thuộc tính là bị cấm, ngược lại trả vềfalse.
`true` `false` Tham khảo:Property flags and descriptors"
670,XML Http request với Promise,Giới thiệu,"Nếu các bạn đã đọc qua bài viết của mình vềXMLHttpRequest, thì sẽ biết rằng có 2 cách sử dụng đối tượng này là:đồng bộvàbất đồng bộ. Với xử lý đồng bộ, bạn quản lý chương trình dễ hơn, nhưng thường nó sẽ chạy chậm. Trong khi xử lý bất đồng bộ, chương trình chạy nhanh hơn nhưng code sẽ khó khăn hơn. Vì vậy, bài viết này sẽ hướng dẫn các bạn kết hợp XMLHttpRequest vớiPromise JavaScripttrong xử lý bất đồng bộ."
671,XML Http request với Promise,Promise JavaScript là gì?,"Promise JavaScript là mộtđối tượngcho phép bạn thực hiện những tác vụ bất đồng bộ. Sau đây là cách sử dụng cơ bản của Promise (sử dụng ES6):

```js
let p = new Promise((resolve, reject) => {
  // Do an async task and then...
  if(/* good condition */)
    resolve(data);
  else
    reject(error);
});

p.then(
  data => { /* do something with the result */ },
  error => { /* error */ }
)
.catch((event) => {
    /* do something with other errors here */
});
```
`let p = new Promise((resolve, reject) => {
  // Do an async task and then...
  if(/* good condition */)
    resolve(data);
  else
    reject(error);
});

p.then(
  data => { /* do something with the result */ },
  error => { /* error */ }
)
.catch((event) => {
    /* do something with other errors here */
});` Khi tạo mới một đối tượng Promise, tham số truyền vào sẽ là 2 hàm sốresolvevàreject- tương tự như các hàmcallback. Đúng như tên gọi của chúng, resolve dùng để xử lý khi tác vụ bất đồng bộ thành công. Ngược lại, reject dùng để xử lý khi tác vụ đó thất bại.
Tuy nhiên, resolve và reject ở đây chỉ là tên gọi. Thực tế, chúng sẽ được triển khai ở phần.then. Trong đó, .then cũng có 2 tham số tương ứng là phần triển khai của 2 hàm số resolve và reject phía trên.
Ngoài ra, bạn cũng có thể bỏ qua phần reject ở đây mà xử lý sau ở trong phần.catchcũng được."
672,XML Http request với Promise,XMLHttpRequest với Promise JavaScript,"Phần này mình đã làm một ví dụ sử dụng XMLHttpRequest để thực hiện phương thứcGETvới API cung cấp bởihttps://fcc-weather-api.glitch.me, để lấy thông tin thời tiết tại một điểm có kinh độ và vĩ độ xác định.

Trong ví dụ trên, bạn có thể nhập tọa độ kinh tuyến và vĩ tuyến, sau đó, nhấnrequestđể lấy thông tin thời tiết tại tọa độ đó. Khi request thành công, kết quả sẽ hiển thị lên màn hình.
Ngoài ra, bạn cũng có thể nhấnCtrl Shift IhoặcF12(tùy trình duyệt) để mởconsolecủa trình duyệt. Mình có ghi log ra đó.
Đối với hầu hết các trình duyệt, bạn có thể sử dụng trực tiếp đối tượng XMLHttpRequest của window. Nhưng đối với trình duyệt IE, bạn cần phải sử dụngActiveXObject(""Microsoft.XMLHTTP"")thay thế. Do đó, bạn cần định nghĩa lại XMLHttpRequest.

```js
let XMLHttpRequest =
  window.XMLHttpRequest || ActiveXObject(""Microsoft.XMLHTTP"");
```
`let XMLHttpRequest =
  window.XMLHttpRequest || ActiveXObject(""Microsoft.XMLHTTP"");` Đoạn code trên hiểu là: Nếu như trình duyệt có hỗ trợ XMLHttpRequest thì window.XMLHttpRequest sẽ khácundefined. Khi đó, ta có XMLHttpRequest = window.XMLHttpRequest. Ngược lại thì window.XMLHttpRequest sẽ là undefined nên XMLHttpRequest = ActiveXObject(""Microsoft.XMLHTTP"").
Đây là cách viết ngắn gọn nhấn. Nó tương đương với cách viết khác dài hơn là:

```js
let XMLHttpRequest = window.XMLHttpRequest
  ? window.XMLHttpRequest
  : ActiveXObject(""Microsoft.XMLHTTP"");
```
`let XMLHttpRequest = window.XMLHttpRequest
  ? window.XMLHttpRequest
  : ActiveXObject(""Microsoft.XMLHTTP"");` Hoặc:

```js
let XMLHttpRequest = window.XMLHttpRequest;
if (XMLHttpRequest == undefined)
  XMLHttpRequest = ActiveXObject(""Microsoft.XMLHTTP"");
```
`let XMLHttpRequest = window.XMLHttpRequest;
if (XMLHttpRequest == undefined)
  XMLHttpRequest = ActiveXObject(""Microsoft.XMLHTTP"");` Tóm lại, để tạo mới đối tượng XMLHttpRequest, bạn sẽ làm như sau:

```js
let XMLHttpRequest =
  window.XMLHttpRequest || ActiveXObject(""Microsoft.XMLHTTP"");

let xmlHttpRequest = new XMLHttpRequest();
```
`let XMLHttpRequest =
  window.XMLHttpRequest || ActiveXObject(""Microsoft.XMLHTTP"");

let xmlHttpRequest = new XMLHttpRequest();` Trong khuôn khổ bài viết này, mình sẽ viết lại phương thứcGET. Bạn có thể áp dụng một cách tương tự để viết các hàm số cho phương thứcPOST, PUT,...

```js
function get(requestURL) {
  return new Promise(function (resolve, reject) {
    let XMLHttpRequest =
      window.XMLHttpRequest || ActiveXObject(""Microsoft.XMLHTTP"");
    let req = new XMLHttpRequest();
    req.open(""GET"", requestURL, true);
    req.addEventListener(""load"", function () {
      if (req.status == 200) resolve(req.responseText);
      else if (req.status == 404) throw new Error(xmlPath, ""404"");
    });
    req.addEventListener(""error"", function (event) {
      reject(event);
    });
    req.send(null);
  });
}
```
`function get(requestURL) {
  return new Promise(function (resolve, reject) {
    let XMLHttpRequest =
      window.XMLHttpRequest || ActiveXObject(""Microsoft.XMLHTTP"");
    let req = new XMLHttpRequest();
    req.open(""GET"", requestURL, true);
    req.addEventListener(""load"", function () {
      if (req.status == 200) resolve(req.responseText);
      else if (req.status == 404) throw new Error(xmlPath, ""404"");
    });
    req.addEventListener(""error"", function (event) {
      reject(event);
    });
    req.send(null);
  });
}` Hàm số trên nhận tham số đầu vào là địa chỉ URL dùng để request lên server và kết quả trả về là một Promise. Tác vụ bất đồng bộ ở đây chính là XMLHttpRequest thực hiện GET đối với địa chỉ URL trên.
Khi request thành công, kết quả trả về vớistatus = 200, thì truyềnresponsevào hàm resolve. Ngược lại, request thất bại thì sẽ truyền giá trị lỗi cho hàm reject.
Với hàm số trên, bạn có thể sử dụng một cách đơn giản:

```js
let request = ""https://fcc-weather-api.glitch.me/api/current?lat=21&lon=105"";
get(request)
  .then(function (data) {
    console.log(data);
    $(""#result"").textContent = data.toString();
  })
  .catch(function (error) {
    console.log(error);
  });
```
`let request = ""https://fcc-weather-api.glitch.me/api/current?lat=21&lon=105"";
get(request)
  .then(function (data) {
    console.log(data);
    $(""#result"").textContent = data.toString();
  })
  .catch(function (error) {
    console.log(error);
  });` Khi thành công, kết quả data sẽ được ghi ra console và đổi giá trịtextContentcủa#resultvới data vừa nhận được trong phần.then. Ngược lại, khi có lỗi thì in ra kết quả error trên console trong phần.catch."
673,XML Http request với Promise,Kết luận,Trên đây là cách mà mình kết hợp XMLHttpRequest với Promise JavaScript. Bạn cũng hoàn toàn có thể sử dụng cách trên để áp dụng cho bất kì phương thức bất đồng bộ nào khác.
